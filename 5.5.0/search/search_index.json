{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Kamihi  <p> Python framework for rapid Telegram bot development and management </p> <p>This project is currently in the early stages of development. Expect frequent changes and updates as we work towards a stable release. Your feedback and contributions are welcome!</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#550-2025-11-21","title":"5.5.0 (2025-11-21)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>bot: datasource requests as templates (#94)</li> </ul>"},{"location":"changelog/#540-2025-11-20","title":"5.4.0 (2025-11-20)","text":""},{"location":"changelog/#feat_1","title":"Feat","text":"<ul> <li>datasources: column values can now be accessed using dot notation for sqlite datasources (#91)</li> </ul>"},{"location":"changelog/#530-2025-11-17","title":"5.3.0 (2025-11-17)","text":""},{"location":"changelog/#feat_2","title":"Feat","text":"<ul> <li>tg: added paginated messages (#87)</li> </ul>"},{"location":"changelog/#520-2025-11-16","title":"5.2.0 (2025-11-16)","text":""},{"location":"changelog/#feat_3","title":"Feat","text":"<ul> <li>bot: added scheduled actions (#79)</li> </ul>"},{"location":"changelog/#510-2025-11-02","title":"5.1.0 (2025-11-02)","text":""},{"location":"changelog/#feat_4","title":"Feat","text":"<ul> <li>questions: added question functionality (#75)</li> </ul>"},{"location":"changelog/#500-2025-10-05","title":"5.0.0 (2025-10-05)","text":""},{"location":"changelog/#refactor","title":"Refactor","text":"<ul> <li>base: made application settings a singleton object (#51)</li> </ul>"},{"location":"changelog/#410-2025-10-04","title":"4.1.0 (2025-10-04)","text":""},{"location":"changelog/#feat_5","title":"Feat","text":"<ul> <li>datasources: external database integrations (#46)</li> </ul>"},{"location":"changelog/#400-2025-10-03","title":"4.0.0 (2025-10-03)","text":""},{"location":"changelog/#feat_6","title":"Feat","text":"<ul> <li>db: use SQLAlchemy instead of MongoDB (#28)</li> </ul>"},{"location":"changelog/#300-2025-09-02","title":"3.0.0 (2025-09-02)","text":""},{"location":"changelog/#feat_7","title":"Feat","text":"<ul> <li>migrated to new organization</li> </ul>"},{"location":"changelog/#200-2025-07-13","title":"2.0.0 (2025-07-13)","text":""},{"location":"changelog/#breaking-change","title":"BREAKING CHANGE","text":"<ul> <li>removed <code>autoreload_templates</code> configuration option</li> </ul>"},{"location":"changelog/#feat_8","title":"Feat","text":"<ul> <li>bot: integrated templates with actions (#97)</li> </ul>"},{"location":"changelog/#120-2025-07-12","title":"1.2.0 (2025-07-12)","text":""},{"location":"changelog/#feat_9","title":"Feat","text":"<ul> <li>bot: support sending all media types (#94)</li> </ul>"},{"location":"changelog/#110-2025-06-04","title":"1.1.0 (2025-06-04)","text":""},{"location":"changelog/#feat_10","title":"Feat","text":"<ul> <li>bot: support sending files as action result (#78)</li> </ul>"},{"location":"changelog/#100-2025-05-27","title":"1.0.0 (2025-05-27)","text":""},{"location":"changelog/#feat_11","title":"Feat","text":"<ul> <li>cli: added first commands (#51)</li> </ul>"},{"location":"changelog/#080-2025-05-20","title":"0.8.0 (2025-05-20)","text":""},{"location":"changelog/#feat_12","title":"Feat","text":"<ul> <li>bot: user can now be requested in action function parameters (#48)</li> </ul>"},{"location":"changelog/#071-2025-05-18","title":"0.7.1 (2025-05-18)","text":""},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>tg: auth handler now calls check update of wrapped handler (#44)</li> </ul>"},{"location":"changelog/#070-2025-05-13","title":"0.7.0 (2025-05-13)","text":""},{"location":"changelog/#feat_13","title":"Feat","text":"<ul> <li>users: initial user functionality (#39)</li> </ul>"},{"location":"changelog/#060-2025-05-05","title":"0.6.0 (2025-05-05)","text":""},{"location":"changelog/#feat_14","title":"Feat","text":"<ul> <li>web: initial implementation (#36)</li> </ul>"},{"location":"changelog/#053-2025-05-02","title":"0.5.3 (2025-05-02)","text":""},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>tg: markdown escaping (#34)</li> </ul>"},{"location":"changelog/#052-2025-05-01","title":"0.5.2 (2025-05-01)","text":""},{"location":"changelog/#fix_2","title":"Fix","text":"<ul> <li>checking out latest ref instead of action ref</li> </ul>"},{"location":"changelog/#051-2025-05-01","title":"0.5.1 (2025-05-01)","text":""},{"location":"changelog/#fix_3","title":"Fix","text":"<ul> <li>added metadata to pyproject.toml</li> </ul>"},{"location":"changelog/#050-2025-05-01","title":"0.5.0 (2025-05-01)","text":""},{"location":"changelog/#feat_15","title":"Feat","text":"<ul> <li>bot: added (#27)</li> </ul>"},{"location":"changelog/#040-2025-04-17","title":"0.4.0 (2025-04-17)","text":""},{"location":"changelog/#feat_16","title":"Feat","text":"<ul> <li>tg: added (#19)</li> </ul>"},{"location":"changelog/#030-2025-04-01","title":"0.3.0 (2025-04-01)","text":""},{"location":"changelog/#feat_17","title":"Feat","text":"<ul> <li>templates: added (#14)</li> </ul>"},{"location":"changelog/#020-2025-03-28","title":"0.2.0 (2025-03-28)","text":""},{"location":"changelog/#feat_18","title":"Feat","text":"<ul> <li>base: added (#5)</li> </ul>"},{"location":"changelog/#011-2025-03-19","title":"0.1.1 (2025-03-19)","text":""},{"location":"changelog/#refactor_1","title":"Refactor","text":"<ul> <li>using new file header</li> </ul>"},{"location":"changelog/#010-2025-03-18","title":"0.1.0 (2025-03-18)","text":""},{"location":"changelog/#feat_19","title":"Feat","text":"<ul> <li>added pre-commit and ruff</li> <li>initial project setup</li> </ul>"},{"location":"changelog/#fix_4","title":"Fix","text":"<ul> <li>delete boilerplate code</li> </ul>"},{"location":"thanks/","title":"Special thanks","text":"<p>Special thanks to the following projects and people for their contributions to the development of this project:</p> <ul> <li>Python Telegram Bot</li> </ul>"},{"location":"dev/","title":"Index","text":"<p>This section of the documentation is aimed at developers contributing to the Kamihi project. It provides guidelines for understanding the architecture, setting up a development environment, and contributing effectively to the code and the documentation.</p>"},{"location":"dev/documentation/","title":"Documentation style guide","text":"<p>This guide details the documentation standards and contribution process for the Kamihi project, establishing clear guidelines to ensure consistency, clarity, and maintainability across all project documentation.</p>"},{"location":"dev/documentation/#intended-audiences","title":"Intended audiences","text":"<p>Documentation in this project serves multiple audiences: new users learning to use the tools, knowledgeable developers implementing features and new contributors seeking to understand the codebase. The documentation you write should take into account your intended audience.</p>"},{"location":"dev/documentation/#style-guide","title":"Style guide","text":""},{"location":"dev/documentation/#writing-principles","title":"Writing Principles","text":"<p>Clarity and Conciseness: Write for your future self and new contributors. Every sentence should serve a purpose. Remove unnecessary words and avoid redundant explanations.</p> <p>Active Voice: Use active voice consistently. Write \"Run the command\" instead of \"The command should be run.\"</p> <p>Present Tense: Document current functionality in present tense. Write \"The function returns\" instead of \"The function will return.\"</p>"},{"location":"dev/documentation/#language-standards","title":"Language Standards","text":"<p>Technical Terminology: Use precise technical terms consistently. When introducing new concepts, provide brief explanations or link to definitions.</p> <p>Code References: Use backticks for inline code, function names, file paths, and configuration values. Example: <code>uv run mkdocs serve</code> or <code>setup.md</code>.</p> <p>Commands and Examples: Provide complete, runnable examples. Include expected output when helpful for verification.</p>"},{"location":"dev/documentation/#formatting-conventions","title":"Formatting Conventions","text":"<p>Headers: Use sentence case for headers. Follow the established hierarchy: - <code>##</code> for main sections - <code>###</code> for subsections - <code>####</code> for detailed topics</p> <p>Note</p> <p>The first-level header (<code>#</code>) is filled by the documentation framework from the title in <code>mkdocs.yml</code>. Use <code>##</code> for the first-level sections of your document.</p> <p>Lists: Use bullet points for unordered information, numbered lists for sequential steps. Keep list items parallel in structure.</p> <p>Code Blocks: Specify language for syntax highlighting. Include the command prompt or expected environment when relevant:</p> <pre><code>&gt; uv run mkdocs serve\n</code></pre> <p>File Paths: Use relative paths when possible. Always include the filepath comment for documentation files.</p>"},{"location":"dev/documentation/#content-organization","title":"Content Organization","text":"<p>One Concept Per Section: Each section should focus on a single main idea that can be summarized in one sentence.</p> <p>Logical Flow: Structure content to build understanding progressively. Start with concepts, then provide implementation details.</p> <p>Cross-References: Link related sections and external resources. Use descriptive link text rather than \"click here.\" Always use relative links to maintain portability across environments.</p>"},{"location":"dev/documentation/#organization","title":"Organization","text":"<p>This project uses MkDocs with Material theme for documentation generation. The documentation follows a \"docs-as-code\" approach, versioned alongside the codebase.</p> <p>File Structure: - <code>/docs/</code> - All documentation source files - <code>/docs/tutorials/</code> - Step-by-step learning guides for new users - <code>/docs/guides/</code> - Task-oriented how-to documentation organized by topic - <code>/docs/reference/</code> - Technical reference material (CLI, API) - <code>/docs/explanation/</code> - Conceptual documentation and background theory - <code>/docs/dev/</code> - Developer-focused documentation for contributors - <code>/docs/images/</code> - Documentation assets and media files - <code>/docs/stylesheets/</code> - Custom CSS for documentation styling - <code>mkdocs.yml</code> - Site configuration and navigation structure</p>"},{"location":"dev/documentation/#contribution-workflow","title":"Contribution Workflow","text":"<p>Documentation Changes: Include documentation updates in the same pull request as related code changes. This ensures synchronization and provides context for reviewers.</p> <p>Review Process: Documentation changes undergo the same review process as code. Reviewers should verify accuracy, clarity, and adherence to style guidelines.</p> <p>Testing: Always test documentation locally before submitting. Verify that code examples work and links resolve correctly.</p>"},{"location":"dev/documentation/#documentation-live","title":"Documentation live","text":"<p>You can view the documentation on a local server with live reload. For that, and assuming you have the project set up following the setup guide, run:</p> <pre><code>uv run mkdocs serve\n</code></pre> <p>This will start a local server at <code>http://localhost:8000</code>, where you can see the documentation. The server will automatically reload when you make changes to the documentation files.</p>"},{"location":"dev/setup/","title":"Development setup","text":"<p>This guide will help you set up the development environment for the project.</p>"},{"location":"dev/setup/#prerequisites","title":"Prerequisites","text":"<p>You should have the following installed:</p> <ul> <li><code>git</code>, for version control. You can find download and installation instructions here.</li> <li><code>uv</code>, for managing virtual environments and dependencies. Install it using this guide.</li> <li>(optional) <code>docker</code> and <code>docker compose</code>. You can install Docker Desktop from here or follow the instructions for Docker Engine and Docker Compose.</li> </ul>"},{"location":"dev/setup/#setting-up-the-project","title":"Setting up the project","text":"<ol> <li>Clone the repository:     <pre><code>git clone https://github.com/kamihi-org/kamihi.git\ncd kamihi\n</code></pre></li> <li>Create the virtual environment and install dependencies:     <pre><code>uv sync --all-packages --all-groups\n</code></pre></li> <li>Activate the virtual environment by restarting your terminal or sourcing the <code>activate</code> file for your terminal type:     <pre><code># For bash/zsh\nsource .venv/bin/activate\n\n# For fish\nsource .venv/bin/activate.fish\n\n# For csh/tcsh\nsource .venv/bin/activate.csh\n\n# For powershell\n. .venv/Scripts/Activate.ps1\n</code></pre></li> <li>(optional) We recommend also setting up a test project to experiment with the framework and the code you write. Just create a new project using the CLI, and substitute the <code>pyproject.toml</code> file with this one:     <pre><code>[project]\nname = \"kamihi-example\"\nversion = \"0.0.0\"\ndescription = \"Kamihi project\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.12\"\ndependencies = [\n    \"kamihi\",\n]\n\n[tool.uv.sources]\nkamihi = { path = \"&lt;the path to the kamihi project&gt;\", editable = true }\n</code></pre></li> </ol> <p>For more information specific to documentation and testing, refer to the documentation guide and the testing guide.</p>"},{"location":"dev/testing/","title":"Testing","text":"<p>This guide explains how to run and develop tests for the Kamihi project.</p>"},{"location":"dev/testing/#functional-testing","title":"Functional testing","text":"<p>Note</p> <p>Functional tests make use of automated Docker container deployments, and thus are very resource-intensive. Make sure your machine is powerful enough to handle them.</p> <p>Warning</p> <p>As of the time of writing this documentation, it is not possible to run functional tests unless you have an iOS device for the initial setup. This is because for now creating test accounts can only be done through the Telegram app on iOS. This is a limitation of Telegram, not Kamihi.</p> <p>Functional tests are located in the <code>tests</code> directory. They are organized by feature, based loosely on the structure of the source code but not constrained by it.</p>"},{"location":"dev/testing/#setup","title":"Setup","text":"<p>Running functional tests requires a bit more setup, as they run on Telegram's test accounts (to avoid bans and FLOOD errors). To create the environment needed for them, you can follow these steps:</p> <ol> <li>Install the dependencies:     <pre><code>$ uv sync --group tests\n</code></pre></li> <li>Make sure you have Docker and Docker Compose installed on your machine.     <pre><code>$ docker --version\n$ docker compose --version\n</code></pre></li> <li>Create a <code>settings.yml</code> file in the <code>tests/</code> folder with the following content, which we will fill in as we go along:     <pre><code>KAMIHI_TESTING__BOT_TOKEN=\nKAMIHI_TESTING__BOT_USERNAME=\nKAMIHI_TESTING__USER_ID=/\nKAMIHI_TESTING__TG_PHONE_NUMBER=/\nKAMIHI_TESTING__TG_API_ID=/\nKAMIHI_TESTING__TG_API_HASH=/\nKAMIHI_TESTING__TG_SESSION=/\nKAMIHI_TESTING__TG_DC_ID=/\nKAMIHI_TESTING__TG_DC_IP=/\n</code></pre></li> <li>Go to your Telegram account's developer panel, sign in with your account, and create a new application.</li> <li>From the 'App configuration' section, you can obtain the values for <code>TG_API_ID</code> (App api_id) and <code>TG_API_HASH</code> (App api_hash).</li> <li>From the 'Available MTProto Servers' section, you can obtain the values for <code>TG_DC_IP</code> (Text field besides 'Test configuration:') and <code>TG_DC_ID</code> (Number just below the IP, prepended by 'DC'). Beware that <code>TG_DC_ID</code> is just the number, without the 'DC' prefix.</li> <li>You need an account on the test servers so you don't hit limitations or risk a ban on your main account. To create a test account:<ol> <li>Get the Telegram app on iOS, if you don't have it already, and log in with your main account (or with any account, really).</li> <li>Tap the Settings icon in the bottom bar ten times to access the developer settings.</li> <li>Select 'Accounts', then 'Login to another account', then 'Test'</li> <li>Input your phone number (must be a valid number that can receive SMS) and tap 'Next', confirm the phone and input the code you receive via SMS.</li> </ol> </li> <li>(optional) You can log in with the test account on the desktop application following this steps:<ol> <li>Go to the sidebar</li> <li>While holding Alt and Shift, right-click on the 'Add account' button</li> <li>Select 'Test server'</li> <li>Log in by scanning the QR code from the Telegram app on iOS that has the test account</li> </ol> </li> <li>Once you hace the test account created, you can fill the value for <code>TG_PHONE_NUMBER</code> with the one you used for the test account, including international prefix and no spaces or other characters, e.g. +15559786475.</li> <li>Now you must obtain your test account's Telegram User ID. The easiest is to message one of the many bots that will provide it for you, like this one. This value corresponds to the `USER_ID' environment variable.</li> <li>For the tests to be able to log in without any user input, two-factor authentication must be skipped. For that to happen, we need a session token. We have a script for that, so to obtain the token, run the following command from the root of the project after having filled in all the values from the previous steps in the <code>.env</code> file:     <pre><code>$ uv run tests/utils/get_string_session.py\n</code></pre>     This value can then be added to the <code>.env</code> file in the <code>TG_SESSION</code> variable.</li> <li>Last, but not least, we need a bot to test on. From your test account, talk to the @BotFather and fill in the <code>BOT_TOKEN</code> and <code>BOT_USERNAME</code> values in the <code>.env</code> file.</li> </ol> <p>Once this odyssey has been completed, you should be able to run the functional tests with the following command:</p> <pre><code>$ uv run pytest\n</code></pre>"},{"location":"dev/testing/#available-fixtures","title":"Available fixtures","text":"<p>The functional test suite provides fixtures grouped by module:</p>"},{"location":"dev/testing/#container-management-fixtures-testsfixturesdocker_container","title":"Container management fixtures (<code>tests.fixtures.docker_container</code>)","text":"<ul> <li><code>db_url</code>: Database URL used by the container (defaults to <code>sqlite:///./kamihi.db</code>). For ad\u2011hoc queries, use <code>kamihi_container.query_db(sql)</code>.</li> <li><code>kamihi_container</code>: Custom KamihiContainer with enhanced logging and helper methods:<ul> <li><code>command_logs: list[str]</code>: In\u2011memory chronological log of every command executed and every line observed while waiting for logs; printed automatically on test failure.</li> <li><code>EndOfLogsException</code>: Raised by waiting helpers if the log stream ends before the expected entry is found.</li> <li><code>parse_log_json(line: str) -&gt; dict | None</code>: Parse a structured (JSON\u2011serialized) log line. Ensures required keys exist; returns dict or None if invalid.</li> <li><code>wait_for_log(stream, message, level=\"INFO\", extra_values: dict[str, Any] | None = None, parse_json: bool = True) -&gt; dict | str</code>: Consume a Docker log stream until a line matches. If <code>parse_json</code> is True, matches on structured log record (level + substring in message + optional key/value pairs inside <code>record.extra</code>). If <code>parse_json</code> is False, performs a plain substring match and returns the raw line.</li> <li><code>wait_for_message(message: str, stream=None) -&gt; str</code>: Convenience wrapper for plain\u2011text (non\u2011JSON) message search.</li> <li><code>run_command(command: str) -&gt; CancellableStream</code>: Execute a command inside the container (<code>docker exec</code>) and return the live output stream (bytes iterator). Also appends <code>$ &lt;command&gt;</code> to <code>command_logs</code>.</li> <li><code>run_command_and_wait_for_log(command, message, level=\"INFO\", extra_values=None, parse_json=True) -&gt; dict | str</code>: Fire a command then immediately wait for a matching log/message (delegates to the two helpers above).</li> <li><code>run_command_and_wait_for_message(command, message) -&gt; str</code>: Plain\u2011text variant of the previous helper.</li> <li><code>uv_sync(command: str = \"uv sync\") -&gt; None</code>: Runs dependency sync.</li> <li><code>db_migrate(command: str = \"kamihi db migrate\") -&gt; None</code>: Applies migrations; waits for structured log containing <code>Migrated</code> at <code>SUCCESS</code> level.</li> <li><code>db_upgrade(command: str = \"kamihi db upgrade\") -&gt; None</code>: Applies any pending schema upgrades; waits for <code>Upgraded</code> at <code>SUCCESS</code> level.</li> <li><code>start(command: str = \"kamihi run\") -&gt; None</code>: Starts the Kamihi app; waits for <code>Started!</code> at <code>SUCCESS</code> level.</li> <li><code>stop() -&gt; None</code>: Terminates the running process with <code>SIGKILL</code> (fast, deterministic teardown for tests).</li> <li><code>query_db(sql: str) -&gt; list[tuple]</code>: Copies the SQLite DB file out of the container to a temp file and executes a read query; returns rows. (Write statements are not intended; treat as read\u2011only.)</li> </ul> </li> <li><code>kamihi</code>: Ensures the container is synced, migrated, upgraded, started, and properly stopped around each test. This is the main fixture to use in tests (instead of <code>kamihi_container</code>, which should be used only if lifecycle control is needed).</li> <li><code>cleanup</code>: Session\u2011scoped, autouse; prunes containers, volumes, and images after the session and prints a summary.</li> </ul>"},{"location":"dev/testing/#docker-mountable-app-files-fixtures-testsfixturesdocker_files","title":"Docker-mountable app files fixtures (<code>tests.fixtures.docker_files</code>)","text":"<p>These fixtures provide the content mounted into the container. All return dictionaries where keys are file paths and values are file contents. Directories are created automatically. Override them to provide custom content:</p> <ul> <li><code>pyproject_extra_dependencies</code>: Extra dependency list injected into pyproject.toml. Override to add dependencies.</li> <li><code>pyproject</code>: {\"pyproject.toml\": \"...\"} including kamihi as dependency and Alembic config. Override to change project configuration, but be sure to include the original content to avoid problems.</li> <li><code>config_file</code>: {\"kamihi.yaml\": \"...\"}. Override to change kamihi configuration.</li> <li><code>actions_folder</code>: Dict representing actions; keys relative to actions/. Override to provide custom actions.</li> <li><code>models_folder</code>: Dict representing models; keys relative to models/. Override to provide custom models.</li> <li><code>migrations_folder</code>: Dict representing Alembic migrations; keys relative to migrations/. Don't override unless you know what you're doing.</li> <li><code>app_folder</code>: Combines all the above for container mounting. Do not override unless necessary.</li> </ul>"},{"location":"dev/testing/#app-utilities-and-commands-testsfixturesapp","title":"App utilities and commands (<code>tests.fixtures.app</code>)","text":"<ul> <li><code>admin_page</code>: Async Playwright Page for the Kamihi admin interface. </li> <li><code>user_custom_data</code>: Dict for custom user data (empty by default). Override to provide custom data to add in <code>user</code>.</li> <li><code>user</code>: Creates a user with the configured test user_id; yields the created user details.</li> <li><code>add_permission_for_user</code>: Yields a function to add a permission to a user for a specific action.</li> <li><code>add_role</code>: Yields a function to create a role.</li> <li><code>assign_role_to_user</code>: Yields a function to assign an existing role to a user.</li> </ul>"},{"location":"dev/testing/#telegram-client-fixtures-testsfixturestg","title":"Telegram client fixtures (<code>tests.fixtures.tg</code>)","text":"<ul> <li><code>tg_client</code>: Session\u2011scoped Telethon client using test settings and test DC. Don't use directly; use <code>chat</code> instead.</li> <li><code>chat</code>: Session\u2011scoped Conversation opened with the test bot.</li> </ul>"},{"location":"dev/testing/#testing-settings-testsfixturessettings","title":"Testing settings (<code>tests.fixtures.settings</code>)","text":"<ul> <li><code>test_settings</code>: Provides a TestingSettings instance populated from environment variables (<code>KAMIHI_TESTING__*</code>).</li> </ul>"},{"location":"dev/testing/#using-the-fixtures","title":"Using the fixtures","text":""},{"location":"dev/testing/#basic-test-structure","title":"Basic test structure","text":"<p>Most functional tests follow this pattern:</p> <pre><code>@pytest.mark.asyncio\n@pytest.mark.usefixtures(\"kamihi\")\nasync def test_my_feature(user_in_db, add_permission_for_user, chat):\n    \"\"\"Test description.\"\"\"\n    # Setup permissions\n    add_permission_for_user(user_in_db[\"telegram_id\"], \"my_action\")\n\n    # Test interaction\n    await chat.send_message(\"/my_command\")\n    response = await chat.get_response()\n\n    # Assertions\n    assert response.text == \"expected response\"\n</code></pre>"},{"location":"dev/testing/#overriding-fixtures","title":"Overriding fixtures","text":""},{"location":"dev/testing/#file-level-overrides","title":"File-level overrides","text":"<p>Override fixtures for an entire test file by redefining the fixture:</p> <pre><code>@pytest.fixture\ndef actions_folder():\n    \"\"\"Custom actions for all tests in this file.\"\"\"\n    return {\n        \"start/__init__.py\": \"\",\n        \"start/start.py\": \"\"\"\\\n            from kamihi import bot\n\n            @bot.action\n            async def start():\n                return \"Hello World!\"\n        \"\"\",\n    }\n\ndef test_my_feature(kamihi, chat):\n    # All tests in this file use the overridden fixtures\n    pass\n</code></pre>"},{"location":"dev/testing/#function-level-overrides","title":"Function-level overrides","text":"<p>Override fixtures for specific tests by decorating individual functions:</p> <pre><code>@pytest.mark.parametrize(\"user_custom_data\", [{\"name\": \"John Doe\"}])\n@pytest.mark.parametrize(\n    \"models_folder\",\n    [\n        {\n            \"user.py\": \"\"\"\\\n                from kamihi.db import BaseUser\n                from sqlalchemy import Column, String\n\n                class User(BaseUser):\n                    __table_args__ = {'extend_existing': True}\n                    name = Column(String, nullable=True)\n            \"\"\",\n        }\n    ],\n)\nasync def test_custom_user_model(user_in_db, chat, models_folder):\n    # This test uses custom user model and data\n    pass\n</code></pre>"},{"location":"dev/testing/#common-patterns","title":"Common patterns","text":""},{"location":"dev/testing/#using-test-media-files","title":"Using test media files","text":"<p>You can use the provided utility functions to add media files to your tests:</p> <pre><code>@pytest.mark.asyncio\n@pytest.mark.usefixtures(\"kamihi\")\n@pytest.mark.parametrize(\n    \"actions_folder\",\n    [\n        (\n            {\n                \"start/__init__.py\": \"\",\n                \"start/start.py\": \"\"\"\\\n                    from pathlib import Path\n                    from kamihi import bot\n\n                    @bot.action\n                    async def start() -&gt; list[bot.Photo]:\n                        return [\n                            bot.Photo(Path(\"actions/start/image.jpg\")),\n                            bot.Video(Path(\"actions/start/video.mp4\")),\n                            bot.Audio(Path(\"actions/start/audio.mp3\")),\n                            bot.Voice(Path(\"actions/start/audio.m4a\")),\n                        ]\n                \"\"\",\n                \"start/image.jpg\": random_image(),\n                \"start/video.mp4\": random_video_path().read_bytes(),\n                \"start/audio.mp3\": random_audio_path().read_bytes(),\n                \"start/audio.m4a\": random_voice_note_path().read_bytes(),\n            },\n        ),\n    ]\n)\nasync def test(..., actions_folder): ...\n</code></pre>"},{"location":"dev/testing/#testing-cli-commands","title":"Testing CLI commands","text":"<pre><code>def test_cli_validation(kamihi):\n    \"\"\"Test invalid CLI parameters.\"\"\"\n    kamihi.run_command_and_wait_for_message(\n        \"kamihi run --port=invalid\",\n        \"Invalid value for '--port'\"\n    )\n</code></pre> <p>If testing the <code>kamihi run</code> command, you can override the <code>run_command</code> fixture to avoid starting the application twice, which will generate conflicts:</p> <pre><code>@pytest.fixture\ndef run_command():\n    \"\"\"Override to test CLI without full application startup.\"\"\"\n    return \"sleep infinity\"\n</code></pre>"},{"location":"dev/testing/#testing-web-interface","title":"Testing web interface","text":"<pre><code>@pytest.mark.asyncio\nasync def test_web_feature(admin_page):\n    \"\"\"Test admin interface functionality.\"\"\"\n    await admin_page.get_by_role(\"link\", name=\"Users\").click()\n    await admin_page.get_by_role(\"button\", name=\"+ New User\").click()\n    # Continue with Playwright interactions\n</code></pre>"},{"location":"dev/testing/#testing-bot-actions-with-custom-code","title":"Testing bot actions with custom code","text":"<pre><code>@pytest.mark.parametrize(\n    \"actions_folder\",\n    [\n        {\n            \"greet/__init__.py\": \"\",\n            \"greet/greet.py\": \"\"\"\\\n                from kamihi import bot\n\n                @bot.action\n                async def greet(user):\n                    return f\"Hello {user.telegram_id}!\"\n            \"\"\",\n        }\n    ],\n)\nasync def test_greeting(user_in_db, add_permission_for_user, chat, actions_folder):\n    \"\"\"Test custom greeting action.\"\"\"\n    add_permission_for_user(user_in_db[\"telegram_id\"], \"greet\")\n\n    await chat.send_message(\"/greet\")\n    response = await chat.get_response()\n\n    assert str(user_in_db['telegram_id']) in response.text\n</code></pre>"},{"location":"dev/testing/#best-practices","title":"Best practices","text":"<ul> <li>Use <code>@pytest.mark.usefixtures(\"kamihi\")</code> when you need the container running but don't directly interact with it</li> <li>Always add permissions before testing bot actions using <code>add_permission_for_user</code>, otherwise the bot will respond with the default message.</li> <li>Use <code>dedent()</code> for multiline code strings to maintain readable indentation</li> <li>Override <code>run_command</code> to <code>\"sleep infinity\"</code> when testing CLI without full application startup</li> <li>Parametrize at file level when multiple tests need the same overrides</li> <li>Do not use test classes; functional tests should be simple functions</li> <li>Use meaningful test descriptions that explain the specific scenario being tested</li> <li>Use <code>wait_for_log</code> with specific log levels, messages and extra dictionary contents, if there should be any.</li> </ul>"},{"location":"dev/testing/#unit-testing","title":"Unit testing","text":"<p>Unit tests are currently not implemented. They may be added in the future, although with the current architecture of the project, they would be highly complex to set up and maintain, and thus not worth the effort.</p>"},{"location":"dev/guides/create-datasource/","title":"Create a new datasource type","text":"<p>This guide explains how to implement a new data source type. </p> <p>Data source types are classes that inherit from the <code>kamihi.base.datasources.DataSource</code> class. They define how to connect to, and disconnect from, the data source, execute queries, and return results.</p> <p>Each data source type has also an associated configuration class that inherits from <code>kamihi.base.datasources.DataSourceConfig</code>. This class defines the configuration options required for that data source type.</p> <p>Data source types live in the <code>src/kamihi/datasources</code> directory. Each type, along with its configuration class, should be defined in a separate file, following the naming convention <code>&lt;datasource_name&gt;.py</code>.</p>"},{"location":"dev/guides/create-datasource/#implementing-the-data-source-configuration-class","title":"Implementing the data source configuration class","text":"<p>The data source configuration class should inherit from <code>kamihi.datasources.DataSourceConfig</code>. It should define the required configuration options for the data source type. Since the base configuration class is a <code>pydantic</code> model, you can use its features to define the configuration options.</p> <p>The configuration class MUST include the attribute <code>type</code> with the type set to <code>Literal[\"&lt;datasource_name&gt;\"]</code> and the value set to the name of the data source type. This is used by Kamihi to identify the data source type when loading the configuration.</p> <p>For example, if you are implementing a new data source type called <code>MyDataSource</code>, you would create a file named <code>my_datasource.py</code> in the <code>src/kamihi/datasources</code> directory and define the configuration class like this:</p> <pre><code>from kamihi.datasources import DataSourceConfig\nfrom typing import Literal\n\nclass MyDataSourceConfig(DataSourceConfig):\n    \"\"\"\n    Configuration model for MyDataSource.\n\n    Attributes:\n        option1 (str): Description of option1.\n        option2 (int): Description of option2. Default is 42.\n    \"\"\"\n    type: Literal[\"my_datasource\"] = \"my_datasource\"\n\n    option1: str\n    option2: int = 42  # Default value\n</code></pre> <p>Info</p> <p>Be sure to correctly document all the configuration options in the class docstring, as this will be used to generate the documentation for the data source type.</p>"},{"location":"dev/guides/create-datasource/#implementing-the-data-source-type-class","title":"Implementing the data source type class","text":"<p>The data source type class should inherit from <code>kamihi.datasources.DataSource</code>. It should implement the following methods:</p> <ul> <li><code>async def connect(self): ...</code>: Establishes a connection to the data source.</li> <li><code>async def fetch(self, query: str | Path) -&gt; list[dict]: ...</code>: Executes a query and returns the results as a list of dictionaries.</li> <li><code>async def disconnect(self): ...</code>: Closes the connection to the data source.</li> </ul> <p>The class has access to the configuration options defined in the configuration class through the <code>self.config</code> attribute, which is an instance of the configuration class defined earlier.</p> <p>For example, continuing with the <code>MyDataSource</code> example, you would implement the data source type class like this:</p> <pre><code>from kamihi.datasources import DataSource\nfrom pathlib import Path\n\nclass MyDataSource(DataSource):\n    async def connect(self):\n        # Implement the logic to establish a connection to the data source\n        self.connection = \"Connected to MyDataSource\"  # Placeholder for actual connection logic\n        print(self.connection)\n\n    async def fetch(self, query: str | Path) -&gt; list[dict]:\n        # Implement the logic to execute the query and return results\n        print(f\"Executing query: {query}\")\n        return [{\"result\": \"data from MyDataSource\"}]  # Placeholder for actual query results\n\n    async def disconnect(self):\n        # Implement the logic to close the connection to the data source\n        print(\"Disconnecting from MyDataSource\")\n        self.connection = None\n</code></pre> <p>The <code>kamihi.base.utils</code> package provides utility functions to help with common tasks, such as timing requests and handling exceptions. You can use these utilities in your data source type implementation as needed. Consult one of the existing data source types for examples of how to use these utilities.</p>"},{"location":"dev/guides/create-datasource/#handling-dependencies","title":"Handling dependencies","text":"<p>Each datasource type has its own set of dependencies, and these are normally heavy and not needed for all Kamihi applications. To avoid unnecessary dependencies in user installations, you should define any dependencies in a separate dependency group in the <code>pyproject.toml</code> file or when using <code>uv</code> to add them to the framework.</p> <p>For example, if your data source type requires the <code>requests</code> library:</p> pyproject.tomlUsing <code>uv</code>'s CLI <pre><code>[project.optional-dependencies]\nmy_datasource = [\n    \"requests&gt;=2.25.1\"\n]\nall = [\n    \"requests&gt;=2.25.1\",  # Include in the 'all' group\n    # other dependencies...\n]\n</code></pre> <pre><code>uv add --optional my_datasource --optional all requests&gt;=2.25.1\n</code></pre> <p>Info</p> <p>Remember to also add the dependency to the <code>all</code> optional dependencies group.</p> <p>Since the dependencies are optional, users may try to use the data source type without having the required dependencies installed.</p> <p>To avoid this, you should decorate every method that requires the dependencies with the <code>@requires(\"&lt;optional_group_name&gt;\")</code> decorator from <code>kamihi.base.utils</code> and import the required dependencies inside the method. This decorator will raise an exception if the required dependencies are not installed, providing a clear error message to the user.</p> <pre><code>from kamihi.base.utils import requires\n\nclass MyDataSource(DataSource):\n    @requires(\"my_datasource\")\n    async def connect(self):\n        import requests  # Importing inside the method will ensure the dependency is available\n        # Implement the logic to establish a connection to the data source\n        self.connection = \"Connected to MyDataSource\"  # Placeholder for actual connection logic\n        print(self.connection)\n</code></pre>"},{"location":"dev/guides/create-datasource/#registering-the-data-source-type","title":"Registering the data source type","text":"<p>Once you have implemented the data source type and its configuration class, you need to register it with Kamihi. This is done by adding the data source type to the <code>kamihi.datasources</code> module's <code>__all__</code> list.</p> <pre><code>from kamihi.datasources.my_datasource import MyDataSource, MyDataSourceConfig\n\n__all__ = [\n    ..., # other existing data sources\n    \"MyDataSource\", \n    \"MyDataSourceConfig\"\n]\n</code></pre>"},{"location":"dev/guides/create-datasource/#testing-your-data-source-type","title":"Testing your data source type","text":"<p>To ensure your data source type works correctly, you should write unit and functional tests for it. Refer to the Testing guide for more information on how to write tests for Kamihi.</p>"},{"location":"dev/guides/create-datasource/#checklist","title":"Checklist","text":"<ul> <li> Define any dependencies as optional in the <code>pyproject.toml</code> or using <code>uv</code>.</li> <li> Implement the data source configuration class.</li> <li> Implement the data source type class.</li> <li> Register the data source type in <code>kamihi.datasources</code>.</li> <li> Write unit and functional tests for your data source type.</li> <li> Add your datasource config type to the table in the Configure datasources guide.</li> <li> Create a pull request with your changes.</li> </ul>"},{"location":"guides/","title":"Index","text":"<p>In this section, we will cover some of the most common use cases for Kamihi, providing guides on how to implement them.</p>"},{"location":"guides/key-concepts/","title":"Key concepts","text":"<p>These are the most important concepts and definitions used throughout this documentation.</p>"},{"location":"guides/key-concepts/#action","title":"Action","text":"<p>An action is, in its most basic terms, something you can do with your bot. You are in charge of defining them.</p>"},{"location":"guides/key-concepts/#command","title":"Command","text":"<p>A command is a string sent to your bot through Telegram that executes an action. They are always prefixed with a slash (for example, <code>/start</code> or <code>/hello</code>). </p> <p>Info</p> <p>An action may have many commands assigned.</p>"},{"location":"guides/key-concepts/#user","title":"User","text":"<p>A user is someone that has been registered in the framework. Only they can use the actions you define.</p>"},{"location":"guides/key-concepts/#role","title":"Role","text":"<p>A role is, in essence, a group of users. Roles are most commonly used to grant them permission to use actions. Many users can have one role, and users can also have many roles.</p>"},{"location":"guides/key-concepts/#permission","title":"Permission","text":"<p>A permission is a record that tells the bot which users and roles can use which actions. You can have many permissions for each action, each targeting as many users and roles as you want.</p>"},{"location":"guides/actions/ask-questions/","title":"Ask questions","text":"<p>This guide explains how to use questions to obtain data from users with your bot.</p>"},{"location":"guides/actions/ask-questions/#asking-questions","title":"Asking questions","text":"<p>To ask a question to a user, add a new parameter to your action and annotate it with a type from <code>kamihi.questions</code>. For example:</p> <pre><code>from kamihi import bot\nfrom kamihi.questions import String\nfrom typing import Annotated\n\n@bot.action\nasync def greet_user(\n        name: Annotated[ # (1)!\n            str, # (2)!\n            String(\"What is your name?\") # (3)!\n        ]\n) -&gt; str:\n    return f\"Hello, {name}!\"\n</code></pre> <ol> <li>With Annotated we can add metadata to the parameter <code>name</code>.</li> <li>We specify that the type of <code>name</code> will be <code>str</code>.</li> <li>We use the <code>String</code> question type to ask the user for their name.</li> </ol> <p>When the user executes the command <code>/greet_user</code>, the bot will ask \"What is your name?\". Once the user responds, the bot will greet them with their name.</p>"},{"location":"guides/actions/ask-questions/#available-question-types","title":"Available question types","text":"<p>Kamihi provides several base question types to handle different kinds of user input:</p> <ul> <li><code>String</code>: Asks for a text input. Can include optional validation for length or regex patterns.</li> <li><code>Integer</code>: Asks for an integer input. Can include optional validation for range or multiples.</li> <li><code>Boolean</code>: Asks for a yes/no input. The responses accepted as \"yes\" or \"no\" can be customized.</li> <li><code>Choice</code>: Asks the user to select from a list of options. Can be presented as a custom keyboard or as inline buttons for easier selection.</li> <li><code>DynamicChoice</code>: Similar to <code>Choice</code>, but the options are generated dynamically from a request to a datasource.</li> <li><code>Datetime</code>, <code>Date</code>, <code>Time</code>: Asks for date and/or time input. Can include optional validation for ranges or past/future dates, and can parse various formats by using the library <code>dateparser</code>.</li> <li><code>File</code>: Asks the user to upload a file. Can specify allowed file types and maximum file size.</li> <li><code>Image</code>: Asks the user to upload an image. Can specify allowed image formats, maximum dimensions, and file size.</li> </ul> <p>To use these question types, simply import them from <code>kamihi.questions</code> and annotate your action parameters as shown in the example above. Consult the API reference for detailed information on each question type and their available options.</p> <p>A note on using <code>DynamicQuestion</code></p> <p>When using <code>DynamicQuestion</code>, a path to a request file has to be specified. The file name should follow the same rules described in the guide on data sources. If the path specified is relative, it will be assumed to be relative to a folder <code>questions</code> in the root of the project.</p>"},{"location":"guides/actions/commands/","title":"Set commands","text":"<p>This guide explains how command names are assigned from actions and how to customize them.</p>"},{"location":"guides/actions/commands/#default-command","title":"Default command","text":"<p>When decorating a function to turn it into an action, the command will be the name of the function. For example:</p> <pre><code>from kamihi import bot\n\n@bot.action\nasync def test() -&gt; str:\n    return \"Test successful!\"\n</code></pre> <p>This code will register the command <code>/test</code> on Telegram.</p>"},{"location":"guides/actions/commands/#changing-the-default-command","title":"Changing the default command","text":"<p>Sometimes we do not want to use the name of the function name as our command. We can easily change it by passing the command we want to the decorator:</p> <pre><code>from kamihi import bot\n\n@bot.action(\"hello\")\nasync def test() -&gt; str:\n    return \"Test successful!\"\n</code></pre> <p>This will register the command <code>/hello</code> instead of the command <code>/test</code> in Telegram.</p>"},{"location":"guides/actions/commands/#assigning-multiple-commands","title":"Assigning multiple commands","text":"<p>Extending the previous example, we can easily assign multiple commands to an action by passing them to the decorator:</p> <pre><code>from kamihi import bot\n\n@bot.action(\"hello\", \"hola\", \"allo\")\nasync def test() -&gt; str:\n    return \"Test successful!\"\n</code></pre> <p>With this code, all three commands will be registered in Telegram and all will execute the same function <code>test()</code>. </p> <p>Info</p> <p>In this case the function name will not be registered as a command.</p>"},{"location":"guides/actions/custom-questions/","title":"Create custom questions","text":"<p>This guide explains how to create custom reusable questions in Kamihi, allowing you to encapsulate complex validation and logic that can be reused across multiple actions.</p>"},{"location":"guides/actions/custom-questions/#creating-custom-reusable-questions","title":"Creating custom reusable questions","text":"<p>Sometimes, the same question is used in multiple actions, and might have complex validation or other logic. In these cases, it is recommended to create a custom question class that can be reused across actions.</p> <p>Custom questions live in the <code>questions</code> folder in the root of your Kamihi project.</p> <p>To create a custom question, create a new Python file in the <code>questions</code> folder in the root of your Kamihi project and define a class that inherits from one of the base question types. For example:</p> <pre><code>from kamihi.questions import String\n\nclass EmailQuestion(String):\n    def __init__(self, prompt: str):\n        super().__init__(\n            prompt,\n            pattern=r\"^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$\",\n            error_text=\"Please enter a valid email address.\"\n        )\n</code></pre> <p>This custom question <code>EmailQuestion</code> inherits from <code>String</code> and adds a regex pattern to validate that the input is a valid email address.</p> <p>You can then use this custom question in your actions by importing it:</p> <pre><code>from kamihi import bot\nfrom typing import Annotated\n\nfrom questions.email_question import EmailQuestion\n\n@bot.action\nasync def register_user(\n        email: Annotated[\n            str,\n            EmailQuestion(\"What is your email address?\")\n        ]\n) -&gt; str:\n    return f\"Registered email: {email}\"\n</code></pre> Cleaner imports <p>Right now, if you want to use both standard and custom questions in your actions, you will need to import them separately.</p> <pre><code>from kamihi.questions import String, Integer\nfrom questions.email_question import EmailQuestion\n</code></pre> <p>To keep your imports cleaner, you can create an <code>__init__.py</code> file in the <code>questions</code> folder that re-exports your custom questions along with the standard ones. For example:</p> <pre><code>from kamihi.questions import *\nfrom .email_question import EmailQuestion\n</code></pre> <p>This way, you can import all questions from the <code>questions</code> folder with a single import statement:     <code>python from questions import EmailQuestion, String, Integer</code></p>"},{"location":"guides/actions/custom-questions/#complex-validation","title":"Complex validation","text":"<p>For more complex validation logic that cannot be easily handled with regex patterns or simple checks, there are several methods you can override in your custom question classes:</p> <ul> <li><code>validate_before(self, response: Any) -&gt; Any</code>: This method is called before any built-in validation and type casting. You can use it to implement custom pre-validation logic.</li> <li><code>validate_after(self, response: Any) -&gt; Any</code>: This method is called after built-in validation and type casting. You can use it to implement custom post-validation logic.</li> <li><code>_validate_internal(self, response: Any) -&gt; Any</code>: This method is where the built-in validation logic is implemented. Only override this method when you are creating a completely custom question that inherits directly from the <code>Question</code> base type.</li> <li><code>validate(self, response: Any) -&gt; Any</code>: This is the main validation method that is called when validating a response. It calls <code>validate_before</code>, the built-in validation logic, and <code>validate_after</code> in sequence. You can override this method to customize the entire validation process.</li> </ul> <p>On all validators, you can raise a <code>ValueError</code> with a custom error message to indicate that the validation has failed. The error message specified for the <code>ValueError</code> will be sent to the user, and they can try to answer the question again.</p> <p>For example, here is a custom question that asks for a color but does not allow the color \"red\":</p> <pre><code>from kamihi.questions import String\n\nclass NoRedColorQuestion(String):\n    def validate_after(self, response: str) -&gt; str:\n        if response.lower() == \"red\":\n            raise ValueError(\"The color red is not allowed.\")\n        return response\n</code></pre> <p>Another example: a date choice that does not allow weekends:</p> <pre><code>from kamihi.questions import Date\nimport datetime\n\nclass WeekdayDateQuestion(Date):\n    def validate_after(self, response: datetime.date) -&gt; datetime.date:\n        if response.weekday() &gt;= 5:  # 5 = Saturday, 6 = Sunday\n            raise ValueError(\"Please choose a weekday (Monday to Friday).\")\n        return response\n</code></pre> <p>Another example: a string question that asks for the user's full name, makes it title case before validation, and ensures that it contains at least two words:</p> <pre><code>from kamihi.questions import String\n\nclass FullNameQuestion(String):\n    def validate_before(self, response: str) -&gt; str:\n        # Convert to title case before validation\n        return response.title()\n\n    def validate_after(self, response: str) -&gt; str:\n        # Ensure the name contains at least two words\n        if len(response.split()) &lt; 2:\n            raise ValueError(\"Please enter your full name (at least first and last name).\")\n        return response\n</code></pre> <p>Yet another example: a dynamic choice question that always uses the same request (so you avoid specifying it every time):</p> <pre><code>from kamihi.questions import DynamicChoice\n\nclass CountryChoiceQuestion(DynamicChoice):\n    def __init__(self, *args, **kwargs):\n        super().__init__(\n            *args,\n            **kwargs,\n            request=\"countries.geographic_db.sql\"  # Path to the request file inside the `questions` folder\n        )\n</code></pre>"},{"location":"guides/actions/custom-questions/#further-customizing-custom-questions","title":"Further customizing custom questions","text":"<p>In addition to validation, you can further customize your custom question classes by overriding other methods and properties from the base question types. Some useful methods and properties you might want to override include:</p> <ul> <li><code>ask_question(self, update: Update, context: Context) -&gt; None</code>: This method is responsible for sending the question prompt to the user. You can override it to customize how the question is presented.</li> <li><code>filters(self) -&gt; filters.BaseFilter</code> (property): This property returns a list of filters from <code>python-telegram-bot</code> that are applied to the user's response. You can override it to add custom filters for the responses, so that only valid responses are processed, while the rest are ignored.</li> <li><code>get_response(self, update: Update, context: Context) -&gt; Any</code>: This method extracts the user's response from the update object. You can override it to customize how the response is retrieved.</li> </ul> <p>To consult the full list of methods and properties available for customization, refer to the API reference for the <code>Question</code> base class.</p>"},{"location":"guides/actions/send-media/","title":"Send media and files","text":"<p>This guide details how to send any type of media supported by Kamihi.</p>"},{"location":"guides/actions/send-media/#sending-media","title":"Sending media","text":"<p>There are two ways of sending media using Kamihi:</p> <ul> <li>Implicit: you return a <code>Path</code> object in your function, and the framework automatically detects the best way of sending the file.</li> <li>Explicit: you return a <code>bot.Media</code> subclass that tells the framework how to treat the file.</li> </ul> ImplicitExplicit <pre><code>from kamihi import bot\nfrom pathlib import Path\n\n@bot.action\nasync def start() -&gt; Path:\n    return Path(\"actions/start/file.txt\")\n</code></pre> <pre><code>from kamihi import bot\nfrom pathlib import Path\n\n@bot.action\nasync def start() -&gt; bot.Document:\n    return bot.Document(\"actions/start/file.txt\")\n</code></pre> <p>Warning</p> <p>Only media types based on files can be sent implicitly.</p>"},{"location":"guides/actions/send-media/#supported-media-types","title":"Supported media types","text":"<p>Kamihi supports sending the following media types:</p> Media Type Allowed formats Max. size Notes Documents <code>bot.Document</code> Any 50MB Default sending mode Photos <code>bot.Photo</code> JPG  PNG  GIF  WEBP 10MB - Videos <code>bot.Video</code> MP4 50MB - Audios <code>bot.Audio</code> MP3  M4A 50MB If less than 1MB, it will be detected as a voice note Voice notes <code>bot.Voice</code> MP3  M4A  OGG (Opus) 1MB If more than 1MB, it will be detected as audio Media groups (albums) <code>list</code> - - Only sent as group if all items are of the same type (Photo and Video are considered equal) Location <code>bot.Location</code> - - Defined by latitude, longitude and optional horizontal accuracy"},{"location":"guides/actions/send-media/#examples","title":"Examples","text":"DocumentsPhotosVideosAudiosVoice notesMedia groupsLocation <pre><code>from kamihi import bot\nfrom pathlib import Path\n\n# implicit\n@bot.action\nasync def start() -&gt; Path:\n    return Path(\"actions/start/file.txt\")\n\n# explicit\n@bot.action\nasync def start() -&gt; bot.Document:\n    return bot.Document(\"actions/start/file.txt\")\n</code></pre> <pre><code>from kamihi import bot\nfrom pathlib import Path\n\n# implicit\n@bot.action\nasync def start() -&gt; Path:\n    return Path(\"actions/start/image.jpg\")\n\n# explicit\n@bot.action\nasync def start() -&gt; bot.Photo:\n    return bot.Photo(Path(\"actions/start/image.jpg\"))\n</code></pre> <pre><code>from kamihi import bot\nfrom pathlib import Path\n\n# implicit\n@bot.action\nasync def start() -&gt; Path:\n    return Path(\"actions/start/video.mp4\")\n\n# explicit\n@bot.action\nasync def start() -&gt; bot.Video:\n    return bot.Video(Path(\"actions/start/video.mp4\"))\n</code></pre> <pre><code>from kamihi import bot\nfrom pathlib import Path\n\n# implicit\n@bot.action\nasync def start() -&gt; Path:\n    return Path(\"actions/start/audio.mp3\")\n\n# explicit\n@bot.action\nasync def start() -&gt; bot.Audio:\n    return bot.Audio(Path(\"actions/start/audio.mp3\"))\n</code></pre> <pre><code>from kamihi import bot\nfrom pathlib import Path\n\n# implicit\n@bot.action\nasync def start() -&gt; Path:\n    return Path(\"actions/start/voice.ogg\")\n\n# explicit\n@bot.action\nasync def start() -&gt; bot.Voice:\n    return bot.Voice(Path(\"actions/start/voice.ogg\"))\n</code></pre> <pre><code>from kamihi import bot\nfrom pathlib import Path\n\n# implicit\n@bot.action\nasync def start() -&gt; list[Path]:\n    return [\n        Path(\"actions/start/image1.jpg\"),\n        Path(\"actions/start/image2.jpg\"),\n        Path(\"actions/start/video.mp4\")\n    ]\n\n# explicit\n@bot.action\nasync def start() -&gt; list[bot.Audio]:\n    return [\n        bot.Photo(Path(\"actions/start/audio1.mp3\")),\n        bot.Photo(Path(\"actions/start/audio2.mp3\")),\n    ]\n</code></pre> <pre><code>from kamihi import bot\nfrom pathlib import Path\n\n# explicit\n@bot.action\nasync def start() -&gt; bot.Location:\n    return bot.Location(latitude=37.7749, longitude=-122.4194, horizontal_accuracy=100)\n</code></pre>"},{"location":"guides/actions/send-media/#adding-captions","title":"Adding captions","text":"<p>Adding captions to media you send is only possible when marking the type of media explicitly. You just need to pass the <code>caption</code> keyword argument to the constructor of the media type.</p> <pre><code>from kamihi import bot\nfrom pathlib import Path\n\n@bot.action\nasync def start() -&gt; bot.Document:\n    return bot.Document(Path(\"actions/start/file.txt\"), caption=\"This is a file caption.\")\n</code></pre> <p>Info</p> <p>To caption media groups, there are two options:</p> <ul> <li>Caption every item in the group with their own caption by passing the <code>caption</code> keyword argument.</li> <li>Caption just the first item in the group, and it will be used as the caption for the entire group.</li> </ul>"},{"location":"guides/actions/send-multiple/","title":"Send multiple messages","text":"<p>This guide shows how to send multiple messages in a single action.</p> <p>It is as easy as returning a list of messages from an action. Kamihi will take care of sending each message in the list to the user.</p> <pre><code>from kamihi import bot\n\n@bot.action\ndef start() -&gt; list[str]:\n    return [\n        \"Hello, world!\",\n        \"This is the second message.\",\n        \"And this is the third one.\",\n    ]\n</code></pre> <p>The list accepts any type that can be sent by its own. For example, you can return a list of <code>bot.Photo</code>, <code>bot.Video</code>, or even a mix of different types.</p> <p>For more information on how lists of media files are handled, see the send media guide.</p>"},{"location":"guides/actions/send-pages/","title":"Send paginated messages","text":"<p>This guide explains how to send paginated messages in Kamihi, allowing you to break down long content into manageable pages that users can navigate through.</p>"},{"location":"guides/actions/send-pages/#sending-paginated-messages","title":"Sending paginated messages","text":"<p>To send paginated messages, you can use the <code>bot.Pages</code> class. This class allows you to define multiple pages of content and send them as a single message that users can navigate through.</p> <p>To do this, you will need two things: a list of items to paginate, and a template to render each page.</p> send_paginated_items/send_paginated_items.pysend_paginated_items/send_paginated_items.md.jinja <pre><code>from kamihi import bot\nfrom jinja2 import Template\nfrom typing import Annotated\n\n@bot.action\nasync def send_paginated_items(\n    data: list[str],\n    template: Template\n):\n    return bot.Pages(\n        data=data,\n        page_template=template,\n        items_per_page=5  # Number of items per page\n    )\n</code></pre> <pre><code>{% for item in data %}\n- {{ item }}\n{% endfor %}\n</code></pre> <p>Internally, <code>bot.Pages</code> splits the list of items into pages based on the <code>items_per_page</code> argument and renders each page using the provided template and passing the corresponding slice of items to it as the <code>data</code> variable.</p> <p>When the action is called, Kamihi will render the template for each page using the corresponding items and send the paginated message to the user. Users will be able to navigate through the pages using inline buttons.</p> <p></p>"},{"location":"guides/actions/send-pages/#the-first-page","title":"The first page","text":"<p>You can optionally provide a <code>first_page_template</code> argument to the <code>bot.Pages</code> constructor. This template will be used to render the first page of the paginated message, allowing you to customize its appearance or content. This is useful for help pages or introductions. The first page template will not be passed any items.</p>"},{"location":"guides/actions/send-pages/#page-expiration","title":"Page expiration","text":"<p>Pages are stored in the database. To prevent a build-up of old pages, a customizable default of 7 days expiration is applied to each page set. You can change this by providing the <code>db.pages_expiration_days</code> configuration option in your configuration.</p>"},{"location":"guides/actions/use-datasources/","title":"Use datasources","text":"<p>This guide explains how to use data sources in your actions. Data sources allow you to fetch and process data from various sources, such as databases, and use that data to compose responses or perform actions in your Kamihi bot.</p> <p>To use datasources in your actions, you must have first configured them. See the Configure datasources guide for more information on how to perform this set up.</p>"},{"location":"guides/actions/use-datasources/#writing-queries","title":"Writing queries","text":"<p>Data sources will fetch and execute SQL queries defined in your actions, and put the results in your action's arguments for you to use.</p> <p>After writing your query in the appropriate SQL dialect for the datasource, save it in the action directory using the following naming convention:</p> <pre><code>&lt;query_name&gt;.&lt;datasource_name&gt;.sql\n</code></pre> <p>For actions that have one query, it is recommended that the query name be the same as the action name. For example, for an action named <code>get_users</code> that uses a datasource named <code>my_sqlite_db</code>, you should name the file <code>get_users.my_sqlite_db.sql</code>.</p>"},{"location":"guides/actions/use-datasources/#parametrizing-queries","title":"Parametrizing queries","text":"<p>You can parameterize your query files using Jinja2 templating syntax. This allows you to dynamically insert values into your queries based on the action's input arguments. Any value valid in the action parameters can be used in the query template (except <code>template</code> and <code>template_*</code>), and that includes reusable questions. </p> <p>In this case, the name of the file must follow the same convention as before, but suffixed with <code>.jinja</code> to indicate that it is a Jinja2 template:</p> <pre><code>&lt;query_name&gt;.&lt;datasource_name&gt;.sql.jinja\n</code></pre>"},{"location":"guides/actions/use-datasources/#using-the-data-in-your-action","title":"Using the data in your action","text":"<p>There are three main patterns for using data from data sources in your actions:</p> <ol> <li>Implicit: Automatically selects the query based on the action name.</li> <li>By argument name: Uses a specific naming convention to match query results to action arguments.</li> <li>Explicit: Uses the <code>Annotated</code> type to specify which query corresponds to which argument.</li> </ol> <p>You can choose the pattern that best fits your use case, and you can mix and match these patterns in your actions as needed.</p>"},{"location":"guides/actions/use-datasources/#implicit","title":"Implicit","text":"<p>You define the function argument <code>data</code> in your action, and Kamihi will automatically select the appropriate query and datasource based on the query file name.</p> <p>Continuing from the previous example, if you have a file named <code>get_users.my_sqlite_db.sql</code> in the <code>get_users</code> action folder, you can define your action like this:</p> <pre><code>from kamihi import bot\n\n@bot.action\nasync def get_users(data: list[dict]):\n    # The data argument will contain the results of the query\n    for user in data:\n        print(f\"User: {user['name']}, Email: {user['email']}\")\n</code></pre> <p>The <code>data</code> argument will automatically be populated with the results of the query defined in <code>get_users.my_sqlite_db.sql</code>.</p> <p>Warning</p> <p>This pattern only works when there is only one query in the action folder and the query name is the same as the action name (<code>&lt;action_name&gt;.&lt;datasource_name&gt;.sql</code>). </p> <p>If you have multiple queries in the same action, you will need to use one of the other patterns described below.</p>"},{"location":"guides/actions/use-datasources/#by-argument-name","title":"By argument name","text":"<p>When having multiple queries in the same action, you can specify which query corresponds to which argument by using the following argument name convention:</p> <pre><code>data_&lt;query_name&gt;\n</code></pre> <p>For example, if you have an action <code>get_users</code> with two queries, <code>normal_users.my_sqlite_db.sql</code> and <code>premium_users.my_postgres_db.sql</code>, you can define your action like this:</p> <pre><code>from kamihi import bot\n\n@bot.action\nasync def get_users(data_normal_users: list[dict], data_premium_users: list[dict]):\n    # The data_normal_users argument will contain the results of the normal users query\n    for user in data_normal_users:\n        print(f\"Normal User: {user['name']}, Email: {user['email']}\")\n\n    # The data_premium_users argument will contain the results of the premium users query\n    for user in data_premium_users:\n        print(f\"Premium User: {user['name']}, Email: {user['email']}\")\n</code></pre>"},{"location":"guides/actions/use-datasources/#explicit","title":"Explicit","text":"<p>Finally, you can also specify explicitly the query to insert in an argument by using Annotated. This pattern gives you total freedom to name your arguments however you want.</p> <pre><code>from kamihi import bot\nfrom typing import Annotated\n\n@bot.action\nasync def get_users(\n    normal_users: Annotated[list[dict], \"normal_users.my_sqlite_db.sql\"],\n    premium_users: Annotated[list[dict], \"premium_users.my_postgres_db.sql\"]\n):\n    # The normal_users argument will contain the results of the normal users query\n    for user in normal_users:\n        print(f\"Normal User: {user['name']}, Email: {user['email']}\")\n\n    # The premium_users argument will contain the results of the premium users query\n    for user in premium_users:\n        print(f\"Premium User: {user['name']}, Email: {user['email']}\")\n</code></pre>"},{"location":"guides/actions/use-templates/","title":"Use templates","text":"<p>This guide describes how to use templates in Kamihi actions to create dynamic messages and content. Templates allow you to define a structure for your messages while dynamically inserting values at runtime.</p>"},{"location":"guides/actions/use-templates/#writing-templates","title":"Writing templates","text":"<p>Templates in Kamihi are created using Jinja2 syntax. You can create a template by defining a string with placeholders that will be replaced with actual values when the action is executed. For example:</p> <pre><code>Hello, {{ user.name }}! Welcome to our service.\n</code></pre> <p>You can also use more complex expressions and control structures, such as loops and conditionals, to create dynamic content. For example:</p> <pre><code>{% if user.is_premium %}\nThank you for being a premium member, {{ user.name }}!\n{% else %}\nThank you for using our service, {{ user.name }}! Consider upgrading to premium for more features.\n{% endif %}\n</code></pre> <p>Info</p> <p>For more information on Jinja2 syntax, refer to the Jinja2 documentation.</p>"},{"location":"guides/actions/use-templates/#storing-templates","title":"Storing templates","text":"<p>Templates are stored in the folder of the action that uses them. The template file must have a <code>.md.jinja</code> extension, indicating that it is a Markdown template processed by Jinja2.</p> <p>By default, Kamihi will look for a template file with the same name as the action in the action's folder. For example, if your action is <code>start</code>, Kamihi will look for a file named <code>start.md.jinja</code> in the <code>actions/start/</code> directory.</p>"},{"location":"guides/actions/use-templates/#using-templates-in-actions","title":"Using templates in actions","text":"<p>To use templates in Kamihi actions, you request the <code>template</code> parameter in the action's parameters. For example:</p> actions/start/start.pyactions/start/start.md.jinja <pre><code>from kamihi import bot\nfrom jinja2 import Template\n\n@bot.action\nasync def start(template: Template):\n    return template.render(name=\"John Doe\")\n</code></pre> <pre><code>Hello, {{ name }}! Welcome to our service.\n</code></pre>"},{"location":"guides/actions/use-templates/#templates-with-custom-names","title":"Templates with custom names","text":"<p>If you want to use a template with a custom name, you can specify the template file in the action's parameters using the Annotated syntax. For example:</p> actions/start/start.pyactions/start/custom_template_name.md.jinja <pre><code>from kamihi import bot\nfrom jinja2 import Template\nfrom typing import Annotated\n\n@bot.action\nasync def custom_action(template: Annotated[Template, \"custom_template_name.md.jinja\"]):\n    return template.render(name=\"John Doe\")\n</code></pre> <pre><code>Hello, {{ name }}! This is a custom template.\n</code></pre> <p>Kamihi will look recursively for the template file in the same directory as the action, meaning that you can organize your templates in subdirectories if needed, but in the Annotation you should only specify the file name, not the path. </p> <p>For example, if you have a template in <code>actions/start/templates/custom_template_name.md.jinja</code>, you use it with the annotation <code>Annotated[Template, \"custom_template_name.md.jinja\"]</code>.</p>"},{"location":"guides/actions/use-templates/#using-multiple-templates","title":"Using multiple templates","text":"<p>You can also use multiple templates in a single action. To do this, you can define multiple template parameters in the action's signature, as long as they all start with the <code>template</code> prefix. For example:</p> actions/start/start.pyactions/start/main_template.md.jinjaactions/start/secondary_template.md.jinja <pre><code>from kamihi import bot\nfrom jinja2 import Template\nfrom typing import Annotated\n\n@bot.action\nasync def multi_template_action(\n    template_main: Annotated[Template, \"main_template.md.jinja\"],\n    template_secondary: Annotated[Template, \"secondary_template.md.jinja\"]\n):\n    main_content = template_main.render(name=\"John Doe\")\n    secondary_content = template_secondary.render(name=\"John Doe\")\n    return f\"{main_content}\\n\\n{secondary_content}\"\n</code></pre> <pre><code>Hello, {{ name }}! This is the main template.\n</code></pre> <pre><code>Hello, {{ name }}! This is the secondary template.\n</code></pre> <p>You can also mix and match between the default template and custom templates. For example, you can use the default template for the main content and a custom template for the secondary content:</p> <pre><code>from kamihi import bot\nfrom jinja2 import Template\nfrom typing import Annotated\n\n@bot.action\nasync def mixed_template(\n    template: Template,  # Default template at `mixed_template.md.jinja`\n    template_secondary: Annotated[Template, \"secondary_template.md.jinja\"]\n):\n    main_content = template.render(name=\"John Doe\")\n    secondary_content = template_secondary.render(name=\"John Doe\")\n    return f\"{main_content}\\n\\n{secondary_content}\"\n</code></pre>"},{"location":"guides/actions/use-templates/#the-templates-parameter","title":"The <code>templates</code> parameter","text":"<p>You can also request the <code>templates</code> parameter in your action to access all templates in the action's folder. This is useful if you want to use multiple templates without specifying each one individually. The <code>templates</code> parameter will be a dictionary where the keys are the template names and the values are the rendered templates.</p> <pre><code>from kamihi import bot\nfrom jinja2 import Template\n\n@bot.action\nasync def start(templates: dict[str, Template]):\n    main_content = templates[\"start.md.jinja\"].render(name=\"John Doe\")\n    secondary_content = templates[\"secondary_template.md.jinja\"].render(name=\"John Doe\")\n    return f\"{main_content}\\n\\n{secondary_content}\"\n</code></pre>"},{"location":"guides/config/configure-datasources/","title":"Configure datasources","text":"<p>This guide explains how to configure data sources for your Kamihi application. </p>"},{"location":"guides/config/configure-datasources/#supported-data-sources","title":"Supported data sources","text":"<p>Kamihi supports various data sources that can be used to fetch and process data. The following data sources are currently supported:</p> <ul> <li>SQLite: A lightweight, file-based SQL database.</li> <li>PostgreSQL: A powerful, open-source relational database.</li> </ul> <p>You are welcome to contribute new data sources. See the \"Creating a new datasource type\" guide for more information.</p>"},{"location":"guides/config/configure-datasources/#configuration-basics","title":"Configuration basics","text":"<p>Data sources are configured in the <code>datasources</code> section of the <code>KamihiSettings</code> class. Every data source is defined by a unique name and its type. The type specified determines the rest of the configuration options required for that data source.</p> kamihi.yaml<code>.env</code> file <pre><code>datasources:\n  # A sample SQLite datasource\n  - name: my_sqlite_db\n    type: sqlite\n    path: data/database.db\n  # A sample PostgreSQL datasource\n  - name: my_postgres_db\n    type: postgresql\n    host: localhost\n    port: 5432\n    database: my_database\n    user: my_user\n    password: my_password\n</code></pre> <pre><code>KAMIHI_DATASOURCES='[\n    {\n        \"name\": \"my_sqlite_db\",\n        \"type\": \"sqlite\",\n        \"path\": \"data/database.db\"\n    },\n    {\n        \"name\": \"my_postgres_db\",\n        \"type\": \"postgresql\",\n        \"host\": \"localhost\",\n        \"port\": 5432,\n        \"database\": \"my_database\",\n        \"user\": \"my_user\",\n        \"password\": \"my_password\"\n    }\n]'\n</code></pre> <p>Info</p> <p>Since the <code>datasources</code> section is a list, if defined with environment variables, it needs to be represented as a JSON string.</p>"},{"location":"guides/config/configure-datasources/#configuration-values-reference","title":"Configuration values reference","text":"<p>The following table lists the supported data source types and links to their configuration values reference:</p> Data Source Type Configuration values reference SQLite SQLiteDataSourceConfig PostgreSQL PostgresDataSourceConfig"},{"location":"guides/config/configure-timezone/","title":"Configure the timezone","text":"<p>The default timezone for the bot is UTC. You can change it by adjusting the <code>settings.timezone</code> variable:</p> <code>kamihi.yml</code><code>.env</code>Programmatically <pre><code>timezone: America/New_York\n</code></pre> <pre><code>KAMIHI_TIMEZONE=America/New_York\n</code></pre> <pre><code>from kamihi import bot\n\nbot.settings.timezone = \"America/New_York\"\n</code></pre> <p>You can get the list of available timezones from here.</p>"},{"location":"guides/config/load-environment/","title":"Load configuration from environment variables","text":"<p>This guide explains how to load configuration settings for your Kamihi application from environment variables. Using environment variables allows you to configure your application in different environments without modifying your code or configuration files.</p>"},{"location":"guides/config/load-environment/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kamihi project.</li> <li>A basic understanding of Kamihi's configuration system.</li> </ul>"},{"location":"guides/config/load-environment/#configuration-basics","title":"Configuration basics","text":"<p>Kamihi automatically loads configuration settings from environment variables.  Environment variables must be prefixed with <code>KAMIHI_</code> to be recognized by the Kamihi configuration system. Nested settings are defined using double underscores <code>__</code>. For example, the <code>stdout_level</code> attribute within the <code>log</code> section would be represented by the environment variable <code>KAMIHI_LOG__STDOUT_LEVEL</code>.</p> <p>The environment variables correspond to the attributes defined in the <code>KamihiSettings</code> class.</p>"},{"location":"guides/config/load-environment/#steps","title":"Steps","text":"<ol> <li> <p>Define environment variables:</p> <p>Set the desired environment variables in your shell or in a <code>.env</code> file. For example:</p> Environment variables<code>.env</code> file <pre><code>export KAMIHI_LOG__STDOUT_LEVEL=DEBUG\nexport KAMIHI_LOG__FILE_ENABLE=true\nexport KAMIHI_LOG__FILE_PATH=\"app.log\"\n</code></pre> <pre><code>KAMIHI_LOG__STDOUT_LEVEL=DEBUG\nKAMIHI_LOG__FILE_ENABLE=true\nKAMIHI_LOG__FILE_PATH=\"app.log\"\n</code></pre> </li> <li> <p>Load the settings:</p> <p>The Kamihi framework will automatically load the configuration from the environment variables. You can then access these settings through <code>bot.settings</code>.</p> <pre><code>from kamihi import bot\n\nprint(bot.settings.log.stdout_level)  # Output: DEBUG\n</code></pre> </li> </ol>"},{"location":"guides/config/load-environment/#notes","title":"Notes","text":"<ul> <li>Environment variables will override the default values defined in the <code>KamihiSettings</code> class.</li> <li>Environment variables take precedence over settings in a configuration file.</li> <li>Changes to environment variables require a restart of the Kamihi application to take effect.</li> </ul>"},{"location":"guides/config/load-file/","title":"Load configuration from a file","text":"<p>This guide explains how to load configuration settings for your Kamihi application from a file. Using a configuration file allows you to easily manage and modify settings without altering your code.</p>"},{"location":"guides/config/load-file/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kamihi project.</li> <li>A basic understanding of Kamihi's configuration system.</li> </ul>"},{"location":"guides/config/load-file/#configuration-basics","title":"Configuration basics","text":"<p>Kamihi supports loading configuration from YAML files. By default, it looks for a file named <code>kamihi.yaml</code> in the same directory as your application. You can also specify a custom file path using the <code>KAMIHI_CONFIG_FILE</code> environment variable.</p> <p>The configuration file should contain settings that correspond to the attributes defined in your <code>KamihiSettings</code> class.</p>"},{"location":"guides/config/load-file/#steps","title":"Steps","text":"<ol> <li> <p>Create a configuration file:</p> <p>Create a file named <code>kamihi.yaml</code> (or choose a different name) in your project directory. Add your desired configuration settings to this file. For example:</p> <pre><code>log:\n  stdout_level: DEBUG\n  file_enable: true\n  file_path: \"app.log\"\n</code></pre> </li> <li> <p>Specify the configuration file (optional):</p> <p>If you are not using the default <code>kamihi.yaml</code> file, set the <code>KAMIHI_CONFIG_FILE</code> environment variable to the path of your configuration file. This can be done in your shell or in a <code>.env</code> file:</p> Environment variable<code>.env</code> file <pre><code>export KAMIHI_CONFIG_FILE=/path/to/your/config.yaml\n</code></pre> <pre><code>KAMIHI_CONFIG_FILE=/path/to/your/config.yaml\n</code></pre> </li> <li> <p>Load the settings:</p> <p>When your Kamihi application starts, it will automatically load the configuration from the specified file (or the default <code>kamihi.yaml</code> if no environment variable is set).  You can then access these settings through <code>bot.settings</code>.</p> <pre><code>from kamihi import bot\n\nprint(bot.settings.log.stdout_level)  # Output: DEBUG\n</code></pre> </li> </ol>"},{"location":"guides/config/load-file/#notes","title":"Notes","text":"<ul> <li>Settings in the configuration file will override the default values defined in your <code>KamihiSettings</code> class.</li> <li>Environment variables (e.g., <code>KAMIHI_LOG__STDOUT_LEVEL</code>) will take precedence over settings in the configuration file.</li> <li>If the file specified by <code>KAMIHI_CONFIG_FILE</code> does not exist, Kamihi will fall back to the default <code>kamihi.yaml</code> file, or to the default settings if that file doesn't exist either.</li> </ul>"},{"location":"guides/config/load-prog/","title":"Set configuration values programmatically","text":"<p>This guide explains how to configure your Kamihi application programmatically. This method is useful when you need to dynamically generate or modify configuration settings within your code.</p>"},{"location":"guides/config/load-prog/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kamihi project.</li> <li>A basic understanding of Kamihi's configuration system.</li> </ul>"},{"location":"guides/config/load-prog/#configuration-basics","title":"Configuration basics","text":"<p>Kamihi allows you to configure settings directly in your Python code by instantiating and modifying the <code>KamihiSettings</code> class. This approach bypasses the need for environment variables or configuration files, providing greater flexibility for dynamic configurations.</p>"},{"location":"guides/config/load-prog/#steps","title":"Steps","text":"<ol> <li>Import the bot instance: <pre><code>from kamihi import bot\n</code></pre></li> <li>Set the desired settings programmatically: You can set the desired settings directly on the <code>bot.settings</code> object. For example:     <pre><code>bot.settings.log.stdout_level = \"DEBUG\"\nbot.settings.log.file_enable = True\nbot.settings.log.file_path = \"app.log\"\n</code></pre></li> </ol>"},{"location":"guides/config/load-prog/#notes","title":"Notes","text":"<ul> <li>Programmatically set settings will override default values and settings loaded from configuration files or environment variables.</li> <li>Configuration changes made programmatically will not be validated against the schema defined in the <code>KamihiSettings</code> class. Ensure that the values you set are valid according to the expected types and formats.</li> <li>This method is ideal for scenarios where configuration needs to be determined at runtime based on application logic or external factors.</li> </ul>"},{"location":"guides/db/migrations/","title":"Perform migrations","text":"<p>This guide explains how to manage database migrations in your project. Migrations are essential for evolving your database schema over time while preserving existing data.</p>"},{"location":"guides/db/migrations/#creating-a-migration","title":"Creating a migration","text":"<p>To create a new migration after modifying your models, use the following command:</p> kamihi db migrate2025-01-01 at 00:00:00 | SUCCESS  | Migrated revision='xxxxxxxxxxxx' <p>This command will generate a new migration script in the <code>migrations/versions</code> directory. Review the generated script to ensure it accurately reflects the changes you made to your models.</p>"},{"location":"guides/db/migrations/#applying-migrations","title":"Applying migrations","text":"<p>Once you have created a migration, you need to apply it to your database. Use the following command to upgrade your database schema to the latest revision:</p> kamihi db upgrade2025-01-01 at 00:00:00 | SUCCESS  | Upgraded revision='xxxxxxxxxxxx' <p>This command will apply all pending migrations to your database.</p>"},{"location":"guides/db/migrations/#downgrading-migrations","title":"Downgrading migrations","text":"<p>If you need to revert to a previous migration, you can use the downgrade command. Specify the target revision you want to downgrade to:</p> kamihi db downgrade &lt;target_revision&gt;2025-01-01 at 00:00:00 | SUCCESS  | Downgraded revision='&lt;target_revision&gt;' <p>Replace <code>&lt;target_revision&gt;</code> with the specific revision identifier you want to revert to. You can also use relative revisions numbers (e.g., <code>-1</code> to go back one revision, <code>-5</code> to go back five revisions, etc.).</p>"},{"location":"guides/db/setup/","title":"Set up different databases","text":"<p>This guide will show the steps to set up different DBMS for your Kamihi project. </p> <p>By default, Kamihi uses SQLite, which is a serverless, self-contained database engine. However, for production environments or more complex applications, you might want to use a more robust DBMS like PostgreSQL or MySQL.</p>"},{"location":"guides/db/setup/#supported-dbms","title":"Supported DBMS","text":"<p>For now, Kamihi supports the following DBMS:</p> <ul> <li>SQLite</li> <li>PostgreSQL</li> </ul> <p>If you need support for another DBMS, please open an issue on our issue tracker.</p>"},{"location":"guides/db/setup/#sqlite","title":"SQLite","text":"<p>SQLite is the default DBMS for Kamihi. It requires no additional setup. The database file will be created automatically in the project directory when you run your application for the first time.</p> <p>You can, however, customize the location of the SQLite database file by modifying the configuration:</p> <code>kamihi.yml</code><code>.env</code> <pre><code>db:\n  url: sqlite:///./my_database.db\n</code></pre> <pre><code>KAMIHI_DB__URL=sqlite:///./my_database.db\n</code></pre>"},{"location":"guides/db/setup/#postgresql","title":"PostgreSQL","text":"Development PostgreSQL setup <p>The base project includes a <code>docker-compose.dev.yml</code> file that can be used to set up a PostgreSQL server for development purposes. To use it:</p> <ol> <li>Make sure you have Docker and Docker Compose installed on your machine.</li> <li>In the <code>docker-compose.dev.yml</code> file, you can find the PostgreSQL service configuration. You can modify the environment variables to set your desired username, password, and database name.</li> <li> <p>Start the PostgreSQL server by running the following command in root of your project:</p> <p>docker-compose -f docker-compose.dev.yml up -d postgres[+] Running 3/3\u2714 Network kamihi-example_default  Created                                                                                                                                                                                                                     0.1s\u2714 Volume kamihi-example_pgdata    Created                                                                                                                                                                                                                     0.0s\u2714 Container postgresql            Started  </p> </li> </ol> <p>To use PostgreSQL as your DBMS, you need to have a PostgreSQL server running. With that in place, you can configure your Kamihi project to connect to it by setting the database URL:</p> <code>kamihi.yml</code><code>.env</code> <pre><code>db:\n  url: postgresql+asyncpg://username:password@localhost:5432/database_name # replace with your actual credentials\n</code></pre> <pre><code>KAMIHI_DB__URL=postgresql+asyncpg://username:password@localhost:5432/database_name # replace with your actual credentials\n</code></pre>"},{"location":"guides/jobs/schedule/","title":"Schedule jobs","text":"<p>This guide details how to schedule actions to run at specific times using Kamihi's job scheduling feature.</p>"},{"location":"guides/jobs/schedule/#overview","title":"Overview","text":"<p>Kamihi allows you to schedule actions to be executed at specified times or intervals. This is useful for sending messages regularly to your users, performing routine maintenance tasks, or any other repetitive actions.</p> <p>Tip</p> <p>An action does not have to return anything, so you can use scheduled actions for any kind of task, not just sending messages.</p>"},{"location":"guides/jobs/schedule/#enabling-jobs","title":"Enabling jobs","text":"<p>Jobs are disabled by default in Kamihi. To enable job scheduling, you need to set the <code>jobs.enabled</code> configuration option to <code>true</code>.</p> kamihi.yaml<code>.env</code> file <pre><code>jobs:\n    enabled: true\n</code></pre> <pre><code>KAMIHI_JOBS__ENABLED=true\n</code></pre>"},{"location":"guides/jobs/schedule/#creating-a-scheduled-job","title":"Creating a scheduled job","text":"<p>Jobs, once enabled, are defined through the Kamihi admin interface. To create a scheduled job, follow these steps:</p> <ol> <li>Navigate to the \"Jobs\" section in the Kamihi admin interface.</li> <li>Click on \"New Job\".</li> <li>Fill in the job details:<ul> <li>Action: Select the action you want to schedule from the dropdown list.</li> <li>Enabled: Check this box to enable the job.</li> <li>Users: Select the users that the job will target.</li> <li>Roles: Select the roles that the job will target.</li> <li>Per user: Check this box if you want the job to run separately for each user. See the dedicated section for more details.</li> <li>Cron expression: Define the schedule using a cron expression. You can use online tools like crontab.guru to help you create valid expressions.</li> <li>Args: Provide any necessary arguments for the action in JSON format. More details in the dedicated section.</li> </ul> </li> <li>Click \"Save\" to create the job.</li> </ol>"},{"location":"guides/jobs/schedule/#run-jobs-manually","title":"Run jobs manually","text":"<p>Jobs can also be run manually from the Kamihi admin interface to test their functionality or to execute them outside of their scheduled times. To run a job manually, you can select the option \"Run job manually\" from the Actions dropdown menu in the job row or from the job detail page.</p>"},{"location":"guides/jobs/schedule/#the-per_user-option","title":"The <code>per_user</code> option","text":"<p>The <code>per_user</code> option allows you to specify whether the job should be executed separately for each user or just once. This means several things:</p> <ul> <li>A job with a large number of users may take a long time to complete if <code>per_user</code> is enabled, as it will run the action once for each user. Be also careful that all requests to external datasources will be repeated for each user, which may lead to rate limiting or bans.</li> <li>A job with no users or roles selected and <code>per_user</code> enabled will not run at all, since there are no users to iterate over. If you plan to create jobs without specific users or roles, make sure to leave <code>per_user</code> disabled.</li> <li>If <code>per_user</code> is disabled, the parameter <code>user</code> passed to the action will be <code>None</code>, so the action will not be able to target specific users. Take this into account when designing an action that can be used both by command and in jobs and that needs the <code>user</code> parameter. In any case, the parameter <code>users</code> passed to the action will always contain the list of users selected for the job.</li> </ul>"},{"location":"guides/jobs/schedule/#job-arguments","title":"Job arguments","text":"<p>Jobs cannot ask reusable questions, since they can only run without user interaction. Therefore, if your action uses questions to gather input, you need to provide the answers in the job definition. To do this, you can use the Args field in the job creation form to provide a JSON object containing the necessary arguments. For example, if your action requires a <code>name</code> and a <code>city</code>, you can provide them like this:</p> <pre><code>{\n    \"name\": \"John Doe\",\n    \"city\": \"New York\"\n}\n</code></pre> <p>Make sure that: - All the required arguments for the action to function correctly are provided. If any required arguments are missing, the job will fill them with <code>None</code>, which may lead to errors during execution. - The keys in the JSON object match the parameter names expected by the action, since they will be passed as keyword arguments. - The provided arguments are of the correct type, as no type validation is performed on the provided values.</p>"},{"location":"guides/logging/configure-notifications/","title":"Configure notifications","text":"<p>This guide shows you how to set up log notifications in Kamihi to receive alerts for important log events through various notification services.</p>"},{"location":"guides/logging/configure-notifications/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kamihi application</li> <li>Access to one or more notification services (Discord, Slack, Email, Telegram, etc.)</li> <li>Basic understanding of log levels</li> </ul>"},{"location":"guides/logging/configure-notifications/#configure-notification-logging","title":"Configure notification logging","text":"<p>Add the appropriate configuration to your Kamihi application to enable notification logging:</p> Config. file<code>.env</code> fileProgrammatically <pre><code>log:\n  # Enable notification logging\n  notification_enable: true\n\n  # Set the minimum log level that triggers notifications\n  notification_level: ERROR\n\n  # Add notification service URLs (Apprise format)\n  notification_urls:\n    - discord://webhook_id/webhook_token\n    - slack://token/channel\n    - telegram://bot_token/chat_id\n</code></pre> <pre><code># Enable notification logging\nKAMIHI_LOG__NOTIFICATION_ENABLE=true\n\n# Set the minimum log level that triggers notifications\nKAMIHI_LOG__NOTIFICATION_LEVEL=ERROR\n\n# Add notification service URLs (Apprise format)\n# For multiple URLs, use comma-separated values\nKAMIHI_LOG__NOTIFICATION_URLS=discord://webhook_id/webhook_token,slack://token/channel\n</code></pre> <pre><code>from kamihi import bot\n\nbot.settings.log.notification_enable = True\nbot.settings.log.notification_level = \"ERROR\"\nbot.settings.log.notification_urls = [\n    \"discord://webhook_id/webhook_token\",\n    \"slack://token/channel\",\n    \"telegram://bot_token/chat_id\"\n]\n</code></pre>"},{"location":"guides/logging/configure-notifications/#setting-up-notification-services","title":"Setting up notification services","text":""},{"location":"guides/logging/configure-notifications/#telegram","title":"Telegram","text":"<p>You can use the same Telegram bot token and chat ID that you use for the main bot. To set up notifications:</p> <ol> <li>Get your bot token</li> <li>Get your chat ID (you can use the <code>getUpdates</code> method to find it)</li> <li>Use the format: <code>telegram://bot_token/chat_id</code></li> </ol>"},{"location":"guides/logging/configure-notifications/#discord","title":"Discord","text":"<p>To set up Discord notifications:</p> <ol> <li>In your Discord server, go to Server Settings &gt; Integrations &gt; Webhooks</li> <li>Click New Webhook, give it a name and select a channel</li> <li>Click Copy Webhook URL</li> <li>Use this URL in the format: <code>discord://webhook_id/webhook_token</code></li> </ol>"},{"location":"guides/logging/configure-notifications/#slack","title":"Slack","text":"<p>To set up Slack notifications:</p> <ol> <li>Create a Slack app at https://api.slack.com/apps</li> <li>Enable Incoming Webhooks for your app</li> <li>Add a new webhook to your workspace</li> <li>Copy the webhook URL</li> <li>Use this URL in the format: <code>slack://token/channel</code></li> </ol>"},{"location":"guides/logging/configure-notifications/#email","title":"Email","text":"<p>To set up email notifications:</p> <ol> <li>Use the format: <code>mailto://user:password@gmail.com</code></li> <li>For Gmail, you may need to create an app password</li> </ol>"},{"location":"guides/logging/configure-notifications/#other-services","title":"Other services","text":"<p>Please refer to the Apprise documentation for more information on how to set up other supported notification services.</p>"},{"location":"guides/logging/configure-notifications/#testing-your-notifications","title":"Testing your notifications","text":"<p>You can use a simple script to test that your notifications are working:</p> <pre><code>from loguru import logger\n\n# This will send a notification if you've set notification_level to ERROR or lower\nlogger.error(\"Test notification - this is an error message\")\n\n# This will send a notification if you've set notification_level to CRITICAL\nlogger.critical(\"Test notification - this is a critical message\")\n</code></pre>"},{"location":"guides/logging/configure-rotation-retention/","title":"Configure file log rotation and retention","text":"<p>This guide shows you how to set up file logging with rotation and retention policies in Kamihi, preventing log files from growing too large and managing disk space efficiently.</p>"},{"location":"guides/logging/configure-rotation-retention/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kamihi project</li> <li>Basic understanding of Kamihi's configuration system</li> </ul>"},{"location":"guides/logging/configure-rotation-retention/#configuration-basics","title":"Configuration basics","text":"<p>Kamihi uses the following configuration options for log rotation and retention:</p> <ul> <li><code>log.file_enable</code> (<code>KAMIHI_LOG__FILE_ENABLE</code>): Enable file logging</li> <li><code>log.file_path</code> (<code>KAMIHI_LOG__FILE_PATH</code>): Path to the log file</li> <li><code>log.file_rotation</code> (<code>KAMIHI_LOG__FILE_ROTATION</code>): Rotation policy</li> <li><code>log.file_retention</code> (<code>KAMIHI_LOG__FILE_RETENTION</code>): Retention policy</li> </ul> <p>To understand how to set configuration options, refer to the configuration guide.</p>"},{"location":"guides/logging/configure-rotation-retention/#common-logging-scenarios","title":"Common logging scenarios","text":""},{"location":"guides/logging/configure-rotation-retention/#high-volume-production-applications","title":"High-volume production applications","text":"<p>If your application produces high-volume logs (e.g., many requests per second), the following settings are recommended</p> Config. file<code>.env</code> fileProgrammatically <pre><code>log:\nfile_enable: true\nfile_path: \"/var/log/kamihi/app.log\"\nfile_rotation: \"100 MB\" # Rotate when the file reaches 100 MB\nfile_retention: \"10 days\" # Keep logs for 10 days\n</code></pre> <pre><code>KAMIHI_LOG__FILE_ENABLE=true\nKAMIHI_LOG__FILE_PATH=\"/var/log/kamihi/app.log\"\nKAMIHI_LOG__FILE_ROTATION=\"100 MB\" # Rotate when the file reaches 100 MB\nKAMIHI_LOG__FILE_RETENTION=\"10 days\" # Keep logs for 10 days\n</code></pre> <pre><code>from kamihi import bot\n\nbot.settings.log.file_enable = True\nbot.settings.log.file_path = \"/var/log/kamihi/app.log\"\nbot.settings.log.file_rotation = \"100 MB\"  # Rotate when the file reaches 100 MB\nbot.settings.log.file_retention = \"10 days\"  # Keep logs for 10 days\n</code></pre> <p>Alternatively, for containers or environments with limited disk space, you can use a more conservative approach:</p> Config. file<code>.env</code> fileProgrammatically <pre><code>log:\nfile_enable: true\nfile_path: \"/var/log/kamihi/app.log\"\nfile_rotation: \"50 MB\" # Rotate when the file reaches 50 MB\nfile_retention: \"3 days\" # Keep logs for 3 days\n</code></pre> <pre><code>KAMIHI_LOG__FILE_ENABLE=true\nKAMIHI_LOG__FILE_PATH=\"/var/log/kamihi/app.log\"\nKAMIHI_LOG__FILE_ROTATION=\"50 MB\" # Rotate when the file reaches 50 MB\nKAMIHI_LOG__FILE_RETENTION=\"3 days\" # Keep logs for 3 days\n</code></pre> <pre><code>from kamihi import bot\n\nbot.settings.log.file_enable = True\nbot.settings.log.file_path = \"/var/log/kamihi/app.log\"\nbot.settings.log.file_rotation = \"50 MB\"  # Rotate when the file reaches 50 MB\nbot.settings.log.file_retention = \"3 days\"  # Keep logs for 3 days\n</code></pre>"},{"location":"guides/logging/configure-rotation-retention/#background-or-batch-processing-applications","title":"Background or batch processing applications","text":"<p>If your application runs scheduled jobs or processes data in batches, you can configure daily rotation to match your job schedule:</p> Config. file<code>.env</code> fileProgrammatically <pre><code>log:\nfile_enable: true\nfile_path: \"/var/log/kamihi/app.log\"\nfile_rotation: \"1 day\" # Rotate daily\nfile_retention: \"7 days\" # Keep logs for 7 days\n</code></pre> <pre><code>KAMIHI_LOG__FILE_ENABLE=true\nKAMIHI_LOG__FILE_PATH=\"/var/log/kamihi/app.log\"\nKAMIHI_LOG__FILE_ROTATION=\"1 day\" # Rotate daily\nKAMIHI_LOG__FILE_RETENTION=\"7 days\" # Keep logs for 7 days\n</code></pre> <pre><code>from kamihi import bot\n\nbot.settings.log.file_enable = True\nbot.settings.log.file_path = \"/var/log/kamihi/app.log\"\nbot.settings.log.file_rotation = \"1 day\"  # Rotate daily\nbot.settings.log.file_retention = \"7 days\"  # Keep logs for 7 days\n</code></pre>"},{"location":"guides/logging/configure-rotation-retention/#development-environments","title":"Development environments","text":"<p>For local development, we do not recommend using file logging, as it can clutter your workspace. However, if you want to keep logs for debugging purposes, you can set a short retention period:</p> Config. file<code>.env</code> fileProgrammatically <pre><code>log:\nfile_enable: true\nfile_path: \"app.log\"\nfile_rotation: \"1 hour\" # Rotate every hour\nfile_retention: \"1 day\" # Keep logs for 1 day\n</code></pre> <pre><code>KAMIHI_LOG__FILE_ENABLE=true\nKAMIHI_LOG__FILE_PATH=\"app.log\"\nKAMIHI_LOG__FILE_ROTATION=\"1 hour\" # Rotate every hour\nKAMIHI_LOG__FILE_RETENTION=\"1 day\" # Keep logs for 1 day\n</code></pre> <pre><code>from kamihi import bot\n\nbot.settings.log.file_enable = True\nbot.settings.log.file_path = \"app.log\"\nbot.settings.log.file_rotation = \"1 hour\"  # Rotate every hour\nbot.settings.log.file_retention = \"1 day\"  # Keep logs for 1 day\n</code></pre>"},{"location":"guides/logging/configure-rotation-retention/#advanced-usage","title":"Advanced usage","text":"<p>Please refer to the <code>loguru</code> documentation for more advanced usage, including custom rotation and retention policies.</p>"},{"location":"guides/logging/configure-structured/","title":"Configure structured logging","text":"<p>Structured logging transforms your application logs into machine-readable JSON format instead of plain text. You should enable structured logging when:</p> <ul> <li>You need to process logs programmatically</li> <li>You're integrating with modern log management systems</li> <li>You want to enable advanced filtering and searching capabilities</li> <li>You need to track complex relationships between log events</li> </ul> <p>Structured logs make it easier to analyze patterns, troubleshoot issues, and extract metrics from your application's operation.</p>"},{"location":"guides/logging/configure-structured/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kamihi application</li> <li>Basic understanding of Kamihi configuration</li> </ul>"},{"location":"guides/logging/configure-structured/#enable-structured-logging","title":"Enable structured logging","text":"<p>Add the appropriate configuration to your Kamihi application to enable structured logging:</p> Config. file<code>.env</code> fileProgrammatically <pre><code>log:\n  # Enable structured logging for stdout\n  stdout_serialize: true\n\n  # Enable structured logging for stderr\n  stderr_enable: true\n  stderr_serialize: true\n\n  # Enable structured logging for file output\n  file_enable: true\n  file_path: kamihi.json\n  file_serialize: true\n</code></pre> <pre><code># Enable structured logging for stdout\nKAMIHI_LOG__STDOUT_SERIALIZE=true\n\n# Enable structured logging for stderr\nKAMIHI_LOG__STDERR_ENABLE=true\nKAMIHI_LOG__STDERR_SERIALIZE=true\n\n# Enable structured logging for file output\nKAMIHI_LOG__FILE_ENABLE=true\nKAMIHI_LOG__FILE_PATH=kamihi.json\nKAMIHI_LOG__FILE_SERIALIZE=true\n</code></pre> <pre><code>from kamihi import bot\n\nbot.settings.log.stdout_serialize = True\n\nbot.settings.log.stderr_enable = True\nbot.settings.log.stderr_serialize = True\n\nbot.settings.log.file_enable = True\nbot.settings.log.file_path = \"kamihi.json\"\nbot.settings.log.file_serialize = True\n</code></pre>"},{"location":"guides/logging/configure-structured/#checking-your-structured-logs","title":"Checking your structured logs","text":"<p>When structured logging is enabled, your logs will be output as JSON objects. Each log entry will be a single line containing a JSON object that includes details like timestamp, log level, message text, and contextual information.</p>"},{"location":"guides/logging/configure-structured/#related-documentation","title":"Related documentation","text":"<p>Refer to the Loguru documentation for more details on structured logging capabilities and how to add contextual information to your logs.</p>"},{"location":"guides/logging/setup-basic/","title":"Set up basic logging","text":"<p>This guide shows you how to configure and use basic logging in your Kamihi application.</p> <p>If you need to capture application activity for debugging or monitoring, configure logging as described below.</p>"},{"location":"guides/logging/setup-basic/#configuring-console-logging","title":"Configuring console logging","text":"<p>Console logging to <code>stdout</code> is enabled by default. You can configure it in several ways:</p> Config. file<code>.env</code> fileProgrammatically <pre><code>log:\n    stdout_level: DEBUG # default is INFO\n</code></pre> <pre><code>KAMIHI_LOG__STDOUT_LEVEL=DEBUG # default is INFO\n</code></pre> <pre><code>from kamihi import bot\n\n# Set the logging level for stdout\nbot.settings.log.stdout_level = \"DEBUG\"  # default is INFO\n</code></pre>"},{"location":"guides/logging/setup-basic/#configuring-stderr-logging","title":"Configuring <code>stderr</code> logging","text":"<p>If you want to log to <code>stderr</code>, you can enable and configure it similarly:</p> Config. file<code>.env</code> fileProgrammatically <pre><code>log:\n    stderr_enable: true\n    stderr_level: ERROR\n</code></pre> <pre><code>KAMIHI_LOG__STDERR_ENABLE=true\nKAMIHI_LOG__STDERR_LEVEL=ERROR\n</code></pre> <pre><code>from kamihi import bot\n\n# Enable and set the logging level for stderr\nbot.settings.log.stderr_enable = True\nbot.settings.log.stderr_level = \"ERROR\"\n</code></pre>"},{"location":"guides/logging/setup-basic/#adding-file-logging","title":"Adding file logging","text":"<p>If you need to store logs in a file:</p> Config. file<code>.env</code> fileProgrammatically <pre><code>log:\n    file_enable: true\n    file_path: app.log # Path to the log file, default is \"kamihi.log\"\n    file_level: DEBUG\n</code></pre> <pre><code>KAMIHI_LOG__FILE_ENABLE=true\nKAMIHI_LOG__FILE_PATH=app.log # Path to the log file, default is \"kamihi.log\"\nKAMIHI_LOG__FILE_LEVEL=DEBUG\n</code></pre> <pre><code>from kamihi import bot\n\n# Enable file logging and set the log file path and level\nbot.settings.log.file_enable = True\nbot.settings.log.file_path = \"app.log\"  # Path to the log file, default is \"kamihi.log\"\nbot.settings.log.file_level = \"DEBUG\"\n</code></pre>"},{"location":"guides/projects/other-package-managers/","title":"Using other package managers","text":"<p>This guide explains how to install and set up Kamihi projects using package managers other than <code>uv</code>. While Kamihi's templates and documentation default to <code>uv</code>, you can successfully use <code>pip</code> with virtual environments or <code>Poetry</code> for dependency management.</p>"},{"location":"guides/projects/other-package-managers/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or higher installed on your system</li> <li>Basic familiarity with Python package management</li> <li>For Poetry: Poetry installed on your system (installation guide)</li> </ul>"},{"location":"guides/projects/other-package-managers/#why-use-alternative-package-managers","title":"Why use alternative package managers","text":"<p>While <code>uv</code> offers exceptional performance and modern features, you might prefer other package managers for various reasons:</p> <ul> <li>Team consistency: Your team already uses <code>pip</code> or Poetry</li> <li>Tooling integration: Existing CI/CD pipelines or IDE configurations</li> <li>Familiarity: Comfort with established workflows</li> <li>Corporate policies: Organization requirements for specific tools</li> </ul>"},{"location":"guides/projects/other-package-managers/#installation-approaches","title":"Installation approaches","text":""},{"location":"guides/projects/other-package-managers/#using-pip-with-virtual-environments","title":"Using pip with virtual environments","text":"<p>This approach uses Python's built-in <code>venv</code> module with <code>pip</code> for dependency management.</p>"},{"location":"guides/projects/other-package-managers/#creating-a-new-project","title":"Creating a new project","text":"<ol> <li> <p>Create and navigate to your project directory:</p> <pre><code>mkdir hello-world\ncd hello-world\n</code></pre> </li> <li> <p>Create a virtual environment:</p> <pre><code>python -m venv .venv\n</code></pre> </li> <li> <p>Activate the virtual environment:</p> Linux/macOSWindows (Command Prompt)Windows (PowerShell) <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\activate.bat\n</code></pre> <pre><code>.venv\\Scripts\\Activate.ps1\n</code></pre> </li> <li> <p>Install Kamihi:</p> <pre><code>pip install kamihi\n</code></pre> </li> <li> <p>Create project structure manually:</p> <p>Since <code>kamihi init</code> creates a <code>uv</code>-based project, you'll need to adapt the structure:</p> <pre><code># Create necessary directories\nmkdir actions models\nmkdir actions/start\n\n# Create __init__.py files\ntouch actions/__init__.py\ntouch actions/start/__init__.py\ntouch models/__init__.py\n</code></pre> </li> <li> <p>Create essential files:</p> <p>Create a <code>requirements.txt</code> file for dependency management:</p> <pre><code>kamihi&gt;=1.0.0\n</code></pre> <p>Create a basic <code>kamihi.yml</code> configuration file:</p> <pre><code>---\ntoken: YOUR_TOKEN_HERE\ntimezone: UTC\n</code></pre> <p>Create a sample action in <code>actions/start/start.py</code>:</p> <pre><code>from kamihi import bot\nfrom telegram import Update\nfrom telegram.ext import ContextTypes\n\n@bot.action(description=\"Start the bot\")\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -&gt; None:\n    \"\"\"Handle the /start command.\"\"\"\n    await update.message.reply_text(\"Hello! I'm your Kamihi bot.\")\n</code></pre> </li> </ol>"},{"location":"guides/projects/other-package-managers/#running-your-project","title":"Running your project","text":"<ol> <li> <p>Ensure your virtual environment is activated:</p> <p>The command prompt should show <code>(.venv)</code> prefix when activated.</p> </li> <li> <p>Run the bot:</p> <pre><code>kamihi run\n</code></pre> </li> </ol>"},{"location":"guides/projects/other-package-managers/#managing-dependencies","title":"Managing dependencies","text":"<p>To add new dependencies to your project:</p> <pre><code># Install a new package\npip install package-name\n\n# Update requirements.txt\npip freeze &gt; requirements.txt\n</code></pre> <p>To install dependencies on a new machine:</p> <pre><code># Activate virtual environment first\nsource .venv/bin/activate  # Linux/macOS\n# or\n.venv\\Scripts\\activate.bat  # Windows\n\n# Install dependencies\npip install -r requirements.txt\n</code></pre>"},{"location":"guides/projects/other-package-managers/#using-poetry","title":"Using Poetry","text":"<p>Poetry provides a more modern approach to Python dependency management with automatic virtual environment handling.</p>"},{"location":"guides/projects/other-package-managers/#creating-a-new-project_1","title":"Creating a new project","text":"<ol> <li> <p>Initialize a new Poetry project:</p> <pre><code>poetry new hello-world\ncd hello-world\n</code></pre> </li> <li> <p>Add Kamihi as a dependency:</p> <pre><code>poetry add kamihi\n</code></pre> </li> <li> <p>Create project structure:</p> <p>Poetry creates a different directory structure by default. Adapt it for Kamihi:</p> <pre><code># Remove the default package directory if it exists\nrm -rf hello_world/\n\n# Create Kamihi-expected directories\nmkdir actions models\nmkdir actions/start\n\n# Create __init__.py files\ntouch actions/__init__.py\ntouch actions/start/__init__.py\ntouch models/__init__.py\n</code></pre> </li> <li> <p>Create essential files:</p> <p>Create a <code>kamihi.yml</code> configuration file:</p> <pre><code>---\ntoken: YOUR_TOKEN_HERE\ntimezone: UTC\n</code></pre> <p>Create a sample action in <code>actions/start/start.py</code>:</p> <pre><code>from kamihi import bot\nfrom telegram import Update\nfrom telegram.ext import ContextTypes\n\n@bot.action(description=\"Start the bot\")\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -&gt; None:\n    \"\"\"Handle the /start command.\"\"\"\n    await update.message.reply_text(\"Hello! I'm your Kamihi bot.\")\n</code></pre> </li> </ol>"},{"location":"guides/projects/other-package-managers/#running-your-project_1","title":"Running your project","text":"<ol> <li> <p>Run the bot using Poetry:</p> <pre><code>poetry run kamihi run\n</code></pre> <p>Alternatively, you can activate Poetry's virtual environment:</p> <pre><code>poetry shell\nkamihi run\n</code></pre> </li> </ol>"},{"location":"guides/projects/other-package-managers/#managing-dependencies_1","title":"Managing dependencies","text":"<p>Poetry simplifies dependency management:</p> <pre><code># Add a new dependency\npoetry add package-name\n\n# Add a development dependency\npoetry add --group dev package-name\n\n# Update dependencies\npoetry update\n\n# Install dependencies (useful for new machines)\npoetry install\n</code></pre>"},{"location":"guides/projects/other-package-managers/#converting-existing-uv-projects","title":"Converting existing uv projects","text":"<p>If you have an existing Kamihi project created with <code>uv</code> that you want to convert:</p>"},{"location":"guides/projects/other-package-managers/#converting-to-pip-venv","title":"Converting to pip + venv","text":"<ol> <li> <p>Create and activate a virtual environment:</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate  # Linux/macOS\n# or\n.venv\\Scripts\\activate.bat  # Windows\n</code></pre> </li> <li> <p>Convert dependencies:</p> <p>Extract dependencies from <code>pyproject.toml</code> and create <code>requirements.txt</code>:</p> <pre><code># If uv is still available\nuv pip compile pyproject.toml -o requirements.txt\n\n# Or manually create requirements.txt based on pyproject.toml dependencies\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Remove uv-specific files (optional):</p> <pre><code>rm uv.lock  # If you no longer need uv\n</code></pre> </li> </ol>"},{"location":"guides/projects/other-package-managers/#converting-to-poetry","title":"Converting to Poetry","text":"<ol> <li> <p>Initialize Poetry in the existing directory:</p> <pre><code>poetry init\n</code></pre> </li> <li> <p>Add dependencies from pyproject.toml:</p> <p>Poetry can read the existing <code>pyproject.toml</code> if it follows standard format:</p> <pre><code>poetry install\n</code></pre> <p>Or manually add each dependency:</p> <pre><code>poetry add kamihi\n# Add other dependencies as needed\n</code></pre> </li> <li> <p>Remove uv-specific files (optional):</p> <pre><code>rm uv.lock  # If you no longer need uv\n</code></pre> </li> </ol>"},{"location":"guides/projects/other-package-managers/#important-considerations","title":"Important considerations","text":""},{"location":"guides/projects/other-package-managers/#virtual-environment-activation","title":"Virtual environment activation","text":"<p>Unlike <code>uv</code>, which can automatically manage Python environments, <code>pip</code> requires manual virtual environment activation. Always ensure your virtual environment is activated before running commands.</p>"},{"location":"guides/projects/other-package-managers/#dependency-resolution","title":"Dependency resolution","text":"<ul> <li>uv: Provides fast, deterministic dependency resolution</li> <li>pip: May require manual conflict resolution for complex dependencies</li> <li>Poetry: Provides deterministic resolution similar to uv but may be slower</li> </ul>"},{"location":"guides/projects/other-package-managers/#performance-differences","title":"Performance differences","text":"<p><code>uv</code> typically offers significantly faster installation and resolution times compared to <code>pip</code> and Poetry. If performance is critical, consider using <code>uv</code> even if your team prefers other tools for some workflows.</p>"},{"location":"guides/projects/other-package-managers/#docker-deployment","title":"Docker deployment","text":"<p>When deploying with Docker, you may need to adapt the Dockerfile provided by Kamihi templates. The default Dockerfile uses <code>uv</code> for multi-stage builds and optimized performance.</p>"},{"location":"guides/projects/other-package-managers/#notes","title":"Notes","text":"<ul> <li>Kamihi's core functionality remains the same regardless of the package manager used</li> <li>The <code>kamihi</code> CLI commands work identically across all package managers</li> <li>Consider your team's existing toolchain and workflows when choosing a package manager</li> <li>All package managers can coexist in the same environment if needed for different projects</li> </ul>"},{"location":"guides/reference/action-parameters/","title":"Action parameters","text":"<p>This guide details all the possible options for defining action parameters in Kamihi.</p> Parameter Name Description Type More information <code>data</code> The main data argument for the action. If only one query is defined for the action, its results will be automatically assigned to this parameter. <code>list</code> Using data sources in actions <code>data_&lt;query_name&gt;</code> When multiple queries are defined for the action, each query's results can be assigned to a separate parameter by using this naming convention. Replace <code>&lt;query_name&gt;</code> with the actual name of the query file (without the datasource and extension). <code>list</code> Using data sources in actions <code>template</code> The Jinja2 template to be used for rendering the action's response. By default, Kamihi looks for a template file with the same name as the action in the action's folder. <code>jinja2.Template</code> Using templates in actions <code>template_&lt;name&gt;</code> To use a template with a custom name, specify the template file in the action's parameters using the Annotated syntax. Replace <code>&lt;name&gt;</code> with the actual name of the template file. <code>jinja2.Template</code> Using templates in actions <code>update</code> The update object representing the incoming message or event that triggered the action. This allows you to access details about the user, chat, and message context. <code>telegram.Update</code> - <code>context</code> The context object that provides additional information about the current state of the bot and the conversation. This can be used to store temporary data or manage session state. <code>telegram.ext.CallbackContext</code> - <code>logger</code> A logger instance that can be used to log messages for debugging or monitoring purposes within the action. <code>loguru.Logger</code> - <code>user</code> The user object representing the user who triggered the action. This allows you to access user-specific information such as Telegram ID and any other details in the User model. <code>models.User</code> Extending the user model <code>users</code> A list of user objects representing all the users that can use this action. <code>list[models.User]</code> - <code>action_folder</code> The path to the folder where the action's files are stored. This can be useful for accessing additional resources or files related to the action. <code>pathlib.Path</code> - <code>.*</code> Custom parameters defined by the user, that correspond to questions. They need to be properly annotated using <code>typing.Annotated</code> and a question type from <code>kamihi.questions</code>. Varies Asking questions"},{"location":"guides/users/extend/","title":"Extend the user model","text":"<p>This guide shows how to extend and customize the user model of the framework. You can do this if you need to store more data about your users than just their Telegram ID and their admin status.</p>"},{"location":"guides/users/extend/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kamihi application</li> <li>Basic understanding of how SQLAlchemy works</li> </ul>"},{"location":"guides/users/extend/#extending-the-user-class","title":"Extending the User class","text":"<p>The base project defines a <code>User</code> class in <code>kamihi/models/user.py</code> that extends from <code>kamihi.BaseUser</code>. This class can be extended to add more attributes. For example, to add a <code>name</code> attribute, you can modify the file like this:</p> <pre><code>from kamihi.db import BaseUser\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nclass User(BaseUser):\n    __table_args__ = {'extend_existing': True}\n    name: Mapped[str | None] = mapped_column(String(100), nullable=True)\n</code></pre> <p>Warning</p> <p>Be sure to update the database schema when modifying the model. To obtain more information on how to do this, refer to the database migrations guide.</p>"},{"location":"guides/users/extend/#adding-users-with-extended-attributes-using-the-cli","title":"Adding users with extended attributes using the CLI","text":"<p>To add users with an extended <code>User</code> class, all the extra attributes need to be sent as a JSON string with the <code>--data</code> option:</p> <pre><code>&gt; kamihi user add 123456789 --data '{\"name\": \"John Doe\"}'\n</code></pre>"},{"location":"reference/cli/","title":"CLI reference","text":""},{"location":"reference/cli/#kamihi","title":"kamihi","text":"<p>Kamihi CLI utility.</p> <p>This utility provides commands to manage and interact with the Kamihi framework.</p>"},{"location":"reference/cli/#usage","title":"Usage","text":"<p><code>kamihi [OPTIONS] COMMAND [ARGS]...</code></p>"},{"location":"reference/cli/#arguments","title":"Arguments","text":"<p>No arguments available</p>"},{"location":"reference/cli/#options","title":"Options","text":"Name Description Required Default <code>--settings-path FILE</code> Path to the Kamihi settings file  [default: (kamihi.yaml)] No - <code>--help</code> Show this message and exit. No -"},{"location":"reference/cli/#commands","title":"Commands","text":"Name Description <code>version</code> Print the version and exit. <code>init</code> Initialize a new Kamihi project. <code>action</code> <code>run</code> Run a project with the Kamihi framework. <code>user</code> <code>db</code> Database management commands for Kamihi CLI. <code>permission</code> <code>role</code>"},{"location":"reference/cli/#sub-commands","title":"Sub Commands","text":""},{"location":"reference/cli/#kamihi-version","title":"<code>kamihi version</code>","text":"<p>Print the version and exit.</p>"},{"location":"reference/cli/#usage_1","title":"Usage","text":"<p><code>kamihi version [OPTIONS]</code></p>"},{"location":"reference/cli/#arguments_1","title":"Arguments","text":"<p>No arguments available</p>"},{"location":"reference/cli/#options_1","title":"Options","text":"Name Description Required Default <code>--help</code> Show this message and exit. No -"},{"location":"reference/cli/#kamihi-init","title":"<code>kamihi init</code>","text":"<p>Initialize a new Kamihi project.</p>"},{"location":"reference/cli/#usage_2","title":"Usage","text":"<p><code>kamihi init [OPTIONS] NAME</code></p>"},{"location":"reference/cli/#arguments_2","title":"Arguments","text":"Name Description Required <code>NAME</code> Name of the project. Yes"},{"location":"reference/cli/#options_2","title":"Options","text":"Name Description Required Default <code>--path DIRECTORY</code> Path to the project directory. No - <code>--description TEXT</code> Description of the project.  [default: Kamihi project] No - <code>--help</code> Show this message and exit. No -"},{"location":"reference/cli/#kamihi-action","title":"<code>kamihi action</code>","text":"<p>No description available</p>"},{"location":"reference/cli/#usage_3","title":"Usage","text":"<p><code>kamihi action new [OPTIONS] NAME</code></p>"},{"location":"reference/cli/#arguments_3","title":"Arguments","text":"Name Description Required <code>NAME</code> Name of the new action. Yes"},{"location":"reference/cli/#options_3","title":"Options","text":"Name Description Required Default <code>--help</code> Show this message and exit. No - <code>--description TEXT</code> Description of the new action. No - <code>--help</code> Show this message and exit. No -"},{"location":"reference/cli/#kamihi-run","title":"<code>kamihi run</code>","text":"<p>Run a project with the Kamihi framework.</p>"},{"location":"reference/cli/#usage_4","title":"Usage","text":"<p><code>kamihi run [OPTIONS]</code></p>"},{"location":"reference/cli/#arguments_4","title":"Arguments","text":"<p>No arguments available</p>"},{"location":"reference/cli/#options_4","title":"Options","text":"Name Description Required Default <code>-l, --log-level [TRACE|DEBUG|INFO|SUCCESS|WARNING|ERROR|CRITICAL]</code> Set the logging level for console loggers.  [default: (INFO)] No - <code>-h, --host TEXT</code> Host of the admin web panel  [default: (localhost)] No - <code>-p, --port INTEGER RANGE</code> Port of the admin web panel  [default: (4242); 1024&lt;=x&lt;=65535] No - <code>--help</code> Show this message and exit. No -"},{"location":"reference/cli/#kamihi-user","title":"<code>kamihi user</code>","text":"<p>No description available</p>"},{"location":"reference/cli/#usage_5","title":"Usage","text":"<p><code>kamihi user add [OPTIONS] TELEGRAM_ID</code></p>"},{"location":"reference/cli/#arguments_5","title":"Arguments","text":"Name Description Required <code>TELEGRAM_ID</code> Telegram ID of the user Yes"},{"location":"reference/cli/#options_5","title":"Options","text":"Name Description Required Default <code>--help</code> Show this message and exit. No - <code>-a, --admin</code> Is the user an admin? No - <code>-d, --data TEXT</code> Additional data for the user in JSON format. For use with custom user classes. No - <code>--help</code> Show this message and exit. No -"},{"location":"reference/cli/#kamihi-db","title":"<code>kamihi db</code>","text":"<p>Database management commands for Kamihi CLI.</p>"},{"location":"reference/cli/#usage_6","title":"Usage","text":"<p><code>kamihi db downgrade [OPTIONS]</code></p>"},{"location":"reference/cli/#arguments_6","title":"Arguments","text":"<p>No arguments available</p>"},{"location":"reference/cli/#options_6","title":"Options","text":"Name Description Required Default <code>--help</code> Show this message and exit. No - <code>--help</code> Show this message and exit. No - <code>-r, --revision TEXT</code> The revision to upgrade to.  [default: (head)] No - <code>--help</code> Show this message and exit. No - <code>-r, --revision TEXT</code> The revision to downgrade to.  [default: (-1)] No - <code>--help</code> Show this message and exit. No -"},{"location":"reference/cli/#kamihi-permission","title":"<code>kamihi permission</code>","text":"<p>No description available</p>"},{"location":"reference/cli/#usage_7","title":"Usage","text":"<p><code>kamihi permission add [OPTIONS] ACTION</code></p>"},{"location":"reference/cli/#arguments_7","title":"Arguments","text":"Name Description Required <code>ACTION</code> Name of the action to assign permission for (without the leading slash). Yes"},{"location":"reference/cli/#options_7","title":"Options","text":"Name Description Required Default <code>--help</code> Show this message and exit. No - <code>-u, --user INTEGER</code> Telegram ID of the user(s) to assign the permission to. Can be used multiple times. No - <code>-r, --role TEXT</code> Role name(s) to assign the permission to. Can be used multiple times. No - <code>--help</code> Show this message and exit. No -"},{"location":"reference/cli/#kamihi-role","title":"<code>kamihi role</code>","text":"<p>No description available</p>"},{"location":"reference/cli/#usage_8","title":"Usage","text":"<p><code>kamihi role assign [OPTIONS] ROLE USERS...</code></p>"},{"location":"reference/cli/#arguments_8","title":"Arguments","text":"Name Description Required <code>NAME</code> Name of the role to add. Yes <code>ROLE</code> Name of the role to assign to users. Yes <code>USERS...</code> Telegram ID of the user(s) to assign the role to. Yes"},{"location":"reference/cli/#options_8","title":"Options","text":"Name Description Required Default <code>--help</code> Show this message and exit. No - <code>--help</code> Show this message and exit. No - <code>--help</code> Show this message and exit. No -"},{"location":"tutorials/","title":"Index","text":"<p>In this section, you can find some tutorials to learn the basics of Kamihi.</p> <p>Unsure where to start? \"Your first bot\" might just be the place.</p>"},{"location":"tutorials/adding-actions/","title":"Adding actions","text":"<p>In the previous tutorial, we got our first bot up and running, but at the moment it doesn't do much.</p> <p>We can easily add functionality to our bot by adding new actions.</p>"},{"location":"tutorials/adding-actions/#what-are-actions","title":"What are actions?","text":"<p>Actions are the basic units that compose a bot. Each action defines a functionality, and is normally associated with one command (like <code>/start</code>, always prefixed with a slash). By adding actions to our bot, we can make it do anything we may want.</p>"},{"location":"tutorials/adding-actions/#the-default-action","title":"The default action","text":"<p>Your basic bot already comes with an action, and the good news is that you have already used it! By sending the command <code>/start</code> to the bot, you executed the action <code>start</code>, that lives in the folder <code>actions/start</code>. Pretty straightforward, right?</p> <p>If you open the file <code>actions/start/start.py</code>, you will find the following content:</p> <pre><code>\"\"\"\nStart action for hello-world.\n\"\"\"\n\nfrom kamihi import bot # (1)!\n\n\n@bot.action # (2)!\nasync def start() -&gt; str: # (3)!\n    \"\"\"\n    Start action for the bot.\n\n    This function is called when the bot starts.\n    \"\"\"\n    return f\"Hello, I'm your friendly bot. How can I help you today?\" # (4)!\n</code></pre> <ol> <li>To interact with Kamihi, we import the <code>bot</code> object. There is no need to initialize any class, the framework takes care of that.</li> <li>We register an action by decorating any <code>async</code> function with <code>@bot.action</code>.</li> <li>Although not strictly needed for basic cases, Kamihi works better when the code is typed.</li> <li>The result returned from the decorated function will be sent to the user.</li> </ol>"},{"location":"tutorials/adding-actions/#creating-a-new-action","title":"Creating a new action","text":"<p>The default action is OK, but really basic. It's all right, though, because we can easily add new actions with a simple command:</p> kamihi action new timeCopying from template version x.x.x identical  actions    create  actions/time    create  actions/time/time.py    create  actions/time/__init__.py <p>This command creates a new <code>actions/time</code> folder with all the files you need to get this action up and running.</p>"},{"location":"tutorials/adding-actions/#making-the-action-interesting","title":"Making the action interesting","text":"<p>If you start the bot right now, and send the command <code>/time</code>, it will answer with a simple \"Hello, world!\". I think we can do better. Since the command is <code>/time</code>, we can make our bot return the time. For that, edit the file <code>actions/time/time.py</code> with the following content:</p> <pre><code>\"\"\"\ntime action.\n\"\"\"\n\n\nfrom datetime import datetime # (1)!\n\nfrom kamihi import bot\n\n\n@bot.action\nasync def time() -&gt; str:\n    \"\"\"\n    time action.\n\n    Returns:#\n        str: The result of the action.\n\n    \"\"\"\n    # Your action logic here\n    return (datetime\n            .now(bot.settings.timezone_obj) # (2)!\n            .strftime(\"It's %H:%M:%S on %A, %B %d, %Y\") # (3)!\n            )\n</code></pre> <ol> <li><code>datetime</code> is the Python standard library time utility.</li> <li>We can access all the settings of the bot with the <code>bot.settings</code> attribute. The <code>timezone_obj</code> property gives us a timezone object from the string we set in <code>kamihi.yml</code>.</li> <li>To get a nice message, we use this expression to format the date and time.</li> </ol>"},{"location":"tutorials/adding-actions/#using-our-new-command","title":"Using our new command","text":"<p>We can restart the bot and our new action will automatically get picked up, its command registered in the bot's menu in Telegram.</p> <p></p> <p>And we can use it in the same way as the other one, by sending <code>/time</code> to our bot.</p>"},{"location":"tutorials/adding-actions/#configuring-the-timezone","title":"Configuring the timezone","text":"<p>If you live around the Greenwich Meridian, you are all set! Continue to the next section. </p> <p>If not, the bot will have told you the wrong time. That is OK, the bot thinks itself in England, but we can easily change that. Refer to this guide for information on how to do so, and then come back.</p>"},{"location":"tutorials/adding-actions/#recap","title":"Recap","text":"<p>We have learned how to create new actions for the bot by using the <code>kamihi action new &lt;name&gt;</code> command. We have also learned how to access the bot's settings.</p> <p>In the actions you create, you can return any Markdown content. You can also integrate it with any other library, as seen with the <code>time</code> action, so go wild!</p>"},{"location":"tutorials/adding-actions/#whats-next","title":"What's next?","text":"<p>Now that you have a basic bot up and running, and you know how to add actions to it, you can customize it to your heart's content. We have just scratched the surface of what you can do with Kamihi. Check out all the guides for more in-depth information on how to use Kamihi to the fullest.</p>"},{"location":"tutorials/your-first-bot/","title":"Your first bot","text":""},{"location":"tutorials/your-first-bot/#prerequisites","title":"Prerequisites","text":"<p>To start using Kamihi, you will need two things installed on your machine:</p> <ul> <li> <p><code>git</code>: a version control manager. You can find installation instructions here, although if you are using Linux, you probably have it. To check your installation, you can use the following command on your terminal of choice:</p> <p>git -vgit version 2.49.0</p> <p>The version does not matter, any is fine as long as it shows.</p> </li> <li> <p><code>uv</code>: a Python package manager. For instructions on installing, you can follow this guide. To verify you have correctly installed it, run this command (any version is fine too):</p> <p>uv --versionuv 0.7.6</p> <p>If you do not want to use <code>uv</code>, refer to the guide for other package managers.</p> </li> </ul>"},{"location":"tutorials/your-first-bot/#creating-your-project","title":"Creating your project","text":"<p>To create a new bot using Kamihi, run the following command:</p> uvx kamihi init hello-worldCopying from template version x.x.x    create  pyproject.toml    ...     <p>This will create a folder named <code>hello-world</code> in your current directory and create all the necessary files. You fill find the following files:</p> <pre><code>hello-world/\n\u251c\u2500\u2500 actions # (1)!\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 start # (2)!\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 start.py\n\u251c\u2500\u2500 migrations # (6)!\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 versions/\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 script.py.mako\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 env.py\n\u251c\u2500\u2500 models # (4)!\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 user.py\n\u251c\u2500\u2500 docker-compose.dev.yml\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 .dockerignore\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 kamihi.yml # (3)!\n\u251c\u2500\u2500 pyproject.toml # (5)!\n\u251c\u2500\u2500 .python-version\n\u2514\u2500\u2500 README.md\n</code></pre> <ol> <li>The actions folder. This is where you'll spend most of your time. It holds all the things you can do with the bot.</li> <li>A sample action, free of charge ;)</li> <li>The configuration file for Kamihi</li> <li>The directory for database models, where you can customize the default ones and add more.</li> <li>The Python project file.</li> <li>The database migrations folder, which is used to keep track of changes to the database schema.</li> </ol> <p>Don't worry if you are not sure what all files do. The base project is designed to work out of the box.</p> <p>Get into the project and install all dependencies by running these two commands:</p> cd hello-worlduv syncUsing CPython 3.12.10Creating virtual environment at: .venvResolved 46 packagesPrepared 2 packagesDone!"},{"location":"tutorials/your-first-bot/#getting-your-token","title":"Getting your token","text":"<p>Before we start doing things with our bot, we need a token. This token is a unique identifier for a bot and is used to authenticate it with the Telegram API. You can get a token by talking to @BotFather on Telegram. Just send him the <code>/newbot</code> command and follow the instructions. He'll give you a token that looks something like this:</p> <pre><code>123456789:ABC-DEF1234ghIkl-zyx57W2P0s\n</code></pre> <p>We can input our token in the configuration file we saw before (<code>kamihi.yml</code>) so that Kamihi can use it. Go ahead and open that file, and paste it in place of <code>YOUR_TOKEN_HERE</code>. Leave the rest alone, we'll come back to it later.</p> <pre><code>---\n\ntoken: YOUR_TOKEN_HERE # (1)!\ntimezone: UTC # Timezone for the bot\n</code></pre> <ol> <li>Right here, substituting <code>YOUR_TOKEN_HERE</code></li> </ol>"},{"location":"tutorials/your-first-bot/#starting-the-database","title":"Starting the database","text":"<p>Kamihi runs on top of SQLAlchemy and Alembic, which means it needs a database to store its data. For development purposes, we can use SQLite, which is a file-based database that requires no setup. To start the database, we just need to run the following two commands:</p> kamihi db migrate2025-01-01 at 00:00:00 | SUCCESS  | Migrated revision='xxxxxxxxxxxx'kamihi db upgrade2025-01-01 at 00:00:00 | SUCCESS  | Upgraded revision='xxxxxxxxxxxx' <p>This will create a file named <code>kamihi.db</code> in the root of your project, which is the SQLite database file. It will also create a file in the <code>migrations</code> folder, which contains the database schema.</p>"},{"location":"tutorials/your-first-bot/#creating-our-first-user","title":"Creating our first user","text":"<p>Last but not least, before we start the bot, we need to register our fist user. For that, we need our account's ID, which you can obtain by messaging this bot on Telegram.</p> <p>We will add this first user as an administrator, so it will have permission to use all actions. Later we will see how we can customize each user's permissions.</p> <p>To add it, we just need to run this command (substituting <code>user_id</code> with your actual Telegram ID):</p> kamihi user add user_id --admin2025-01-01 at 00:00:00 | SUCCESS  | User added telegram_id=&lt;your_user_id&gt;, is_admin=True"},{"location":"tutorials/your-first-bot/#running-the-bot","title":"Running the bot","text":"<p>We are now ready to start our bot for the first time! To do so, just run this command in the root of your project:</p> kamihi run2025-01-01 at 00:00:00 | INFO     | Admin interface started on http://localhost:4242 host='localhost', port=42422025-01-01 at 00:00:00 | SUCCESS  | Started! <p>You can now go to Telegram and start a conversation with your bot by sending the command <code>/start</code>.</p> <p></p>"},{"location":"tutorials/your-first-bot/#what-now","title":"What now?","text":"<p>Now that you have a basic bot up and running, you can start adding some actions to it. We have just scratched the surface of what you can do with Kamihi. Check out the next tutorial on how to add more actions, or the guides for more in-depth information on how to use Kamihi to the fullest.</p>"},{"location":"reference/kamihi/","title":"kamihi","text":""},{"location":"reference/kamihi/#kamihi","title":"kamihi","text":"<p>Kamihi is a Python framework for creating and managing Telegram bots.</p> License <p>MIT</p> <p>Attributes:</p> Name Type Description <code>__version__</code> <code>str</code> <p>The version of the package.</p> <code>bot</code> <code>Bot</code> <p>The bot instance for the Kamihi framework. Preferable to using the Bot class directly, as it ensures that the bot is properly configured and managed by the framework.</p> <p>Modules:</p> Name Description <code>base</code> <p>Base module for the Kamihi framework.</p> <code>bot</code> <p>Bot module for Kamihi.</p> <code>cli</code> <p>Command-line utility for the Kamihi framework.</p> <code>datasources</code> <p>Data sources module for Kamihi.</p> <code>db</code> <p>Database connections module for the Kamihi framework.</p> <code>questions</code> <p>Questions module for Kamihi.</p> <code>tg</code> <p>Telegram module for Kamihi.</p> <code>users</code> <p>Users module of the Kamihi framework.</p> <code>web</code> <p>Web interface module for Kamihi.</p>"},{"location":"reference/kamihi/#kamihi.init_bot","title":"init_bot","text":"<pre><code>init_bot() -&gt; Bot\n</code></pre> <p>Start the Kamihi bot.</p> Source code in <code>src/kamihi/__init__.py</code> <pre><code>def init_bot() -&gt; \"Bot\":\n    \"\"\"Start the Kamihi bot.\"\"\"\n    global bot  # skipcq: PYL-W0603\n\n    from .bot import Bot\n\n    bot = Bot()\n    return bot\n</code></pre>"},{"location":"reference/kamihi/base/","title":"base","text":""},{"location":"reference/kamihi/base/#kamihi.base","title":"kamihi.base","text":"<p>Base module for the Kamihi framework.</p> <p>Provides base utilities and classes for the framework.</p> License <p>MIT</p> <p>Modules:</p> Name Description <code>config</code> <p>Configuration module.</p> <code>logging</code> <p>Logging configuration module.</p> <code>manual_send</code> <p>Module for sending alerts to notification services.</p> <code>utils</code> <p>Utility functions and variables for the Kamihi project.</p> <p>Classes:</p> Name Description <code>KamihiSettings</code> <p>Defines the configuration schema for the Kamihi framework.</p> <p>Functions:</p> Name Description <code>configure_logging</code> <p>Configure logging for the module.</p> <code>get_settings</code> <p>Get the global settings instance.</p> <code>init_settings</code> <p>Initialize the global settings instance.</p>"},{"location":"reference/kamihi/base/#kamihi.base.KamihiSettings","title":"KamihiSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Defines the configuration schema for the Kamihi framework.</p> <p>Attributes:</p> Name Type Description <code>timezone</code> <code>str</code> <p>The timezone for the application.</p> <code>log</code> <code>LogSettings</code> <p>The logging settings.</p> <code>db</code> <code>DatabaseSettings</code> <p>The database settings.</p> <code>token</code> <code>str | None</code> <p>The Telegram bot token.</p> <code>responses</code> <code>ResponseSettings</code> <p>The response settings.</p> <code>web</code> <code>WebSettings</code> <p>The web settings.</p> <p>Methods:</p> Name Description <code>from_yaml</code> <p>Load settings from a custom YAML file.</p> <code>settings_customise_sources</code> <p>Customize the order of settings sources.</p>"},{"location":"reference/kamihi/base/#kamihi.base.KamihiSettings.timezone_obj","title":"timezone_obj  <code>property</code>","text":"<pre><code>timezone_obj: DstTzInfo\n</code></pre> <p>Get the timezone object.</p> <p>Returns:</p> Name Type Description <code>DstTzInfo</code> <code>DstTzInfo</code> <p>The timezone object.</p>"},{"location":"reference/kamihi/base/#kamihi.base.KamihiSettings.from_yaml","title":"from_yaml  <code>classmethod</code>","text":"<pre><code>from_yaml(path: Path) -&gt; KamihiSettings\n</code></pre> <p>Load settings from a custom YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>Path</code> <p>The path to the YAML file.</p> required <p>Returns:</p> Name Type Description <code>KamihiSettings</code> <code>KamihiSettings</code> <p>An instance of KamihiSettings with the loaded settings.</p> Source code in <code>src/kamihi/base/config.py</code> <pre><code>@classmethod\ndef from_yaml(cls, path: Path) -&gt; \"KamihiSettings\":\n    \"\"\"\n    Load settings from a custom YAML file.\n\n    Args:\n        path (Path): The path to the YAML file.\n\n    Returns:\n        KamihiSettings: An instance of KamihiSettings with the loaded settings.\n\n    \"\"\"\n    if path.exists() and path.is_file():\n        with path.open(\"r\", encoding=\"utf-8\") as f:\n            data = yaml.safe_load(f)\n        if data and isinstance(data, dict):\n            return cls(**data)\n    return cls()\n</code></pre>"},{"location":"reference/kamihi/base/#kamihi.base.KamihiSettings.from_yaml(path)","title":"<code>path</code>","text":""},{"location":"reference/kamihi/base/#kamihi.base.KamihiSettings.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; tuple[PydanticBaseSettingsSource, ...]\n</code></pre> <p>Customize the order of settings sources.</p> <p>This method allows you to customize the order in which settings sources are loaded. The order of sources is important because it determines which settings take precedence when there are conflicts. The order of sources is as follows:     1. Environment variables     2. .env file     3. YAML file     4. Initial settings</p> <p>Parameters:</p> Name Type Description Default <code>type[BaseSettings]</code> <p>the settings class to customize sources for</p> required <code>PydanticBaseSettingsSource</code> <p>settings from class initialization</p> required <code>PydanticBaseSettingsSource</code> <p>settings from environment variables</p> required <code>PydanticBaseSettingsSource</code> <p>settings from .env file</p> required <code>PydanticBaseSettingsSource</code> <p>settings from file secrets</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[PydanticBaseSettingsSource, ...]</code> <p>A tuple containing the customized settings sources in the desired order.</p> Source code in <code>src/kamihi/base/config.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,  # skipcq: PYL-W0621\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n    \"\"\"\n    Customize the order of settings sources.\n\n    This method allows you to customize the order in which settings sources are\n    loaded. The order of sources is important because it determines which settings\n    take precedence when there are conflicts.\n    The order of sources is as follows:\n        1. Environment variables\n        2. .env file\n        3. YAML file\n        4. Initial settings\n\n    Args:\n        settings_cls: the settings class to customize sources for\n        init_settings: settings from class initialization\n        env_settings: settings from environment variables\n        dotenv_settings: settings from .env file\n        file_secret_settings: settings from file secrets\n\n    Returns:\n        tuple: A tuple containing the customized settings sources in the desired order.\n\n    \"\"\"\n    return (\n        init_settings,\n        env_settings,\n        dotenv_settings,\n        YamlConfigSettingsSource(\n            settings_cls,\n            yaml_file=[\n                os.getenv(\"KAMIHI_CONFIG_FILE\", \"kamihi.yaml\"),\n                \"kamihi.yaml\",\n                \"kamihi.yml\",\n            ],\n        ),\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"reference/kamihi/base/#kamihi.base.KamihiSettings.settings_customise_sources(settings_cls)","title":"<code>settings_cls</code>","text":""},{"location":"reference/kamihi/base/#kamihi.base.KamihiSettings.settings_customise_sources(init_settings)","title":"<code>init_settings</code>","text":""},{"location":"reference/kamihi/base/#kamihi.base.KamihiSettings.settings_customise_sources(env_settings)","title":"<code>env_settings</code>","text":""},{"location":"reference/kamihi/base/#kamihi.base.KamihiSettings.settings_customise_sources(dotenv_settings)","title":"<code>dotenv_settings</code>","text":""},{"location":"reference/kamihi/base/#kamihi.base.KamihiSettings.settings_customise_sources(file_secret_settings)","title":"<code>file_secret_settings</code>","text":""},{"location":"reference/kamihi/base/#kamihi.base.configure_logging","title":"configure_logging","text":"<pre><code>configure_logging(logger: Logger) -&gt; None\n</code></pre> <p>Configure logging for the module.</p> <p>This function sets up the logging configuration for the module, including log level and format.</p> <p>Parameters:</p> Name Type Description Default <code>Logger</code> <p>The logger instance to configure.</p> required Source code in <code>src/kamihi/base/logging.py</code> <pre><code>def configure_logging(logger: loguru.Logger) -&gt; None:  # noqa: C901 # skipcq: PY-R1000\n    \"\"\"\n    Configure logging for the module.\n\n    This function sets up the logging configuration for the module, including\n    log level and format.\n\n    Args:\n        logger: The logger instance to configure.\n\n    \"\"\"\n    settings = get_settings().log\n\n    logger.remove()\n    logger.configure(patcher=_extra_formatter, extra={\"compact\": \"\"})\n\n    if settings.stdout_enable:\n        fmt = \"&lt;green&gt;{time:YYYY-MM-DD at HH:mm:ss}&lt;/green&gt; | \"\n        fmt += \"&lt;level&gt;{level: &lt;8}&lt;/level&gt; | \"\n        if settings.stdout_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \"{module: &lt;16} | \"\n        fmt += \"{message} \"\n        if settings.stdout_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \"&lt;dim&gt;{extra[compact]}&lt;/dim&gt;\"\n\n        logger.add(\n            sys.__stdout__,\n            level=settings.stdout_level,\n            format=fmt,\n            serialize=settings.stdout_serialize,\n            enqueue=True,\n        )\n\n    if settings.stderr_enable:\n        fmt = \"&lt;green&gt;{time:YYYY-MM-DD at HH:mm:ss}&lt;/green&gt; | \"\n        fmt += \"&lt;level&gt;{level: &lt;8}&lt;/level&gt; | \"\n        if settings.stderr_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \"{module: &lt;16} | \"\n        fmt += \"{message} \"\n        if settings.stderr_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \"&lt;dim&gt;{extra[compact]}&lt;/dim&gt;\"\n\n        logger.add(\n            sys.__stderr__,\n            level=settings.stderr_level,\n            format=fmt,\n            serialize=settings.stderr_serialize,\n            enqueue=True,\n        )\n\n    if settings.file_enable:\n        fmt = \"&lt;green&gt;{time:YYYY-MM-DD at HH:mm:ss}&lt;/green&gt; | \"\n        fmt += \"&lt;level&gt;{level: &lt;8}&lt;/level&gt; | \"\n        if settings.file_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \"{module: &lt;16} | \"\n        fmt += \"{message} \"\n        if settings.file_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \"&lt;dim&gt;{extra[compact]}&lt;/dim&gt;\"\n\n        logger.add(\n            settings.file_path,\n            level=settings.file_level,\n            format=fmt,\n            serialize=settings.file_serialize,\n            rotation=settings.file_rotation,\n            retention=settings.file_retention,\n            enqueue=True,\n        )\n\n    if settings.notification_enable:\n        manual_sender = ManualSender(settings.notification_urls)\n        fmt = \"{level.icon} *{level.name}*\"\n        if settings.notification_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \" from `{module}`\"\n        fmt += \"\\n{message}\"\n        if settings.notification_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \"\\n\\n{extra[pretty]}\"\n\n        logger.add(\n            manual_sender.notify,\n            level=settings.notification_level,\n            format=fmt,\n            filter={\"apprise\": False},\n            enqueue=True,\n        )\n\n    logging.basicConfig(\n        handlers=[_InterceptHandler(logger, include=[\"alembic\"])],\n        level=0,\n        force=True,\n    )\n</code></pre>"},{"location":"reference/kamihi/base/#kamihi.base.configure_logging(logger)","title":"<code>logger</code>","text":""},{"location":"reference/kamihi/base/#kamihi.base.get_settings","title":"get_settings","text":"<pre><code>get_settings() -&gt; KamihiSettings\n</code></pre> <p>Get the global settings instance.</p> Source code in <code>src/kamihi/base/config.py</code> <pre><code>def get_settings() -&gt; KamihiSettings:\n    \"\"\"Get the global settings instance.\"\"\"\n    if _settings is None:\n        raise RuntimeError(\"Settings not initialized. Call init_settings() first.\")\n    return _settings\n</code></pre>"},{"location":"reference/kamihi/base/#kamihi.base.init_settings","title":"init_settings","text":"<pre><code>init_settings(path: Path | None = None) -&gt; None\n</code></pre> <p>Initialize the global settings instance.</p> <p>Parameters:</p> Name Type Description Default <code>Path | None</code> <p>Optional path to a YAML configuration file.</p> <code>None</code> Source code in <code>src/kamihi/base/config.py</code> <pre><code>def init_settings(path: Path | None = None) -&gt; None:\n    \"\"\"\n    Initialize the global settings instance.\n\n    Args:\n        path (Path | None): Optional path to a YAML configuration file.\n\n    \"\"\"\n    global _settings  # skipcq: PYL-W0603\n    if _settings is None:\n        _settings = KamihiSettings.from_yaml(path) if path else KamihiSettings()\n</code></pre>"},{"location":"reference/kamihi/base/#kamihi.base.init_settings(path)","title":"<code>path</code>","text":""},{"location":"reference/kamihi/base/config/","title":"config","text":""},{"location":"reference/kamihi/base/config/#kamihi.base.config","title":"kamihi.base.config","text":"<p>Configuration module.</p> <p>This module contains the configuration settings for the Kamihi framework. The configuration settings are loaded from environment variables and/or a <code>.env</code> file. They must begin with the prefix <code>KAMIHI_</code>.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>DatabaseSettings</code> <p>Defines the database settings schema.</p> <code>JobSettings</code> <p>Defines the job settings schema.</p> <code>KamihiSettings</code> <p>Defines the configuration schema for the Kamihi framework.</p> <code>LogLevel</code> <p>Enum for log levels.</p> <code>LogSettings</code> <p>Defines the logging configuration schema.</p> <code>QuestionSettings</code> <p>Defines the question settings schema.</p> <code>ResponseSettings</code> <p>Defines the response settings schema.</p> <code>WebSettings</code> <p>Defines the web settings schema.</p> <p>Functions:</p> Name Description <code>get_settings</code> <p>Get the global settings instance.</p> <code>init_settings</code> <p>Initialize the global settings instance.</p>"},{"location":"reference/kamihi/base/config/#kamihi.base.config.DatabaseSettings","title":"DatabaseSettings","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the database settings schema.</p> <p>Attributes:</p> Name Type Description <code>url</code> <code>str</code> <p>The database connection URL.</p>"},{"location":"reference/kamihi/base/config/#kamihi.base.config.JobSettings","title":"JobSettings","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the job settings schema.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Whether to enable job scheduling.</p>"},{"location":"reference/kamihi/base/config/#kamihi.base.config.KamihiSettings","title":"KamihiSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Defines the configuration schema for the Kamihi framework.</p> <p>Attributes:</p> Name Type Description <code>timezone</code> <code>str</code> <p>The timezone for the application.</p> <code>log</code> <code>LogSettings</code> <p>The logging settings.</p> <code>db</code> <code>DatabaseSettings</code> <p>The database settings.</p> <code>token</code> <code>str | None</code> <p>The Telegram bot token.</p> <code>responses</code> <code>ResponseSettings</code> <p>The response settings.</p> <code>web</code> <code>WebSettings</code> <p>The web settings.</p> <p>Methods:</p> Name Description <code>from_yaml</code> <p>Load settings from a custom YAML file.</p> <code>settings_customise_sources</code> <p>Customize the order of settings sources.</p>"},{"location":"reference/kamihi/base/config/#kamihi.base.config.KamihiSettings.timezone_obj","title":"timezone_obj  <code>property</code>","text":"<pre><code>timezone_obj: DstTzInfo\n</code></pre> <p>Get the timezone object.</p> <p>Returns:</p> Name Type Description <code>DstTzInfo</code> <code>DstTzInfo</code> <p>The timezone object.</p>"},{"location":"reference/kamihi/base/config/#kamihi.base.config.KamihiSettings.from_yaml","title":"from_yaml  <code>classmethod</code>","text":"<pre><code>from_yaml(path: Path) -&gt; KamihiSettings\n</code></pre> <p>Load settings from a custom YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>Path</code> <p>The path to the YAML file.</p> required <p>Returns:</p> Name Type Description <code>KamihiSettings</code> <code>KamihiSettings</code> <p>An instance of KamihiSettings with the loaded settings.</p> Source code in <code>src/kamihi/base/config.py</code> <pre><code>@classmethod\ndef from_yaml(cls, path: Path) -&gt; \"KamihiSettings\":\n    \"\"\"\n    Load settings from a custom YAML file.\n\n    Args:\n        path (Path): The path to the YAML file.\n\n    Returns:\n        KamihiSettings: An instance of KamihiSettings with the loaded settings.\n\n    \"\"\"\n    if path.exists() and path.is_file():\n        with path.open(\"r\", encoding=\"utf-8\") as f:\n            data = yaml.safe_load(f)\n        if data and isinstance(data, dict):\n            return cls(**data)\n    return cls()\n</code></pre>"},{"location":"reference/kamihi/base/config/#kamihi.base.config.KamihiSettings.from_yaml(path)","title":"<code>path</code>","text":""},{"location":"reference/kamihi/base/config/#kamihi.base.config.KamihiSettings.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; tuple[PydanticBaseSettingsSource, ...]\n</code></pre> <p>Customize the order of settings sources.</p> <p>This method allows you to customize the order in which settings sources are loaded. The order of sources is important because it determines which settings take precedence when there are conflicts. The order of sources is as follows:     1. Environment variables     2. .env file     3. YAML file     4. Initial settings</p> <p>Parameters:</p> Name Type Description Default <code>type[BaseSettings]</code> <p>the settings class to customize sources for</p> required <code>PydanticBaseSettingsSource</code> <p>settings from class initialization</p> required <code>PydanticBaseSettingsSource</code> <p>settings from environment variables</p> required <code>PydanticBaseSettingsSource</code> <p>settings from .env file</p> required <code>PydanticBaseSettingsSource</code> <p>settings from file secrets</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[PydanticBaseSettingsSource, ...]</code> <p>A tuple containing the customized settings sources in the desired order.</p> Source code in <code>src/kamihi/base/config.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,  # skipcq: PYL-W0621\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n    \"\"\"\n    Customize the order of settings sources.\n\n    This method allows you to customize the order in which settings sources are\n    loaded. The order of sources is important because it determines which settings\n    take precedence when there are conflicts.\n    The order of sources is as follows:\n        1. Environment variables\n        2. .env file\n        3. YAML file\n        4. Initial settings\n\n    Args:\n        settings_cls: the settings class to customize sources for\n        init_settings: settings from class initialization\n        env_settings: settings from environment variables\n        dotenv_settings: settings from .env file\n        file_secret_settings: settings from file secrets\n\n    Returns:\n        tuple: A tuple containing the customized settings sources in the desired order.\n\n    \"\"\"\n    return (\n        init_settings,\n        env_settings,\n        dotenv_settings,\n        YamlConfigSettingsSource(\n            settings_cls,\n            yaml_file=[\n                os.getenv(\"KAMIHI_CONFIG_FILE\", \"kamihi.yaml\"),\n                \"kamihi.yaml\",\n                \"kamihi.yml\",\n            ],\n        ),\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"reference/kamihi/base/config/#kamihi.base.config.KamihiSettings.settings_customise_sources(settings_cls)","title":"<code>settings_cls</code>","text":""},{"location":"reference/kamihi/base/config/#kamihi.base.config.KamihiSettings.settings_customise_sources(init_settings)","title":"<code>init_settings</code>","text":""},{"location":"reference/kamihi/base/config/#kamihi.base.config.KamihiSettings.settings_customise_sources(env_settings)","title":"<code>env_settings</code>","text":""},{"location":"reference/kamihi/base/config/#kamihi.base.config.KamihiSettings.settings_customise_sources(dotenv_settings)","title":"<code>dotenv_settings</code>","text":""},{"location":"reference/kamihi/base/config/#kamihi.base.config.KamihiSettings.settings_customise_sources(file_secret_settings)","title":"<code>file_secret_settings</code>","text":""},{"location":"reference/kamihi/base/config/#kamihi.base.config.LogLevel","title":"LogLevel","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum for log levels.</p> <p>This enum defines the log levels used in the logging configuration.</p> <p>Attributes:</p> Name Type Description <code>TRACE</code> <p>Trace level logging.</p> <code>DEBUG</code> <p>Debug level logging.</p> <code>INFO</code> <p>Info level logging.</p> <code>SUCCESS</code> <p>Success level logging.</p> <code>WARNING</code> <p>Warning level logging.</p> <code>ERROR</code> <p>Error level logging.</p> <code>CRITICAL</code> <p>Critical level logging.</p>"},{"location":"reference/kamihi/base/config/#kamihi.base.config.LogSettings","title":"LogSettings","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the logging configuration schema.</p> <p>Attributes:</p> Name Type Description <code>stdout_enable</code> <code>bool</code> <p>Enable or disable stdout logging.</p> <code>stdout_level</code> <code>str</code> <p>Log level for stdout logging.</p> <code>stdout_serialize</code> <code>bool</code> <p>Enable or disable serialization for stdout logging.</p> <code>stderr_enable</code> <code>bool</code> <p>Enable or disable stderr logging.</p> <code>stderr_level</code> <code>str</code> <p>Log level for stderr logging.</p> <code>stderr_serialize</code> <code>bool</code> <p>Enable or disable serialization for stderr logging.</p> <code>file_enable</code> <code>bool</code> <p>Enable or disable file logging.</p> <code>file_level</code> <code>str</code> <p>Log level for file logging.</p> <code>file_path</code> <code>str</code> <p>Path to the log file.</p> <code>file_serialize</code> <code>bool</code> <p>Enable or disable serialization for file logging.</p> <code>file_rotation</code> <code>str</code> <p>Rotation policy for the log file.</p> <code>file_retention</code> <code>str</code> <p>Retention policy for the log file.</p> <code>notification_enable</code> <code>bool</code> <p>Enable or disable notification logging.</p> <code>notification_level</code> <code>str</code> <p>Log level for notification logging.</p> <code>notification_urls</code> <code>list[str]</code> <p>List of URLs for notification services.</p>"},{"location":"reference/kamihi/base/config/#kamihi.base.config.QuestionSettings","title":"QuestionSettings","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the question settings schema.</p> <p>Attributes:</p> Name Type Description <code>timeout</code> <code>int</code> <p>The timeout for questions in seconds.</p>"},{"location":"reference/kamihi/base/config/#kamihi.base.config.ResponseSettings","title":"ResponseSettings","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the response settings schema.</p> <p>Attributes:</p> Name Type Description <code>default_enabled(bool)</code> <p>Whether to enable the default message</p> <code>default_message(str)</code> <p>The message to return when no handler has been triggered</p> <code>error_message(str)</code> <p>The message to send to the user when an error happens</p> <code>cancel_command(str)</code> <p>The command to cancel an ongoing operation</p> <code>cancel_message(str)</code> <p>The message to send when an operation is cancelled</p>"},{"location":"reference/kamihi/base/config/#kamihi.base.config.WebSettings","title":"WebSettings","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the web settings schema.</p> <p>Attributes:</p> Name Type Description <code>host</code> <code>str</code> <p>The host of the web interface.</p> <code>port</code> <code>int</code> <p>The port of the web interface.</p>"},{"location":"reference/kamihi/base/config/#kamihi.base.config.get_settings","title":"get_settings","text":"<pre><code>get_settings() -&gt; KamihiSettings\n</code></pre> <p>Get the global settings instance.</p> Source code in <code>src/kamihi/base/config.py</code> <pre><code>def get_settings() -&gt; KamihiSettings:\n    \"\"\"Get the global settings instance.\"\"\"\n    if _settings is None:\n        raise RuntimeError(\"Settings not initialized. Call init_settings() first.\")\n    return _settings\n</code></pre>"},{"location":"reference/kamihi/base/config/#kamihi.base.config.init_settings","title":"init_settings","text":"<pre><code>init_settings(path: Path | None = None) -&gt; None\n</code></pre> <p>Initialize the global settings instance.</p> <p>Parameters:</p> Name Type Description Default <code>Path | None</code> <p>Optional path to a YAML configuration file.</p> <code>None</code> Source code in <code>src/kamihi/base/config.py</code> <pre><code>def init_settings(path: Path | None = None) -&gt; None:\n    \"\"\"\n    Initialize the global settings instance.\n\n    Args:\n        path (Path | None): Optional path to a YAML configuration file.\n\n    \"\"\"\n    global _settings  # skipcq: PYL-W0603\n    if _settings is None:\n        _settings = KamihiSettings.from_yaml(path) if path else KamihiSettings()\n</code></pre>"},{"location":"reference/kamihi/base/config/#kamihi.base.config.init_settings(path)","title":"<code>path</code>","text":""},{"location":"reference/kamihi/base/logging/","title":"logging","text":""},{"location":"reference/kamihi/base/logging/#kamihi.base.logging","title":"kamihi.base.logging","text":"<p>Logging configuration module.</p> <p>This module provides functions to configure logging for the Kamihi framework.</p> License <p>MIT</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from kamihi.base.logging import configure_logging\n&gt;&gt;&gt; from kamihi.base.config import LogSettings\n&gt;&gt;&gt; from loguru import logger\n&gt;&gt;&gt; settings = LogSettings()\n&gt;&gt;&gt; configure_logging(logger, settings)\n&gt;&gt;&gt; logger.info(\"This is an info message.\")\n</code></pre> <p>Classes:</p> Name Description <code>StreamToLogger</code> <p>Fake file-like stream object that redirects writes to a logger instance.</p> <p>Functions:</p> Name Description <code>configure_logging</code> <p>Configure logging for the module.</p>"},{"location":"reference/kamihi/base/logging/#kamihi.base.logging.StreamToLogger","title":"StreamToLogger","text":"<pre><code>StreamToLogger(logger: Logger, level: str = 'INFO')\n</code></pre> <p>Fake file-like stream object that redirects writes to a logger instance.</p> <p>Parameters:</p> Name Type Description Default <code>Logger</code> <p>The logger instance to redirect writes to.</p> required <code>str</code> <p>The log level to use for the writes (default: \"INFO\").</p> <code>'INFO'</code> <p>Initialize the stream to logger.</p> <p>Parameters:</p> Name Type Description Default <code>Logger</code> <p>The logger instance to redirect writes to.</p> required <code>str</code> <p>The log level to use for the writes (default: \"INFO\").</p> <code>'INFO'</code> <p>Methods:</p> Name Description <code>flush</code> <p>Flush the stream.</p> <code>write</code> <p>Write a buffer to the logger.</p> Source code in <code>src/kamihi/base/logging.py</code> <pre><code>def __init__(self, logger: loguru.Logger, level: str = \"INFO\") -&gt; None:\n    \"\"\"\n    Initialize the stream to logger.\n\n    Args:\n        logger: The logger instance to redirect writes to.\n        level: The log level to use for the writes (default: \"INFO\").\n\n    \"\"\"\n    self.logger = logger\n    self._level = level\n</code></pre>"},{"location":"reference/kamihi/base/logging/#kamihi.base.logging.StreamToLogger(logger)","title":"<code>logger</code>","text":""},{"location":"reference/kamihi/base/logging/#kamihi.base.logging.StreamToLogger(level)","title":"<code>level</code>","text":""},{"location":"reference/kamihi/base/logging/#kamihi.base.logging.StreamToLogger(logger)","title":"<code>logger</code>","text":""},{"location":"reference/kamihi/base/logging/#kamihi.base.logging.StreamToLogger(level)","title":"<code>level</code>","text":""},{"location":"reference/kamihi/base/logging/#kamihi.base.logging.StreamToLogger.flush","title":"flush","text":"<pre><code>flush() -&gt; None\n</code></pre> <p>Flush the stream.</p> Source code in <code>src/kamihi/base/logging.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Flush the stream.\"\"\"\n    pass  # No action needed for flushing\n</code></pre>"},{"location":"reference/kamihi/base/logging/#kamihi.base.logging.StreamToLogger.write","title":"write","text":"<pre><code>write(buffer: str) -&gt; None\n</code></pre> <p>Write a buffer to the logger.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The buffer to write.</p> required Source code in <code>src/kamihi/base/logging.py</code> <pre><code>def write(self, buffer: str) -&gt; None:\n    \"\"\"\n    Write a buffer to the logger.\n\n    Args:\n        buffer: The buffer to write.\n\n    \"\"\"\n    for line in buffer.rstrip().splitlines():\n        self.logger.opt(depth=1).log(self._level, line.strip())\n</code></pre>"},{"location":"reference/kamihi/base/logging/#kamihi.base.logging.StreamToLogger.write(buffer)","title":"<code>buffer</code>","text":""},{"location":"reference/kamihi/base/logging/#kamihi.base.logging.configure_logging","title":"configure_logging","text":"<pre><code>configure_logging(logger: Logger) -&gt; None\n</code></pre> <p>Configure logging for the module.</p> <p>This function sets up the logging configuration for the module, including log level and format.</p> <p>Parameters:</p> Name Type Description Default <code>Logger</code> <p>The logger instance to configure.</p> required Source code in <code>src/kamihi/base/logging.py</code> <pre><code>def configure_logging(logger: loguru.Logger) -&gt; None:  # noqa: C901 # skipcq: PY-R1000\n    \"\"\"\n    Configure logging for the module.\n\n    This function sets up the logging configuration for the module, including\n    log level and format.\n\n    Args:\n        logger: The logger instance to configure.\n\n    \"\"\"\n    settings = get_settings().log\n\n    logger.remove()\n    logger.configure(patcher=_extra_formatter, extra={\"compact\": \"\"})\n\n    if settings.stdout_enable:\n        fmt = \"&lt;green&gt;{time:YYYY-MM-DD at HH:mm:ss}&lt;/green&gt; | \"\n        fmt += \"&lt;level&gt;{level: &lt;8}&lt;/level&gt; | \"\n        if settings.stdout_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \"{module: &lt;16} | \"\n        fmt += \"{message} \"\n        if settings.stdout_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \"&lt;dim&gt;{extra[compact]}&lt;/dim&gt;\"\n\n        logger.add(\n            sys.__stdout__,\n            level=settings.stdout_level,\n            format=fmt,\n            serialize=settings.stdout_serialize,\n            enqueue=True,\n        )\n\n    if settings.stderr_enable:\n        fmt = \"&lt;green&gt;{time:YYYY-MM-DD at HH:mm:ss}&lt;/green&gt; | \"\n        fmt += \"&lt;level&gt;{level: &lt;8}&lt;/level&gt; | \"\n        if settings.stderr_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \"{module: &lt;16} | \"\n        fmt += \"{message} \"\n        if settings.stderr_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \"&lt;dim&gt;{extra[compact]}&lt;/dim&gt;\"\n\n        logger.add(\n            sys.__stderr__,\n            level=settings.stderr_level,\n            format=fmt,\n            serialize=settings.stderr_serialize,\n            enqueue=True,\n        )\n\n    if settings.file_enable:\n        fmt = \"&lt;green&gt;{time:YYYY-MM-DD at HH:mm:ss}&lt;/green&gt; | \"\n        fmt += \"&lt;level&gt;{level: &lt;8}&lt;/level&gt; | \"\n        if settings.file_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \"{module: &lt;16} | \"\n        fmt += \"{message} \"\n        if settings.file_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \"&lt;dim&gt;{extra[compact]}&lt;/dim&gt;\"\n\n        logger.add(\n            settings.file_path,\n            level=settings.file_level,\n            format=fmt,\n            serialize=settings.file_serialize,\n            rotation=settings.file_rotation,\n            retention=settings.file_retention,\n            enqueue=True,\n        )\n\n    if settings.notification_enable:\n        manual_sender = ManualSender(settings.notification_urls)\n        fmt = \"{level.icon} *{level.name}*\"\n        if settings.notification_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \" from `{module}`\"\n        fmt += \"\\n{message}\"\n        if settings.notification_level in [LogLevel.TRACE, LogLevel.DEBUG]:\n            fmt += \"\\n\\n{extra[pretty]}\"\n\n        logger.add(\n            manual_sender.notify,\n            level=settings.notification_level,\n            format=fmt,\n            filter={\"apprise\": False},\n            enqueue=True,\n        )\n\n    logging.basicConfig(\n        handlers=[_InterceptHandler(logger, include=[\"alembic\"])],\n        level=0,\n        force=True,\n    )\n</code></pre>"},{"location":"reference/kamihi/base/logging/#kamihi.base.logging.configure_logging(logger)","title":"<code>logger</code>","text":""},{"location":"reference/kamihi/base/manual_send/","title":"manual_send","text":""},{"location":"reference/kamihi/base/manual_send/#kamihi.base.manual_send","title":"kamihi.base.manual_send","text":"<p>Module for sending alerts to notification services.</p> <p>This module provides functions for sending alerts to notification services using the Apprise library.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>ManualSender</code> <p>Class for sending alerts to notification services.</p>"},{"location":"reference/kamihi/base/manual_send/#kamihi.base.manual_send.ManualSender","title":"ManualSender","text":"<pre><code>ManualSender(urls: list[str])\n</code></pre> <p>               Bases: <code>Apprise</code></p> <p>Class for sending alerts to notification services.</p> <p>This class extends the Apprise library to provide a simple interface for sending alerts to various notification services using Apprise URLs.</p> <p>Manual sender.</p> <p>Parameters:</p> Name Type Description Default <code>list[str]</code> <p>List of Apprise URLs for sending alerts through notification services.</p> required Source code in <code>src/kamihi/base/manual_send.py</code> <pre><code>def __init__(self, urls: list[str]) -&gt; None:\n    \"\"\"\n    Manual sender.\n\n    Args:\n        urls: List of Apprise URLs for sending alerts through notification services.\n\n    \"\"\"\n    super().__init__()\n    self.add(urls)\n</code></pre>"},{"location":"reference/kamihi/base/manual_send/#kamihi.base.manual_send.ManualSender(urls)","title":"<code>urls</code>","text":""},{"location":"reference/kamihi/base/utils/","title":"utils","text":""},{"location":"reference/kamihi/base/utils/#kamihi.base.utils","title":"kamihi.base.utils","text":"<p>Utility functions and variables for the Kamihi project.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>cron_regex</code> <p>Get the compiled regex pattern for validating cron expressions.</p> <code>is_valid_cron_expression</code> <p>Validate if a given string is a valid cron expression.</p> <code>requires</code> <p>Check if required optional dependencies are available.</p> <code>timer</code> <p>Context manager to log the time taken for a block of code.</p>"},{"location":"reference/kamihi/base/utils/#kamihi.base.utils.cron_regex","title":"cron_regex  <code>cached</code>","text":"<pre><code>cron_regex() -&gt; re.Pattern\n</code></pre> <p>Get the compiled regex pattern for validating cron expressions.</p> <p>Returns:</p> Type Description <code>Pattern</code> <p>re.Pattern: The compiled regex pattern.</p> Source code in <code>src/kamihi/base/utils.py</code> <pre><code>@functools.lru_cache(maxsize=1)\ndef cron_regex() -&gt; re.Pattern:\n    \"\"\"\n    Get the compiled regex pattern for validating cron expressions.\n\n    Returns:\n        re.Pattern: The compiled regex pattern.\n\n    \"\"\"\n    # Month and weekday names\n    month_name = r\"(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\"\n    weekday_name = r\"(?:mon|tue|wed|thu|fri|sat|sun)\"\n    name = rf\"(?:{month_name}|{weekday_name})\"\n\n    # Basic building blocks\n    number = r\"\\d+\"\n    star = r\"\\*\"\n    step = rf\"(?:\\*/{number})\"\n    rng = rf\"(?:{number}|{name})-(?:{number}|{name})\"\n    rng_step = rf\"{rng}/{number}\"\n    xth_y = rf\"{number}th\\s+(?:{number}|{weekday_name})\"\n    last_x = rf\"last\\s+(?:{number}|{weekday_name})\"\n    last = r\"last\"\n\n    # Single field expression\n    single_expr = rf\"(?:{star}|{step}|{rng_step}|{rng}|{number}|{name}|{xth_y}|{last_x}|{last})\"\n\n    # Comma-separated list\n    field = rf\"{single_expr}(?:,{single_expr})*\"\n\n    # Full crontab line (5\u20137 fields)\n    return re.compile(\n        rf\"^(?:{field}\\s+){{4,6}}{field}$\",  # 5\u20137 fields\n        re.IGNORECASE,\n    )\n</code></pre>"},{"location":"reference/kamihi/base/utils/#kamihi.base.utils.is_valid_cron_expression","title":"is_valid_cron_expression","text":"<pre><code>is_valid_cron_expression(expression: str) -&gt; bool\n</code></pre> <p>Validate if a given string is a valid cron expression.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The cron expression to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the expression is valid, False otherwise.</p> Source code in <code>src/kamihi/base/utils.py</code> <pre><code>def is_valid_cron_expression(expression: str) -&gt; bool:\n    \"\"\"\n    Validate if a given string is a valid cron expression.\n\n    Args:\n        expression (str): The cron expression to validate.\n\n    Returns:\n        bool: True if the expression is valid, False otherwise.\n\n    \"\"\"\n    return bool(cron_regex().match(expression.strip()))\n</code></pre>"},{"location":"reference/kamihi/base/utils/#kamihi.base.utils.is_valid_cron_expression(expression)","title":"<code>expression</code>","text":""},{"location":"reference/kamihi/base/utils/#kamihi.base.utils.requires","title":"requires","text":"<pre><code>requires(group: str) -&gt; Callable\n</code></pre> <p>Check if required optional dependencies are available.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name of the extra group to check for dependencies.</p> required Source code in <code>src/kamihi/base/utils.py</code> <pre><code>def requires(group: str) -&gt; Callable:\n    \"\"\"\n    Check if required optional dependencies are available.\n\n    Args:\n        group (str): The name of the extra group to check for dependencies.\n\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        @functools.wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            _check_extra_installed(group)\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/kamihi/base/utils/#kamihi.base.utils.requires(group)","title":"<code>group</code>","text":""},{"location":"reference/kamihi/base/utils/#kamihi.base.utils.timer","title":"timer","text":"<pre><code>timer(\n    logger: Logger, message: str, level: str = \"DEBUG\"\n) -&gt; Generator[None, Any, None]\n</code></pre> <p>Context manager to log the time taken for a block of code.</p> <p>Parameters:</p> Name Type Description Default <code>Logger</code> <p>The logger instance to use for logging.</p> required <code>str</code> <p>The message to log with the elapsed time.</p> required <code>str</code> <p>The logging level to use (default is \"DEBUG\").</p> <code>'DEBUG'</code> <p>Returns:</p> Type Description <code>None</code> <p>Generator[None, Any, None]: A generator that yields control to the block of code being timed.</p> Source code in <code>src/kamihi/base/utils.py</code> <pre><code>@contextmanager\ndef timer(logger: \"Logger\", message: str, level: str = \"DEBUG\") -&gt; Generator[None, Any, None]:  # noqa: ANN001\n    \"\"\"\n    Context manager to log the time taken for a block of code.\n\n    Args:\n        logger (Logger): The logger instance to use for logging.\n        message (str): The message to log with the elapsed time.\n        level (str): The logging level to use (default is \"DEBUG\").\n\n    Returns:\n        Generator[None, Any, None]: A generator that yields control to the block of code being timed.\n\n    \"\"\"\n    start_time = time.perf_counter()\n    yield\n    end_time = time.perf_counter()\n    logger.bind(ms=round((end_time - start_time) * 1000)).log(level, message)\n</code></pre>"},{"location":"reference/kamihi/base/utils/#kamihi.base.utils.timer(logger)","title":"<code>logger</code>","text":""},{"location":"reference/kamihi/base/utils/#kamihi.base.utils.timer(message)","title":"<code>message</code>","text":""},{"location":"reference/kamihi/base/utils/#kamihi.base.utils.timer(level)","title":"<code>level</code>","text":""},{"location":"reference/kamihi/bot/","title":"bot","text":""},{"location":"reference/kamihi/bot/#kamihi.bot","title":"kamihi.bot","text":"<p>Bot module for Kamihi.</p> <p>This module provides the primary interface for the Kamihi framework, allowing for the creation and management of Telegram bots.</p> License <p>MIT</p> <p>Modules:</p> Name Description <code>action</code> <p>Action helper class.</p> <code>bot</code> <p>Bot module for Kamihi.</p> <p>Classes:</p> Name Description <code>Action</code> <p>Action class for Kamihi bot.</p> <code>Bot</code> <p>Bot class for Kamihi.</p>"},{"location":"reference/kamihi/bot/#kamihi.bot.Action","title":"Action","text":"<pre><code>Action(\n    name: str,\n    commands: list[str],\n    description: str,\n    func: Callable,\n    datasources: dict[str, DataSource] = None,\n)\n</code></pre> <p>Action class for Kamihi bot.</p> <p>This class provides helpers for defining actions, their commands and their handlers.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the action.</p> <code>commands</code> <code>list[str]</code> <p>List of commands associated.</p> <code>description</code> <code>str</code> <p>Description of the action.</p> <p>Initialize the Action class.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name of the action.</p> required <code>list[str]</code> <p>List of commands associated.</p> required <code>str</code> <p>Description of the action.</p> required <code>Callable</code> <p>The function to be executed when the action is called.</p> required <code>dict[str, DataSource]</code> <p>Dictionary of data sources available for the action.</p> <code>None</code> <p>Methods:</p> Name Description <code>clean_up</code> <p>Clean up the action from the database.</p> <code>run_scheduled</code> <p>Execute the action in a job context.</p> Source code in <code>src/kamihi/bot/action.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    commands: list[str],\n    description: str,\n    func: Callable,\n    datasources: dict[str, DataSource] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the Action class.\n\n    Args:\n        name (str): The name of the action.\n        commands (list[str]): List of commands associated.\n        description (str): Description of the action.\n        func (Callable): The function to be executed when the action is called.\n        datasources (dict[str, DataSource]): Dictionary of data sources available for the action.\n\n    \"\"\"\n    self.name = name\n    self.commands = commands\n    self.description = description\n\n    self._func = func\n    self._logger = logger.bind(action=self.name)\n\n    self._datasources = datasources or {}\n\n    self._files = Environment(\n        loader=FileSystemLoader(self._folder_path),\n        autoescape=select_autoescape(default_for_string=False),\n    )\n\n    self._validate_commands()\n    self._validate_function()\n    self._validate_requests()\n\n    self._save_to_db()\n\n    self._logger.debug(\"Successfully registered\")\n</code></pre>"},{"location":"reference/kamihi/bot/#kamihi.bot.Action(name)","title":"<code>name</code>","text":""},{"location":"reference/kamihi/bot/#kamihi.bot.Action(commands)","title":"<code>commands</code>","text":""},{"location":"reference/kamihi/bot/#kamihi.bot.Action(description)","title":"<code>description</code>","text":""},{"location":"reference/kamihi/bot/#kamihi.bot.Action(func)","title":"<code>func</code>","text":""},{"location":"reference/kamihi/bot/#kamihi.bot.Action(datasources)","title":"<code>datasources</code>","text":""},{"location":"reference/kamihi/bot/#kamihi.bot.Action.handler","title":"handler  <code>property</code>","text":"<pre><code>handler: AuthHandler | ConversationHandler\n</code></pre> <p>Construct a CommandHandler for the action.</p>"},{"location":"reference/kamihi/bot/#kamihi.bot.Action.jobs","title":"jobs  <code>property</code>","text":"<pre><code>jobs: list[\n    tuple[\n        Job,\n        Callable[\n            [CallbackContext], Coroutine[Any, Any, None]\n        ],\n    ]\n]\n</code></pre> <p>Return a list of jobs associated with the action.</p>"},{"location":"reference/kamihi/bot/#kamihi.bot.Action.users","title":"users  <code>property</code>","text":"<pre><code>users: Sequence[BaseUser]\n</code></pre> <p>Return a list of telegram IDs of users authorized to use the action.</p>"},{"location":"reference/kamihi/bot/#kamihi.bot.Action.clean_up","title":"clean_up  <code>classmethod</code>","text":"<pre><code>clean_up(keep: list[str]) -&gt; None\n</code></pre> <p>Clean up the action from the database.</p> Source code in <code>src/kamihi/bot/action.py</code> <pre><code>@classmethod\ndef clean_up(cls, keep: list[str]) -&gt; None:\n    \"\"\"Clean up the action from the database.\"\"\"\n    with Session(get_engine()) as session:\n        statement = select(RegisteredAction).where(RegisteredAction.name.not_in(keep))\n        actions = session.execute(statement).scalars().all()\n        for action in actions:\n            session.delete(action)\n        session.commit()\n</code></pre>"},{"location":"reference/kamihi/bot/#kamihi.bot.Action.run_scheduled","title":"run_scheduled  <code>async</code>","text":"<pre><code>run_scheduled(context: CallbackContext) -&gt; None\n</code></pre> <p>Execute the action in a job context.</p> Source code in <code>src/kamihi/bot/action.py</code> <pre><code>async def run_scheduled(self, context: CallbackContext) -&gt; None:\n    \"\"\"Execute the action in a job context.\"\"\"\n    per_user = context.job.data.get(\"per_user\", False)\n\n    self._logger.debug(\"Executing scheduled action\", per_user=per_user)\n\n    if per_user:\n        for telegram_id in context.job.data.get(\"users\", []):\n            context.job.data[\"user\"] = telegram_id\n            pos_args, keyword_args = await self._fill_parameters(context)\n\n            result: Any = await self._func(*pos_args, **keyword_args)\n\n            await send(result, telegram_id, context)\n    else:\n        pos_args, keyword_args = await self._fill_parameters(context)\n\n        result: Any = await self._func(*pos_args, **keyword_args)\n\n        for telegram_id in context.job.data.get(\"users\", []):\n            await send(result, telegram_id, context)\n\n        self._logger.debug(\"Finished scheduled execution\")\n</code></pre>"},{"location":"reference/kamihi/bot/#kamihi.bot.Bot","title":"Bot","text":"<pre><code>Bot()\n</code></pre> <p>Bot class for Kamihi.</p> <p>The framework already provides a bot instance, which can be accessed using the <code>bot</code> variable. This instance is already configured with default settings and can be used to start the bot. The managed instance is preferable to using the <code>Bot</code> class directly, as it ensures that the bot is properly configured and managed by the framework.</p> <p>Initialize the Bot class.</p> <p>Methods:</p> Name Description <code>action</code> <p>Register an action with the bot.</p> <code>start</code> <p>Start the bot.</p> Source code in <code>src/kamihi/bot/bot.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the Bot class.\"\"\"\n    # Loads the datasources\n    settings = get_settings()\n\n    for datasource_config in settings.datasources:\n        datasource_class = DataSource.get_datasource_class(datasource_config.type)\n        try:\n            self.datasources[datasource_config.name] = datasource_class(datasource_config)\n        except ImportError as e:\n            msg = (\n                f\"Failed to initialize data source '{datasource_config.name}' \"\n                f\"of type '{datasource_config.type}' because of missing dependencies.\"\n            )\n            raise ImportError(msg) from e\n\n        logger.trace(\"Initialized\", datasource=datasource_config.name, type=datasource_config.type)\n</code></pre>"},{"location":"reference/kamihi/bot/#kamihi.bot.Bot.action","title":"action","text":"<pre><code>action(\n    *commands: str, description: str = None\n) -&gt; partial[Action]\n</code></pre> <p>Register an action with the bot.</p> <p>This method overloads the <code>bot.action</code> method so the decorator can be used with or without parentheses.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>A list of command names. If not provided, the function name will be used.</p> <code>()</code> <code>str</code> <p>A description of the action. This will be used in the help message.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>partial[Action]</code> <p>The wrapped function.</p> Source code in <code>src/kamihi/bot/bot.py</code> <pre><code>@dispatch([str])\ndef action(self, *commands: str, description: str = None) -&gt; partial[Action]:\n    \"\"\"\n    Register an action with the bot.\n\n    This method overloads the `bot.action` method so the decorator can be used\n    with or without parentheses.\n\n    Args:\n        *commands: A list of command names. If not provided, the function name will be used.\n        description: A description of the action. This will be used in the help message.\n\n    Returns:\n        Callable: The wrapped function.\n\n    \"\"\"\n    return functools.partial(self.action, *commands, description=description)\n</code></pre>"},{"location":"reference/kamihi/bot/#kamihi.bot.Bot.action(*commands)","title":"<code>*commands</code>","text":""},{"location":"reference/kamihi/bot/#kamihi.bot.Bot.action(description)","title":"<code>description</code>","text":""},{"location":"reference/kamihi/bot/#kamihi.bot.Bot.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the bot.</p> Source code in <code>src/kamihi/bot/bot.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the bot.\"\"\"\n    # Cleans up the database of actions that are not present in code\n    Action.clean_up([action.name for action in self._actions])\n    logger.debug(\"Removed actions not present in code from database\")\n\n    # Warns the user if there are no valid actions registered\n    if not self._actions:\n        logger.warning(\"No valid actions were registered. The bot will not respond to any commands.\")\n\n    # Cleans up the database of old pages\n    Pages.clean_up(get_settings().db.pages_expiration_days)\n    logger.trace(\"Cleaned up old pages\")\n\n    # Loads the Telegram client\n    self._client = TelegramClient(self._post_init, self._post_shutdown)\n    self._client.add_datasources(self.datasources)\n    self._client.add_handlers(self._handlers)\n    self._load_jobs()\n    self._client.add_default_handlers()\n    self._client.add_pages_handler()\n    logger.trace(\"Initialized Telegram client\")\n\n    # Loads the web server\n    self._web = KamihiWeb(\n        {\n            \"after_create\": [self._set_scopes, self._load_jobs],\n            \"after_edit\": [self._set_scopes, self._load_jobs],\n            \"after_delete\": [self._set_scopes, self._load_jobs],\n            \"run_job\": [self._run_job],\n        },\n    )\n    logger.trace(\"Initialized web server\")\n    self._web.start()\n\n    # Runs the client\n    self._client.run()\n</code></pre>"},{"location":"reference/kamihi/bot/action/","title":"action","text":""},{"location":"reference/kamihi/bot/action/#kamihi.bot.action","title":"kamihi.bot.action","text":"<p>Action helper class.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>Action</code> <p>Action class for Kamihi bot.</p>"},{"location":"reference/kamihi/bot/action/#kamihi.bot.action.Action","title":"Action","text":"<pre><code>Action(\n    name: str,\n    commands: list[str],\n    description: str,\n    func: Callable,\n    datasources: dict[str, DataSource] = None,\n)\n</code></pre> <p>Action class for Kamihi bot.</p> <p>This class provides helpers for defining actions, their commands and their handlers.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the action.</p> <code>commands</code> <code>list[str]</code> <p>List of commands associated.</p> <code>description</code> <code>str</code> <p>Description of the action.</p> <p>Initialize the Action class.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name of the action.</p> required <code>list[str]</code> <p>List of commands associated.</p> required <code>str</code> <p>Description of the action.</p> required <code>Callable</code> <p>The function to be executed when the action is called.</p> required <code>dict[str, DataSource]</code> <p>Dictionary of data sources available for the action.</p> <code>None</code> <p>Methods:</p> Name Description <code>clean_up</code> <p>Clean up the action from the database.</p> <code>run_scheduled</code> <p>Execute the action in a job context.</p> Source code in <code>src/kamihi/bot/action.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    commands: list[str],\n    description: str,\n    func: Callable,\n    datasources: dict[str, DataSource] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the Action class.\n\n    Args:\n        name (str): The name of the action.\n        commands (list[str]): List of commands associated.\n        description (str): Description of the action.\n        func (Callable): The function to be executed when the action is called.\n        datasources (dict[str, DataSource]): Dictionary of data sources available for the action.\n\n    \"\"\"\n    self.name = name\n    self.commands = commands\n    self.description = description\n\n    self._func = func\n    self._logger = logger.bind(action=self.name)\n\n    self._datasources = datasources or {}\n\n    self._files = Environment(\n        loader=FileSystemLoader(self._folder_path),\n        autoescape=select_autoescape(default_for_string=False),\n    )\n\n    self._validate_commands()\n    self._validate_function()\n    self._validate_requests()\n\n    self._save_to_db()\n\n    self._logger.debug(\"Successfully registered\")\n</code></pre>"},{"location":"reference/kamihi/bot/action/#kamihi.bot.action.Action(name)","title":"<code>name</code>","text":""},{"location":"reference/kamihi/bot/action/#kamihi.bot.action.Action(commands)","title":"<code>commands</code>","text":""},{"location":"reference/kamihi/bot/action/#kamihi.bot.action.Action(description)","title":"<code>description</code>","text":""},{"location":"reference/kamihi/bot/action/#kamihi.bot.action.Action(func)","title":"<code>func</code>","text":""},{"location":"reference/kamihi/bot/action/#kamihi.bot.action.Action(datasources)","title":"<code>datasources</code>","text":""},{"location":"reference/kamihi/bot/action/#kamihi.bot.action.Action.handler","title":"handler  <code>property</code>","text":"<pre><code>handler: AuthHandler | ConversationHandler\n</code></pre> <p>Construct a CommandHandler for the action.</p>"},{"location":"reference/kamihi/bot/action/#kamihi.bot.action.Action.jobs","title":"jobs  <code>property</code>","text":"<pre><code>jobs: list[\n    tuple[\n        Job,\n        Callable[\n            [CallbackContext], Coroutine[Any, Any, None]\n        ],\n    ]\n]\n</code></pre> <p>Return a list of jobs associated with the action.</p>"},{"location":"reference/kamihi/bot/action/#kamihi.bot.action.Action.users","title":"users  <code>property</code>","text":"<pre><code>users: Sequence[BaseUser]\n</code></pre> <p>Return a list of telegram IDs of users authorized to use the action.</p>"},{"location":"reference/kamihi/bot/action/#kamihi.bot.action.Action.clean_up","title":"clean_up  <code>classmethod</code>","text":"<pre><code>clean_up(keep: list[str]) -&gt; None\n</code></pre> <p>Clean up the action from the database.</p> Source code in <code>src/kamihi/bot/action.py</code> <pre><code>@classmethod\ndef clean_up(cls, keep: list[str]) -&gt; None:\n    \"\"\"Clean up the action from the database.\"\"\"\n    with Session(get_engine()) as session:\n        statement = select(RegisteredAction).where(RegisteredAction.name.not_in(keep))\n        actions = session.execute(statement).scalars().all()\n        for action in actions:\n            session.delete(action)\n        session.commit()\n</code></pre>"},{"location":"reference/kamihi/bot/action/#kamihi.bot.action.Action.run_scheduled","title":"run_scheduled  <code>async</code>","text":"<pre><code>run_scheduled(context: CallbackContext) -&gt; None\n</code></pre> <p>Execute the action in a job context.</p> Source code in <code>src/kamihi/bot/action.py</code> <pre><code>async def run_scheduled(self, context: CallbackContext) -&gt; None:\n    \"\"\"Execute the action in a job context.\"\"\"\n    per_user = context.job.data.get(\"per_user\", False)\n\n    self._logger.debug(\"Executing scheduled action\", per_user=per_user)\n\n    if per_user:\n        for telegram_id in context.job.data.get(\"users\", []):\n            context.job.data[\"user\"] = telegram_id\n            pos_args, keyword_args = await self._fill_parameters(context)\n\n            result: Any = await self._func(*pos_args, **keyword_args)\n\n            await send(result, telegram_id, context)\n    else:\n        pos_args, keyword_args = await self._fill_parameters(context)\n\n        result: Any = await self._func(*pos_args, **keyword_args)\n\n        for telegram_id in context.job.data.get(\"users\", []):\n            await send(result, telegram_id, context)\n\n        self._logger.debug(\"Finished scheduled execution\")\n</code></pre>"},{"location":"reference/kamihi/bot/bot/","title":"bot","text":""},{"location":"reference/kamihi/bot/bot/#kamihi.bot.bot","title":"kamihi.bot.bot","text":"<p>Bot module for Kamihi.</p> <p>This module provides the primary interface for the Kamihi framework, allowing for the creation and management of Telegram bots.</p> <p>The framework already provides a bot instance, which can be accessed using the <code>bot</code> variable. This instance is already configured with default settings and can be used to start the bot. The managed instance is preferable to using the <code>Bot</code> class directly, as it ensures that the bot is properly configured and managed by the framework.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>Bot</code> <p>Bot class for Kamihi.</p>"},{"location":"reference/kamihi/bot/bot/#kamihi.bot.bot.Bot","title":"Bot","text":"<pre><code>Bot()\n</code></pre> <p>Bot class for Kamihi.</p> <p>The framework already provides a bot instance, which can be accessed using the <code>bot</code> variable. This instance is already configured with default settings and can be used to start the bot. The managed instance is preferable to using the <code>Bot</code> class directly, as it ensures that the bot is properly configured and managed by the framework.</p> <p>Initialize the Bot class.</p> <p>Methods:</p> Name Description <code>action</code> <p>Register an action with the bot.</p> <code>start</code> <p>Start the bot.</p> Source code in <code>src/kamihi/bot/bot.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the Bot class.\"\"\"\n    # Loads the datasources\n    settings = get_settings()\n\n    for datasource_config in settings.datasources:\n        datasource_class = DataSource.get_datasource_class(datasource_config.type)\n        try:\n            self.datasources[datasource_config.name] = datasource_class(datasource_config)\n        except ImportError as e:\n            msg = (\n                f\"Failed to initialize data source '{datasource_config.name}' \"\n                f\"of type '{datasource_config.type}' because of missing dependencies.\"\n            )\n            raise ImportError(msg) from e\n\n        logger.trace(\"Initialized\", datasource=datasource_config.name, type=datasource_config.type)\n</code></pre>"},{"location":"reference/kamihi/bot/bot/#kamihi.bot.bot.Bot.action","title":"action","text":"<pre><code>action(\n    *commands: str, description: str = None\n) -&gt; partial[Action]\n</code></pre> <p>Register an action with the bot.</p> <p>This method overloads the <code>bot.action</code> method so the decorator can be used with or without parentheses.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>A list of command names. If not provided, the function name will be used.</p> <code>()</code> <code>str</code> <p>A description of the action. This will be used in the help message.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>partial[Action]</code> <p>The wrapped function.</p> Source code in <code>src/kamihi/bot/bot.py</code> <pre><code>@dispatch([str])\ndef action(self, *commands: str, description: str = None) -&gt; partial[Action]:\n    \"\"\"\n    Register an action with the bot.\n\n    This method overloads the `bot.action` method so the decorator can be used\n    with or without parentheses.\n\n    Args:\n        *commands: A list of command names. If not provided, the function name will be used.\n        description: A description of the action. This will be used in the help message.\n\n    Returns:\n        Callable: The wrapped function.\n\n    \"\"\"\n    return functools.partial(self.action, *commands, description=description)\n</code></pre>"},{"location":"reference/kamihi/bot/bot/#kamihi.bot.bot.Bot.action(*commands)","title":"<code>*commands</code>","text":""},{"location":"reference/kamihi/bot/bot/#kamihi.bot.bot.Bot.action(description)","title":"<code>description</code>","text":""},{"location":"reference/kamihi/bot/bot/#kamihi.bot.bot.Bot.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the bot.</p> Source code in <code>src/kamihi/bot/bot.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the bot.\"\"\"\n    # Cleans up the database of actions that are not present in code\n    Action.clean_up([action.name for action in self._actions])\n    logger.debug(\"Removed actions not present in code from database\")\n\n    # Warns the user if there are no valid actions registered\n    if not self._actions:\n        logger.warning(\"No valid actions were registered. The bot will not respond to any commands.\")\n\n    # Cleans up the database of old pages\n    Pages.clean_up(get_settings().db.pages_expiration_days)\n    logger.trace(\"Cleaned up old pages\")\n\n    # Loads the Telegram client\n    self._client = TelegramClient(self._post_init, self._post_shutdown)\n    self._client.add_datasources(self.datasources)\n    self._client.add_handlers(self._handlers)\n    self._load_jobs()\n    self._client.add_default_handlers()\n    self._client.add_pages_handler()\n    logger.trace(\"Initialized Telegram client\")\n\n    # Loads the web server\n    self._web = KamihiWeb(\n        {\n            \"after_create\": [self._set_scopes, self._load_jobs],\n            \"after_edit\": [self._set_scopes, self._load_jobs],\n            \"after_delete\": [self._set_scopes, self._load_jobs],\n            \"run_job\": [self._run_job],\n        },\n    )\n    logger.trace(\"Initialized web server\")\n    self._web.start()\n\n    # Runs the client\n    self._client.run()\n</code></pre>"},{"location":"reference/kamihi/cli/","title":"cli","text":""},{"location":"reference/kamihi/cli/#kamihi.cli","title":"kamihi.cli","text":"<p>Command-line utility for the Kamihi framework.</p> License <p>MIT</p> <p>Modules:</p> Name Description <code>cli</code> <p>Main file of the CLI utility for the Kamihi framework.</p> <code>commands</code> <p>Commands for Kamihi CLI.</p> <code>utils</code> <p>Utility functions for the Kamihi CLI.</p>"},{"location":"reference/kamihi/cli/cli/","title":"cli","text":""},{"location":"reference/kamihi/cli/cli/#kamihi.cli.cli","title":"kamihi.cli.cli","text":"<p>Main file of the CLI utility for the Kamihi framework.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>Context</code> <p>Context for the Kamihi CLI utility.</p> <p>Functions:</p> Name Description <code>main</code> <p>Kamihi CLI utility.</p>"},{"location":"reference/kamihi/cli/cli/#kamihi.cli.cli.Context","title":"Context","text":"<pre><code>Context()\n</code></pre> <p>Context for the Kamihi CLI utility.</p> <p>This class holds the context data for the CLI commands.</p> <p>Initialize the context with default values.</p> Source code in <code>src/kamihi/cli/cli.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the context with default values.\"\"\"\n    self.cwd: Path = Path.cwd()\n    self.templates: Path = Path(__file__).parent / \"templates\"\n    self.project: Path = self.cwd\n    self.config: Path = self.project / \"kamihi.yaml\"\n</code></pre>"},{"location":"reference/kamihi/cli/cli/#kamihi.cli.cli.main","title":"main","text":"<pre><code>main(\n    ctx: Context,\n    settings_path: Annotated[\n        Path | None,\n        Option(\n            ...,\n            help=\"Path to the Kamihi settings file\",\n            exists=True,\n            file_okay=True,\n            dir_okay=False,\n            readable=True,\n            show_default=yaml,\n        ),\n    ] = None,\n) -&gt; None\n</code></pre> <p>Kamihi CLI utility.</p> <p>This utility provides commands to manage and interact with the Kamihi framework.</p> Source code in <code>src/kamihi/cli/cli.py</code> <pre><code>@app.callback()\ndef main(\n    ctx: typer.Context,\n    settings_path: Annotated[\n        Path | None,\n        typer.Option(\n            ...,\n            help=\"Path to the Kamihi settings file\",\n            exists=True,\n            file_okay=True,\n            dir_okay=False,\n            readable=True,\n            show_default=\"kamihi.yaml\",\n        ),\n    ] = None,\n) -&gt; None:\n    \"\"\"\n    Kamihi CLI utility.\n\n    This utility provides commands to manage and interact with the Kamihi framework.\n    \"\"\"\n    ctx.obj = Context()\n\n    if ctx.invoked_subcommand not in [\"init\", \"version\"]:\n        from kamihi.base import init_settings\n\n        init_settings(settings_path)\n\n        from kamihi.base import configure_logging\n\n        configure_logging(logger)\n        logger.bind(settings_file=str(settings_path)).debug(\"Configured logging and loaded settings\")\n\n    if ctx.invoked_subcommand in [\"permission\", \"role\", \"run\", \"user\"]:\n        from kamihi.cli.utils import import_models\n        from kamihi.db import init_engine\n\n        import_models(ctx.obj.cwd / \"models\")\n        logger.bind(folder=str(ctx.obj.cwd / \"models\")).debug(\"Imported models\")\n\n        init_engine()\n        logger.debug(\"Initialized database engine\")\n</code></pre>"},{"location":"reference/kamihi/cli/commands/","title":"commands","text":""},{"location":"reference/kamihi/cli/commands/#kamihi.cli.commands","title":"kamihi.cli.commands","text":"<p>Commands for Kamihi CLI.</p> License <p>MIT</p> <p>Modules:</p> Name Description <code>action</code> <p>Action-related commands for the Kamihi CLI.</p> <code>db</code> <p>Database management module for Kamihi CLI.</p> <code>init</code> <p>Initialization of projects with Kamihi.</p> <code>permission</code> <p>Permissions management module for Kamihi CLI.</p> <code>role</code> <p>Role management commands for Kamihi CLI.</p> <code>run</code> <p>Kamihi framework project execution.</p> <code>user</code> <p>User management module for Kamihi CLI.</p> <code>version</code> <p>Version command for the Kamihi CLI.</p>"},{"location":"reference/kamihi/cli/commands/action/","title":"action","text":""},{"location":"reference/kamihi/cli/commands/action/#kamihi.cli.commands.action","title":"kamihi.cli.commands.action","text":"<p>Action-related commands for the Kamihi CLI.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>new</code> <p>Create a new action.</p>"},{"location":"reference/kamihi/cli/commands/action/#kamihi.cli.commands.action.new","title":"new","text":"<pre><code>new(\n    ctx: Context,\n    name: str = typer.Argument(\n        ..., help=\"Name of the new action.\"\n    ),\n    description: str = typer.Option(\n        \"\", help=\"Description of the new action.\"\n    ),\n) -&gt; None\n</code></pre> <p>Create a new action.</p> Source code in <code>src/kamihi/cli/commands/action.py</code> <pre><code>@app.command()\ndef new(\n    ctx: typer.Context,\n    name: str = typer.Argument(..., help=\"Name of the new action.\"),\n    description: str = typer.Option(\"\", help=\"Description of the new action.\"),\n) -&gt; None:\n    \"\"\"Create a new action.\"\"\"\n    run_copy(\n        \"gh:kamihi-org/kamihi-action-template\",\n        str(ctx.obj.project),\n        data={\n            \"action_name\": name,\n            \"action_description\": description,\n        },\n    )\n</code></pre>"},{"location":"reference/kamihi/cli/commands/db/","title":"db","text":""},{"location":"reference/kamihi/cli/commands/db/#kamihi.cli.commands.db","title":"kamihi.cli.commands.db","text":"<p>Database management module for Kamihi CLI.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>downgrade</code> <p>Downgrade the database to an earlier version.</p> <code>main</code> <p>Database management commands for Kamihi CLI.</p> <code>migrate</code> <p>Run database migrations.</p> <code>revision_callback</code> <p>Ensure the revision value is valid.</p> <code>upgrade</code> <p>Upgrade the database to a later version.</p>"},{"location":"reference/kamihi/cli/commands/db/#kamihi.cli.commands.db.downgrade","title":"downgrade","text":"<pre><code>downgrade(\n    ctx: Context,\n    revision: Annotated[\n        str,\n        Option(\n            --revision,\n            -r,\n            help=\"The revision to downgrade to.\",\n            show_default=-1,\n            callback=revision_callback,\n        ),\n    ] = \"-1\",\n) -&gt; None\n</code></pre> <p>Downgrade the database to an earlier version.</p> Source code in <code>src/kamihi/cli/commands/db.py</code> <pre><code>@app.command(\"downgrade\")\ndef downgrade(\n    ctx: typer.Context,\n    revision: Annotated[\n        str,\n        typer.Option(\n            \"--revision\", \"-r\", help=\"The revision to downgrade to.\", show_default=\"-1\", callback=revision_callback\n        ),\n    ] = \"-1\",\n) -&gt; None:\n    \"\"\"Downgrade the database to an earlier version.\"\"\"\n    command.downgrade(ctx.obj.alembic_cfg, revision)\n    logger.bind(revision=revision).success(\"Downgraded\")\n</code></pre>"},{"location":"reference/kamihi/cli/commands/db/#kamihi.cli.commands.db.main","title":"main","text":"<pre><code>main(ctx: Context) -&gt; None\n</code></pre> <p>Database management commands for Kamihi CLI.</p> Source code in <code>src/kamihi/cli/commands/db.py</code> <pre><code>@app.callback()\ndef main(ctx: typer.Context) -&gt; None:\n    \"\"\"Database management commands for Kamihi CLI.\"\"\"\n    settings = get_settings()\n\n    import_models(ctx.obj.cwd / \"models\")\n\n    ctx.obj.alembic_cfg = Config(toml_file=ctx.obj.cwd / \"pyproject.toml\")\n    ctx.obj.alembic_cfg.set_main_option(\"sqlalchemy.url\", settings.db.url)\n\n    if not (ctx.obj.cwd / \"migrations\").exists():\n        logger.error(\"No migrations directory found. Please run 'kamihi init' first.\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/kamihi/cli/commands/db/#kamihi.cli.commands.db.migrate","title":"migrate","text":"<pre><code>migrate(ctx: Context) -&gt; None\n</code></pre> <p>Run database migrations.</p> Source code in <code>src/kamihi/cli/commands/db.py</code> <pre><code>@app.command(\"migrate\")\ndef migrate(ctx: typer.Context) -&gt; None:\n    \"\"\"Run database migrations.\"\"\"\n    with contextlib.redirect_stdout(StreamToLogger(logger, \"DEBUG\")):\n        res = command.revision(ctx.obj.alembic_cfg, autogenerate=True, message=\"auto migration\")\n    logger.bind(revision=res.revision).success(\"Migrated\")\n</code></pre>"},{"location":"reference/kamihi/cli/commands/db/#kamihi.cli.commands.db.revision_callback","title":"revision_callback","text":"<pre><code>revision_callback(ctx: Context, value: str) -&gt; str\n</code></pre> <p>Ensure the revision value is valid.</p> <p>Parameters:</p> Name Type Description Default <code>Context</code> <p>The Typer context.</p> required <code>str</code> <p>The revision value.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The validated revision value.</p> Source code in <code>src/kamihi/cli/commands/db.py</code> <pre><code>def revision_callback(ctx: typer.Context, value: str) -&gt; str:\n    \"\"\"\n    Ensure the revision value is valid.\n\n    Args:\n        ctx (typer.Context): The Typer context.\n        value (str): The revision value.\n\n    Returns:\n        str: The validated revision value.\n\n    \"\"\"\n    if not value or not isinstance(value, str):\n        raise typer.BadParameter(\"Invalid revision value\")\n    script = ScriptDirectory.from_config(ctx.obj.alembic_cfg)\n    value = script.as_revision_number(value)\n    if value is None:\n        raise typer.BadParameter(\"Revision not found\")\n    return value\n</code></pre>"},{"location":"reference/kamihi/cli/commands/db/#kamihi.cli.commands.db.revision_callback(ctx)","title":"<code>ctx</code>","text":""},{"location":"reference/kamihi/cli/commands/db/#kamihi.cli.commands.db.revision_callback(value)","title":"<code>value</code>","text":""},{"location":"reference/kamihi/cli/commands/db/#kamihi.cli.commands.db.upgrade","title":"upgrade","text":"<pre><code>upgrade(\n    ctx: Context,\n    revision: Annotated[\n        str,\n        Option(\n            --revision,\n            -r,\n            help=\"The revision to upgrade to.\",\n            show_default=head,\n            callback=revision_callback,\n        ),\n    ] = \"head\",\n) -&gt; None\n</code></pre> <p>Upgrade the database to a later version.</p> Source code in <code>src/kamihi/cli/commands/db.py</code> <pre><code>@app.command(\"upgrade\")\ndef upgrade(\n    ctx: typer.Context,\n    revision: Annotated[\n        str,\n        typer.Option(\n            \"--revision\", \"-r\", help=\"The revision to upgrade to.\", show_default=\"head\", callback=revision_callback\n        ),\n    ] = \"head\",\n) -&gt; None:\n    \"\"\"Upgrade the database to a later version.\"\"\"\n    command.upgrade(ctx.obj.alembic_cfg, revision)\n    logger.bind(revision=revision).success(\"Upgraded\")\n</code></pre>"},{"location":"reference/kamihi/cli/commands/init/","title":"init","text":""},{"location":"reference/kamihi/cli/commands/init/#kamihi.cli.commands.init","title":"kamihi.cli.commands.init","text":"<p>Initialization of projects with Kamihi.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>init</code> <p>Initialize a new Kamihi project.</p>"},{"location":"reference/kamihi/cli/commands/init/#kamihi.cli.commands.init.init","title":"init","text":"<pre><code>init(\n    ctx: Context,\n    name: str = typer.Argument(\n        ..., help=\"Name of the project.\"\n    ),\n    path: Annotated[\n        Path | None,\n        Option(\n            exists=True,\n            file_okay=False,\n            dir_okay=True,\n            writable=True,\n            resolve_path=True,\n            help=\"Path to the project directory.\",\n        ),\n    ] = None,\n    description: str = typer.Option(\n        \"Kamihi project\", help=\"Description of the project.\"\n    ),\n) -&gt; None\n</code></pre> <p>Initialize a new Kamihi project.</p> Source code in <code>src/kamihi/cli/commands/init.py</code> <pre><code>@app.command()\ndef init(\n    ctx: typer.Context,\n    name: str = typer.Argument(..., help=\"Name of the project.\"),\n    path: Annotated[\n        Path | None,\n        typer.Option(\n            exists=True,\n            file_okay=False,\n            dir_okay=True,\n            writable=True,\n            resolve_path=True,\n            help=\"Path to the project directory.\",\n        ),\n    ] = None,\n    description: str = typer.Option(\n        \"Kamihi project\",\n        help=\"Description of the project.\",\n    ),\n) -&gt; None:\n    \"\"\"Initialize a new Kamihi project.\"\"\"\n    run_copy(\n        \"gh:kamihi-org/kamihi-project-template\",\n        str((path or ctx.obj.project) / name),\n        data={\n            \"project_name\": name,\n            \"project_description\": description,\n            \"kamihi_version\": kamihi_version,\n        },\n    )\n</code></pre>"},{"location":"reference/kamihi/cli/commands/permission/","title":"permission","text":""},{"location":"reference/kamihi/cli/commands/permission/#kamihi.cli.commands.permission","title":"kamihi.cli.commands.permission","text":"<p>Permissions management module for Kamihi CLI.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>add</code> <p>Add a new permission for an action to specified users and/or roles.</p>"},{"location":"reference/kamihi/cli/commands/permission/#kamihi.cli.commands.permission.add","title":"add","text":"<pre><code>add(\n    action: Annotated[\n        str,\n        Argument(\n            ...,\n            help=\"Name of the action to assign permission for (without the leading slash).\",\n        ),\n    ],\n    users: Annotated[\n        list[int],\n        Option(\n            ...,\n            --user,\n            -u,\n            help=\"Telegram ID of the user(s) to assign the permission to. Can be used multiple times.\",\n            callback=telegram_id_callback,\n        ),\n    ] = None,\n    roles: Annotated[\n        list[str],\n        Option(\n            ...,\n            --role,\n            -r,\n            help=\"Role name(s) to assign the permission to. Can be used multiple times.\",\n        ),\n    ] = None,\n) -&gt; None\n</code></pre> <p>Add a new permission for an action to specified users and/or roles.</p> Source code in <code>src/kamihi/cli/commands/permission.py</code> <pre><code>@app.command()\ndef add(\n    action: Annotated[\n        str,\n        typer.Argument(..., help=\"Name of the action to assign permission for (without the leading slash).\"),\n    ],\n    users: Annotated[\n        list[int],\n        typer.Option(\n            ...,\n            \"--user\",\n            \"-u\",\n            help=\"Telegram ID of the user(s) to assign the permission to. Can be used multiple times.\",\n            callback=telegram_id_callback,\n        ),\n    ] = None,\n    roles: Annotated[\n        list[str],\n        typer.Option(\n            ...,\n            \"--role\",\n            \"-r\",\n            help=\"Role name(s) to assign the permission to. Can be used multiple times.\",\n        ),\n    ] = None,\n) -&gt; None:\n    \"\"\"Add a new permission for an action to specified users and/or roles.\"\"\"\n    if not users and not roles:\n        logger.error(\"At least one user or role must be specified to assign the permission to\")\n        raise typer.Exit(1)\n\n    with Session(get_engine()) as session:\n        action_obj = session.execute(select(RegisteredAction).where(RegisteredAction.name == action)).scalars().first()\n        if not action_obj:\n            logger.bind(name=action).error(\"Action not found\")\n            raise typer.Exit(1)\n\n        users_objs = []\n        if users:\n            for user_id in users:\n                user = (\n                    session.execute(select(BaseUser.cls()).where(BaseUser.cls().telegram_id == user_id))\n                    .scalars()\n                    .first()\n                )\n                if not user:\n                    logger.bind(telegram_id=user_id).error(\"User not found\")\n                    raise typer.Exit(1)\n                users_objs.append(user)\n\n        roles_objs = []\n        if roles:\n            for role_name in roles:\n                role = session.execute(select(Role).where(Role.name == role_name)).scalars().first()\n                if not role:\n                    logger.bind(name=role_name).error(\"Role not found\")\n                    raise typer.Exit(1)\n                roles_objs.append(role)\n\n        permission = Permission(action=action_obj, users=users_objs, roles=roles_objs)\n        session.add(permission)\n        session.commit()\n        logger.bind(\n            action=action,\n            users=[user.telegram_id for user in users_objs],\n            roles=[role.name for role in roles_objs],\n        ).success(\"Permission added\")\n</code></pre>"},{"location":"reference/kamihi/cli/commands/role/","title":"role","text":""},{"location":"reference/kamihi/cli/commands/role/#kamihi.cli.commands.role","title":"kamihi.cli.commands.role","text":"<p>Role management commands for Kamihi CLI.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>add</code> <p>Add a new role and optionally assign it to specified users.</p> <code>assign</code> <p>Assign an existing role to specified users.</p>"},{"location":"reference/kamihi/cli/commands/role/#kamihi.cli.commands.role.add","title":"add","text":"<pre><code>add(\n    name: Annotated[\n        str, Argument(..., help=\"Name of the role to add.\")\n    ],\n) -&gt; None\n</code></pre> <p>Add a new role and optionally assign it to specified users.</p> Source code in <code>src/kamihi/cli/commands/role.py</code> <pre><code>@app.command()\ndef add(\n    name: Annotated[str, typer.Argument(..., help=\"Name of the role to add.\")],\n) -&gt; None:\n    \"\"\"Add a new role and optionally assign it to specified users.\"\"\"\n    lg = logger.bind(name=name)\n\n    with Session(get_engine()) as session:\n        role = session.execute(select(Role).where(Role.name == name)).scalar_one_or_none()\n        if role:\n            lg.error(\"Role already exists\")\n            raise typer.Exit(1)\n\n        role = Role(name=name)\n        session.add(role)\n        session.commit()\n        lg.success(\"Role added\")\n</code></pre>"},{"location":"reference/kamihi/cli/commands/role/#kamihi.cli.commands.role.assign","title":"assign","text":"<pre><code>assign(\n    role: Annotated[\n        str,\n        Argument(\n            ..., help=\"Name of the role to assign to users.\"\n        ),\n    ],\n    users: Annotated[\n        list[int],\n        Argument(\n            ...,\n            help=\"Telegram ID of the user(s) to assign the role to.\",\n            callback=telegram_id_callback,\n        ),\n    ],\n) -&gt; None\n</code></pre> <p>Assign an existing role to specified users.</p> Source code in <code>src/kamihi/cli/commands/role.py</code> <pre><code>@app.command()\ndef assign(\n    role: Annotated[str, typer.Argument(..., help=\"Name of the role to assign to users.\")],\n    users: Annotated[\n        list[int],\n        typer.Argument(..., help=\"Telegram ID of the user(s) to assign the role to.\", callback=telegram_id_callback),\n    ],\n) -&gt; None:\n    \"\"\"Assign an existing role to specified users.\"\"\"\n    lg = logger.bind(role=role)\n\n    with Session(get_engine()) as session:\n        role_obj = session.execute(select(Role).where(Role.name == role)).scalar_one_or_none()\n        if not role_obj:\n            lg.error(\"Role does not exist\")\n            raise typer.Exit(1)\n\n        assigned_users = []\n        for telegram_id in users:\n            lg2 = lg.bind(telegram_id=telegram_id)\n            user = session.execute(\n                select(BaseUser.cls()).where(BaseUser.cls().telegram_id == telegram_id)\n            ).scalar_one_or_none()\n            if not user:\n                lg2.warning(\"User not found, skipping...\")\n                continue\n\n            if role_obj in user.roles:\n                lg2.warning(\"User already has role, skipping...\")\n                continue\n\n            user.roles.append(role_obj)\n            assigned_users.append(telegram_id)\n            lg2.debug(\"Role assigned to user\")\n\n        session.commit()\n        lg.success(\"Role assigned to users\", users=assigned_users)\n</code></pre>"},{"location":"reference/kamihi/cli/commands/run/","title":"run","text":""},{"location":"reference/kamihi/cli/commands/run/#kamihi.cli.commands.run","title":"kamihi.cli.commands.run","text":"<p>Kamihi framework project execution.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>host_callback</code> <p>Ensure the host value is valid.</p> <code>run</code> <p>Run a project with the Kamihi framework.</p>"},{"location":"reference/kamihi/cli/commands/run/#kamihi.cli.commands.run.host_callback","title":"host_callback","text":"<pre><code>host_callback(value: str | None) -&gt; str | None\n</code></pre> <p>Ensure the host value is valid.</p> <p>Parameters:</p> Name Type Description Default <code>str | None</code> <p>The host value.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The validated host value.</p> Source code in <code>src/kamihi/cli/commands/run.py</code> <pre><code>def host_callback(\n    value: str | None,\n) -&gt; str | None:\n    \"\"\"\n    Ensure the host value is valid.\n\n    Args:\n        value (str | None): The host value.\n\n    Returns:\n        str | None: The validated host value.\n\n    \"\"\"\n    if value and isinstance(hostname(value, may_have_port=False), ValidationError):\n        raise typer.BadParameter(\"Invalid host value\")\n    return value\n</code></pre>"},{"location":"reference/kamihi/cli/commands/run/#kamihi.cli.commands.run.host_callback(value)","title":"<code>value</code>","text":""},{"location":"reference/kamihi/cli/commands/run/#kamihi.cli.commands.run.run","title":"run","text":"<pre><code>run(\n    ctx: Context,\n    log_level: Annotated[\n        LogLevel | None,\n        Option(\n            --log - level,\n            -l,\n            help=\"Set the logging level for console loggers.\",\n            show_default=INFO,\n        ),\n    ] = None,\n    web_host: Annotated[\n        str | None,\n        Option(\n            ...,\n            --host,\n            -h,\n            help=\"Host of the admin web panel\",\n            callback=host_callback,\n            show_default=localhost,\n        ),\n    ] = None,\n    web_port: Annotated[\n        int | None,\n        Option(\n            ...,\n            --port,\n            -p,\n            help=\"Port of the admin web panel\",\n            min=1024,\n            max=65535,\n            show_default=4242,\n        ),\n    ] = None,\n) -&gt; None\n</code></pre> <p>Run a project with the Kamihi framework.</p> Source code in <code>src/kamihi/cli/commands/run.py</code> <pre><code>@app.command()\ndef run(\n    ctx: typer.Context,\n    log_level: Annotated[\n        LogLevel | None,\n        typer.Option(\n            \"--log-level\", \"-l\", help=\"Set the logging level for console loggers.\", show_default=LogLevel.INFO\n        ),\n    ] = None,\n    web_host: Annotated[\n        str | None,\n        typer.Option(\n            ..., \"--host\", \"-h\", help=\"Host of the admin web panel\", callback=host_callback, show_default=\"localhost\"\n        ),\n    ] = None,\n    web_port: Annotated[\n        int | None,\n        typer.Option(..., \"--port\", \"-p\", help=\"Port of the admin web panel\", min=1024, max=65535, show_default=\"4242\"),\n    ] = None,\n) -&gt; None:\n    \"\"\"Run a project with the Kamihi framework.\"\"\"\n    settings = get_settings()\n    if web_host:\n        settings.web.host = web_host\n    if web_port:\n        settings.web.port = web_port\n    if log_level:\n        settings.log.stdout_level = log_level\n        settings.log.stderr_level = log_level\n        settings.log.file_level = log_level\n        settings.log.notification_level = log_level\n\n    # Ignore the \"If 'per_message=False', ...\" warning for CallbackQueryHandler\n    # https://github.com/python-telegram-bot/python-telegram-bot/wiki/Frequently-Asked-Questions#what-do-the-per_-settings-in-conversationhandler-do\n    filterwarnings(action=\"ignore\", message=r\".*CallbackQueryHandler\", category=PTBUserWarning)\n\n    bot = init_bot()\n\n    import_questions(ctx.obj.cwd / \"questions\")\n    import_actions(ctx.obj.cwd / \"actions\")\n    logger.bind(folder=str(ctx.obj.cwd / \"actions\")).debug(\"Imported actions\")\n\n    bot.start()\n</code></pre>"},{"location":"reference/kamihi/cli/commands/user/","title":"user","text":""},{"location":"reference/kamihi/cli/commands/user/#kamihi.cli.commands.user","title":"kamihi.cli.commands.user","text":"<p>User management module for Kamihi CLI.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>add</code> <p>Add a new user.</p> <code>data_callback</code> <p>Parse a JSON string into a dictionary.</p> <code>onerror</code> <p>Handle errors during user validation.</p>"},{"location":"reference/kamihi/cli/commands/user/#kamihi.cli.commands.user.add","title":"add","text":"<pre><code>add(\n    telegram_id: Annotated[\n        int,\n        Argument(\n            ...,\n            help=\"Telegram ID of the user\",\n            callback=telegram_id_callback,\n        ),\n    ],\n    is_admin: Annotated[\n        bool,\n        Option(--admin, -a, help=\"Is the user an admin?\"),\n    ] = False,\n    data: Annotated[\n        str | None,\n        Option(\n            --data,\n            -d,\n            help=\"Additional data for the user in JSON format. For use with custom user classes.\",\n            show_default=False,\n            callback=data_callback,\n        ),\n    ] = None,\n) -&gt; None\n</code></pre> <p>Add a new user.</p> Source code in <code>src/kamihi/cli/commands/user.py</code> <pre><code>@app.command()\ndef add(\n    telegram_id: Annotated[int, typer.Argument(..., help=\"Telegram ID of the user\", callback=telegram_id_callback)],\n    is_admin: Annotated[bool, typer.Option(\"--admin\", \"-a\", help=\"Is the user an admin?\")] = False,  # noqa: FBT002\n    data: Annotated[\n        str | None,\n        typer.Option(\n            \"--data\",\n            \"-d\",\n            help=\"Additional data for the user in JSON format. For use with custom user classes.\",\n            show_default=False,\n            callback=data_callback,\n        ),\n    ] = None,\n) -&gt; None:\n    \"\"\"Add a new user.\"\"\"\n    user_data = data or {}\n    user_data[\"telegram_id\"] = telegram_id\n    user_data[\"is_admin\"] = is_admin\n\n    lg = logger.bind(**user_data)\n\n    with lg.catch(Exception, message=\"User inputted is not valid\", onerror=onerror), Session(get_engine()) as session:\n        statement = select(BaseUser.cls()).where(BaseUser.cls().telegram_id == telegram_id)\n        existing_user = session.execute(statement).scalars().first()\n        if existing_user:\n            lg.error(\"User already exists\")\n            raise typer.Exit(1)\n        user = BaseUser.cls()(**user_data)\n        session.add(user)\n        session.commit()\n\n    lg.success(\"User added\")\n</code></pre>"},{"location":"reference/kamihi/cli/commands/user/#kamihi.cli.commands.user.data_callback","title":"data_callback","text":"<pre><code>data_callback(data: str) -&gt; dict\n</code></pre> <p>Parse a JSON string into a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The JSON string to parse.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The parsed JSON data.</p> <p>Raises:</p> Type Description <code>BadParameter</code> <p>If the JSON string is invalid.</p> Source code in <code>src/kamihi/cli/commands/user.py</code> <pre><code>def data_callback(data: str) -&gt; dict:\n    \"\"\"\n    Parse a JSON string into a dictionary.\n\n    Args:\n        data (str): The JSON string to parse.\n\n    Returns:\n        dict: The parsed JSON data.\n\n    Raises:\n        typer.BadParameter: If the JSON string is invalid.\n\n    \"\"\"\n    if data:\n        try:\n            return json.loads(data)\n        except json.JSONDecodeError as e:\n            msg = f\"Invalid JSON data: {e}\"\n            raise typer.BadParameter(msg) from e\n    return {}\n</code></pre>"},{"location":"reference/kamihi/cli/commands/user/#kamihi.cli.commands.user.data_callback(data)","title":"<code>data</code>","text":""},{"location":"reference/kamihi/cli/commands/user/#kamihi.cli.commands.user.onerror","title":"onerror","text":"<pre><code>onerror(e: BaseException) -&gt; None\n</code></pre> <p>Handle errors during user validation.</p> <p>Parameters:</p> Name Type Description Default <code>Exception</code> <p>The exception raised during validation.</p> required Source code in <code>src/kamihi/cli/commands/user.py</code> <pre><code>def onerror(e: BaseException) -&gt; None:  # noqa: ARG001\n    \"\"\"\n    Handle errors during user validation.\n\n    Args:\n        e (Exception): The exception raised during validation.\n\n    \"\"\"\n    raise typer.Exit(1)\n</code></pre>"},{"location":"reference/kamihi/cli/commands/user/#kamihi.cli.commands.user.onerror(e)","title":"<code>e</code>","text":""},{"location":"reference/kamihi/cli/commands/version/","title":"version","text":""},{"location":"reference/kamihi/cli/commands/version/#kamihi.cli.commands.version","title":"kamihi.cli.commands.version","text":"<p>Version command for the Kamihi CLI.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>version</code> <p>Print the version and exit.</p>"},{"location":"reference/kamihi/cli/commands/version/#kamihi.cli.commands.version.version","title":"version","text":"<pre><code>version() -&gt; None\n</code></pre> <p>Print the version and exit.</p> Source code in <code>src/kamihi/cli/commands/version.py</code> <pre><code>@app.command()\ndef version() -&gt; None:\n    \"\"\"Print the version and exit.\"\"\"\n    from kamihi import __version__\n\n    print(__version__)  # noqa: T201\n</code></pre>"},{"location":"reference/kamihi/cli/utils/","title":"utils","text":""},{"location":"reference/kamihi/cli/utils/#kamihi.cli.utils","title":"kamihi.cli.utils","text":"<p>Utility functions for the Kamihi CLI.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>import_actions</code> <p>Import all Python files from a specified directory.</p> <code>import_file</code> <p>Import a Python file from a specified path.</p> <code>import_models</code> <p>Import all Python files from a specified directory.</p> <code>import_questions</code> <p>Import the questions module from a specified directory with an init.py file.</p> <code>telegram_id_callback</code> <p>Validate the Telegram ID.</p>"},{"location":"reference/kamihi/cli/utils/#kamihi.cli.utils.import_actions","title":"import_actions","text":"<pre><code>import_actions(actions_dir: Path) -&gt; None\n</code></pre> <p>Import all Python files from a specified directory.</p> Source code in <code>src/kamihi/cli/utils.py</code> <pre><code>def import_actions(actions_dir: Path) -&gt; None:\n    \"\"\"Import all Python files from a specified directory.\"\"\"\n    lg = logger.bind(actions_folder=str(actions_dir))\n    if not actions_dir.is_dir():\n        lg.warning(\"No actions directory found.\")\n        return\n\n    _ensure_namespace(\"kamihi.actions\", actions_dir, \"actions\")\n\n    lg.trace(\"Scanning for actions\")\n\n    for action_dir in actions_dir.iterdir():\n        action_dir: Path\n        action_name = action_dir.name\n        lg = logger.bind(action=action_name, folder=str(actions_dir))\n\n        if action_dir.is_dir() and action_dir.name != \"__pycache__\" and (action_dir / \"__init__.py\").exists():\n            action_file = action_dir / f\"{action_name}.py\"\n            lg = lg.bind(file=str(action_file))\n\n            if action_file.exists() and action_file.is_file():\n                lg.debug(\"Importing action\")\n                import_file(action_file, f\"kamihi.actions.{action_name}\")\n\n                sys.modules.setdefault(f\"actions.{action_name}\", sys.modules[f\"kamihi.actions.{action_name}\"])\n            else:\n                lg.error(\"Action directory found, but no '.py' file exists.\")\n        elif action_dir.is_dir():\n            lg.error(\"Action directory found, but no '__init__.py' file exists.\")\n</code></pre>"},{"location":"reference/kamihi/cli/utils/#kamihi.cli.utils.import_file","title":"import_file","text":"<pre><code>import_file(path: Path, name: str) -&gt; None\n</code></pre> <p>Import a Python file from a specified path.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The path to the Python file.</p> required <code>str</code> <p>The name of the module.</p> required Source code in <code>src/kamihi/cli/utils.py</code> <pre><code>def import_file(path: Path, name: str) -&gt; None:\n    \"\"\"\n    Import a Python file from a specified path.\n\n    Args:\n        path (str): The path to the Python file.\n        name (str): The name of the module.\n\n    \"\"\"\n    spec = importlib.util.spec_from_file_location(name, str(path))\n    if spec is None:\n        logger.error(f\"Could not find spec for {name}\")\n        return\n\n    module = importlib.util.module_from_spec(spec)\n\n    sys.modules[name] = module\n\n    with logger.catch(message=\"Error importing file\"):\n        spec.loader.exec_module(module)\n</code></pre>"},{"location":"reference/kamihi/cli/utils/#kamihi.cli.utils.import_file(path)","title":"<code>path</code>","text":""},{"location":"reference/kamihi/cli/utils/#kamihi.cli.utils.import_file(name)","title":"<code>name</code>","text":""},{"location":"reference/kamihi/cli/utils/#kamihi.cli.utils.import_models","title":"import_models","text":"<pre><code>import_models(models_dir: Path) -&gt; None\n</code></pre> <p>Import all Python files from a specified directory.</p> Source code in <code>src/kamihi/cli/utils.py</code> <pre><code>def import_models(models_dir: Path) -&gt; None:\n    \"\"\"Import all Python files from a specified directory.\"\"\"\n    lg = logger.bind(folder=str(models_dir))\n    if not models_dir.is_dir():\n        lg.debug(\"No models directory found.\")\n        return\n\n    _ensure_namespace(\"kamihi.models\", models_dir, \"models\")\n\n    lg.trace(\"Scanning for models\")\n\n    for model_file in models_dir.iterdir():\n        model_file: Path\n        model_name = model_file.stem\n        lg = lg.bind(model=model_name)\n\n        if model_file.is_file() and model_file.suffix == \".py\":\n            lg.bind(file=str(model_file)).trace(\"Importing model\")\n            import_file(model_file, f\"kamihi.models.{model_name}\")\n\n            sys.modules.setdefault(f\"models.{model_name}\", sys.modules[f\"kamihi.models.{model_name}\"])\n</code></pre>"},{"location":"reference/kamihi/cli/utils/#kamihi.cli.utils.import_questions","title":"import_questions","text":"<pre><code>import_questions(questions_dir: Path) -&gt; None\n</code></pre> <p>Import the questions module from a specified directory with an init.py file.</p> Source code in <code>src/kamihi/cli/utils.py</code> <pre><code>def import_questions(questions_dir: Path) -&gt; None:\n    \"\"\"Import the questions module from a specified directory with an __init__.py file.\"\"\"\n    lg = logger.bind(folder=str(questions_dir))\n    if not questions_dir.is_dir():\n        lg.debug(\"No questions directory found.\")\n        return\n\n    _ensure_namespace(\"kamihi.questions\", questions_dir, \"questions\")\n\n    init_file = questions_dir / \"__init__.py\"\n    if init_file.exists() and init_file.is_file():\n        lg.trace(\"Importing questions\")\n        import_file(init_file, \"questions\")\n    else:\n        lg.error(\"Questions directory found, but no '__init__.py' file exists.\")\n</code></pre>"},{"location":"reference/kamihi/cli/utils/#kamihi.cli.utils.telegram_id_callback","title":"telegram_id_callback","text":"<pre><code>telegram_id_callback(\n    value: int | list[int],\n) -&gt; int | list[int] | None\n</code></pre> <p>Validate the Telegram ID.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The Telegram ID to validate.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int | list[int] | None</code> <p>The validated Telegram ID.</p> <p>Raises:</p> Type Description <code>BadParameter</code> <p>If the Telegram ID is invalid.</p> Source code in <code>src/kamihi/cli/utils.py</code> <pre><code>def telegram_id_callback(value: int | list[int]) -&gt; int | list[int] | None:\n    \"\"\"\n    Validate the Telegram ID.\n\n    Args:\n        value (int): The Telegram ID to validate.\n\n    Returns:\n        int: The validated Telegram ID.\n\n    Raises:\n        typer.BadParameter: If the Telegram ID is invalid.\n\n    \"\"\"\n    if value is None:\n        return value\n\n    lvalue = [value] if not isinstance(value, list) else value\n\n    for v in lvalue:\n        if not isinstance(v, int) or v &lt;= 0 or len(str(v)) &gt; 16:\n            msg = \"Must be a positive integer with up to 16 digits\"\n            raise typer.BadParameter(msg)\n\n    return value\n</code></pre>"},{"location":"reference/kamihi/cli/utils/#kamihi.cli.utils.telegram_id_callback(value)","title":"<code>value</code>","text":""},{"location":"reference/kamihi/datasources/","title":"datasources","text":""},{"location":"reference/kamihi/datasources/#kamihi.datasources","title":"kamihi.datasources","text":"<p>Data sources module for Kamihi.</p> License <p>MIT</p> <p>Modules:</p> Name Description <code>datasource</code> <p>Base class for data sources in Kamihi.</p> <code>postgres</code> <p>PostgreSQL datasource module.</p> <code>sqlite</code> <p>SQLite datasource module.</p> <p>Classes:</p> Name Description <code>DataSource</code> <p>Base class for data sources in Kamihi.</p> <code>DataSourceConfig</code> <p>Configuration model for data sources.</p> <code>PostgresDataSource</code> <p>PostgreSQL data source implementation.</p> <code>PostgresDataSourceConfig</code> <p>Configuration model for PostgreSQL data sources.</p> <code>SQLiteDataSource</code> <p>SQLite data source implementation.</p> <code>SQLiteDataSourceConfig</code> <p>Configuration model for SQLite data sources.</p>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.DataSource","title":"DataSource","text":"<pre><code>DataSource(settings: DataSourceConfig)\n</code></pre> <p>Base class for data sources in Kamihi.</p> <p>This class serves as a template for creating specific data source implementations. It defines the basic structure and methods that all data sources should implement.</p> <p>Initialize the DataSource with a name.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name of the data source.</p> required <p>Methods:</p> Name Description <code>connect</code> <p>Connect to the data source.</p> <code>disconnect</code> <p>Disconnect from the data source.</p> <code>fetch</code> <p>Asynchronously fetch data from the data source.</p> <code>get_datasource_class</code> <p>Get the data source class by its type name.</p> Source code in <code>src/kamihi/datasources/datasource.py</code> <pre><code>def __init__(self, settings: DataSourceConfig) -&gt; None:\n    \"\"\"\n    Initialize the DataSource with a name.\n\n    Args:\n        settings (str): The name of the data source.\n\n    \"\"\"\n    self.settings = settings\n</code></pre>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.DataSource(settings)","title":"<code>settings</code>","text":""},{"location":"reference/kamihi/datasources/#kamihi.datasources.DataSource.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; None\n</code></pre> <p>Connect to the data source.</p> <p>This method can be implemented, if needed, to establish a connection to the data source. By default, it does nothing.</p> Source code in <code>src/kamihi/datasources/datasource.py</code> <pre><code>async def connect(self) -&gt; None:  # noqa: ANN002, ANN003, ARG002\n    \"\"\"\n    Connect to the data source.\n\n    This method can be implemented, if needed, to establish a connection\n    to the data source. By default, it does nothing.\n\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.DataSource.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the data source.</p> <p>This method can be implemented, if needed, to close the connection to the data source. By default, it does nothing.</p> Source code in <code>src/kamihi/datasources/datasource.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnect from the data source.\n\n    This method can be implemented, if needed, to close the connection\n    to the data source. By default, it does nothing.\n\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.DataSource.fetch","title":"fetch  <code>async</code>","text":"<pre><code>fetch(request: Path | str) -&gt; Any\n</code></pre> <p>Asynchronously fetch data from the data source.</p> <p>This method should be implemented by subclasses to define how data is retrieved from the specific data source in an asynchronous manner.</p> <p>Parameters:</p> Name Type Description Default <code>Path | str</code> <p>The request to fetch data from the data source. This could be a file path, URL, or any identifier for the data.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The fetched data.</p> Source code in <code>src/kamihi/datasources/datasource.py</code> <pre><code>async def fetch(self, request: Path | str) -&gt; Any:  # noqa: ANN002, ANN003, ANN401\n    \"\"\"\n    Asynchronously fetch data from the data source.\n\n    This method should be implemented by subclasses to define how data is retrieved\n    from the specific data source in an asynchronous manner.\n\n    Args:\n        request (Path | str): The request to fetch data from the data source.\n            This could be a file path, URL, or any identifier for the data.\n\n    Returns:\n        The fetched data.\n\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.DataSource.fetch(request)","title":"<code>request</code>","text":""},{"location":"reference/kamihi/datasources/#kamihi.datasources.DataSource.get_datasource_class","title":"get_datasource_class  <code>classmethod</code>","text":"<pre><code>get_datasource_class(\n    type_name: str,\n) -&gt; type[DataSource] | None\n</code></pre> <p>Get the data source class by its type name.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The type name of the data source.</p> required <p>Returns:</p> Type Description <code>type[DataSource] | None</code> <p>type[DataSource] | None: The data source class if found, otherwise None.</p> Source code in <code>src/kamihi/datasources/datasource.py</code> <pre><code>@classmethod\ndef get_datasource_class(cls, type_name: str) -&gt; type[\"DataSource\"] | None:\n    \"\"\"\n    Get the data source class by its type name.\n\n    Args:\n        type_name (str): The type name of the data source.\n\n    Returns:\n        type[DataSource] | None: The data source class if found, otherwise None.\n\n    \"\"\"\n    if not cls._registry:\n        cls._build_registry()\n    return cls._registry.get(type_name)\n</code></pre>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.DataSource.get_datasource_class(type_name)","title":"<code>type_name</code>","text":""},{"location":"reference/kamihi/datasources/#kamihi.datasources.DataSourceConfig","title":"DataSourceConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration model for data sources.</p> <p>This model defines the configuration schema for data sources in Kamihi. It includes the name of the data source and any additional parameters required for its initialization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the data source. Must be unique across all data sources.</p> <p>Methods:</p> Name Description <code>union_type</code> <p>Get a union type of all registered data source configuration classes.</p>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.DataSourceConfig.union_type","title":"union_type  <code>classmethod</code>","text":"<pre><code>union_type() -&gt; type[Annotated] | NoneType\n</code></pre> <p>Get a union type of all registered data source configuration classes.</p> <p>Returns:</p> Type Description <code>type[Annotated] | NoneType</code> <p>Union[type[DataSourceConfig], ...]: A union type of all registered data source configuration classes.</p> Source code in <code>src/kamihi/datasources/datasource.py</code> <pre><code>@classmethod\ndef union_type(cls) -&gt; type[Annotated] | NoneType:\n    \"\"\"\n    Get a union type of all registered data source configuration classes.\n\n    Returns:\n        Union[type[DataSourceConfig], ...]: A union type of all registered data source configuration classes.\n\n    \"\"\"\n    if not cls._registry.values():\n        cls._build_registry()\n    return (\n        Annotated[\n            Union[tuple(cls._registry.values())],  # noqa: UP007\n            Field(discriminator=\"type\"),\n        ]\n        if cls._registry\n        else NoneType\n    )\n</code></pre>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.PostgresDataSource","title":"PostgresDataSource","text":"<pre><code>PostgresDataSource(settings: PostgresDataSourceConfig)\n</code></pre> <p>               Bases: <code>DataSource</code></p> <p>PostgreSQL data source implementation.</p> <p>This class implements the DataSource interface for connecting to and interacting with a PostgreSQL database.</p> <p>Initialize the PostgresDataSource with the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>PostgresDataSourceConfig</code> <p>The configuration for the PostgreSQL data source.</p> required <p>Methods:</p> Name Description <code>connect</code> <p>Initialize the connection pool for the PostgreSQL database.</p> <code>disconnect</code> <p>Disconnect from the PostgreSQL database asynchronously.</p> <code>fetch</code> <p>Fetch data asynchronously from the PostgreSQL database.</p> <p>Attributes:</p> Name Type Description <code>NamedRecord</code> <code>type</code> <p>Create a named record class for asyncpg records.</p> Source code in <code>src/kamihi/datasources/postgres.py</code> <pre><code>@requires(\"postgresql\")\ndef __init__(self, settings: PostgresDataSourceConfig) -&gt; None:\n    \"\"\"\n    Initialize the PostgresDataSource with the provided configuration.\n\n    Args:\n        settings (PostgresDataSourceConfig): The configuration for the PostgreSQL data source.\n\n    \"\"\"\n    super().__init__(settings)\n    self.settings = settings\n    self._logger = logger.bind(datasource=settings.name, type=settings.type)\n</code></pre>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.PostgresDataSource(settings)","title":"<code>settings</code>","text":""},{"location":"reference/kamihi/datasources/#kamihi.datasources.PostgresDataSource.NamedRecord","title":"NamedRecord  <code>cached</code> <code>property</code>","text":"<pre><code>NamedRecord: type\n</code></pre> <p>Create a named record class for asyncpg records.</p>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.PostgresDataSource.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(*args, **kwargs) -&gt; None\n</code></pre> <p>Initialize the connection pool for the PostgreSQL database.</p> <p>This method is called to set up the connection pool for the PostgreSQL database. It uses asyncpg to create a connection pool with the provided settings.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If asyncpg is not installed.</p> <code>ConnectionError</code> <p>If the connection pool initialization fails.</p> Source code in <code>src/kamihi/datasources/postgres.py</code> <pre><code>async def connect(self, *args, **kwargs) -&gt; None:  # noqa: ANN002, ANN003, ARG002\n    \"\"\"\n    Initialize the connection pool for the PostgreSQL database.\n\n    This method is called to set up the connection pool for the PostgreSQL database.\n    It uses asyncpg to create a connection pool with the provided settings.\n\n    Raises:\n        RuntimeError: If asyncpg is not installed.\n        ConnectionError: If the connection pool initialization fails.\n\n    \"\"\"\n    import asyncpg\n\n    if self._pool is not None:\n        self._logger.warning(\"Connection pool already initialized, skipping re-initialization\")\n        return\n\n    try:\n        self._pool = await asyncpg.create_pool(\n            host=self.settings.host,\n            port=self.settings.port,\n            database=self.settings.database,\n            user=self.settings.user,\n            password=self.settings.password,\n            min_size=self.settings.min_pool_size,\n            max_size=self.settings.max_pool_size,\n            timeout=self.settings.timeout,\n            record_class=self.NamedRecord,\n        )\n        self._logger.info(\"Connected to {datasource}\", datasource=self.settings.name)\n    except asyncpg.PostgresError as e:\n        raise ConnectionError(\"Failed to initialize connection pool\") from e\n</code></pre>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.PostgresDataSource.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the PostgreSQL database asynchronously.</p> <p>This method closes the connection pool if it is initialized.</p> Source code in <code>src/kamihi/datasources/postgres.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnect from the PostgreSQL database asynchronously.\n\n    This method closes the connection pool if it is initialized.\n\n    \"\"\"\n    if self._pool is not None:\n        self._logger.trace(\"Closing connection pool...\")\n        await self._pool.close()\n        self._logger.info(\"Disconnected\")\n        self._pool = None\n</code></pre>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.PostgresDataSource.fetch","title":"fetch  <code>async</code>","text":"<pre><code>fetch(request: Path | str) -&gt; list[NamedRecord]\n</code></pre> <p>Fetch data asynchronously from the PostgreSQL database.</p> <p>This method executes a SQL request from a file and returns the results.</p> <p>Parameters:</p> Name Type Description Default <code>Path | str</code> <p>The path to the SQL request file or the SQL query as a string.</p> required <p>Returns:</p> Type Description <code>list[NamedRecord]</code> <p>list[NamedRecord]: The results obtained from the SQL request.</p> Source code in <code>src/kamihi/datasources/postgres.py</code> <pre><code>async def fetch(self, request: Path | str) -&gt; list[NamedRecord]:\n    \"\"\"\n    Fetch data asynchronously from the PostgreSQL database.\n\n    This method executes a SQL request from a file and returns the results.\n\n    Args:\n        request (Path | str): The path to the SQL request file or the SQL query as a string.\n\n    Returns:\n        list[NamedRecord]: The results obtained from the SQL request.\n\n    \"\"\"\n    if not self._pool:\n        raise RuntimeError(\"Connection pool is not initialized. Call connect() first.\")\n\n    with self._logger.contextualize(request=str(request)), timer(self._logger, \"Executed command\"):\n        async with self._pool.acquire() as conn:\n            self._logger.trace(\"Acquired connection from pool\")\n            results = await conn.fetch(anyio.read_text() if isinstance(request, Path) else request)\n            self._logger.trace(\"Fetched {results} results from datasource\", results=len(results))\n    return results\n</code></pre>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.PostgresDataSource.fetch(request)","title":"<code>request</code>","text":""},{"location":"reference/kamihi/datasources/#kamihi.datasources.PostgresDataSourceConfig","title":"PostgresDataSourceConfig","text":"<p>               Bases: <code>DataSourceConfig</code></p> <p>Configuration model for PostgreSQL data sources.</p> <p>This model extends the base DataSourceConfig to include specific parameters required for connecting to a PostgreSQL database.</p> <p>Attributes:</p> Name Type Description <code>host</code> <code>str</code> <p>The hostname of the PostgreSQL server.</p> <code>port</code> <code>int</code> <p>The port number of the PostgreSQL server.</p> <code>database</code> <code>str</code> <p>The name of the PostgreSQL database to connect to.</p> <code>user</code> <code>str</code> <p>The username for connecting to the PostgreSQL database.</p> <code>password</code> <code>str</code> <p>The password for the specified user.</p> <code>min_pool_size</code> <code>int</code> <p>The minimum number of connections in the pool.</p> <code>max_pool_size</code> <code>int</code> <p>The maximum number of connections in the pool.</p> <code>timeout</code> <code>int</code> <p>The timeout duration for establishing connections, in seconds.</p>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.SQLiteDataSource","title":"SQLiteDataSource","text":"<pre><code>SQLiteDataSource(settings: SQLiteDataSourceConfig)\n</code></pre> <p>               Bases: <code>DataSource</code></p> <p>SQLite data source implementation.</p> <p>This class implements the DataSource interface for connecting to and interacting with an SQLite database.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['sqlite']</code> <p>The type of the data source, which is \"sqlite\".</p> <code>settings</code> <code>SQLiteDataSourceConfig</code> <p>The configuration for the SQLite data source.</p> <p>Initialize the SQLiteDataSource with the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>SQLiteDataSourceConfig</code> <p>The configuration for the SQLite data source.</p> required <p>Methods:</p> Name Description <code>connect</code> <p>Connect to the SQLite database.</p> <code>disconnect</code> <p>Disconnect from the SQLite database.</p> <code>fetch</code> <p>Fetch data from the SQLite database.</p> Source code in <code>src/kamihi/datasources/sqlite.py</code> <pre><code>@requires(\"sqlite\")\ndef __init__(self, settings: SQLiteDataSourceConfig) -&gt; None:\n    \"\"\"\n    Initialize the SQLiteDataSource with the provided configuration.\n\n    Args:\n        settings (SQLiteDataSourceConfig): The configuration for the SQLite data source.\n\n    \"\"\"\n    super().__init__(settings)\n    self.settings = settings\n    self._logger = logger.bind(datasource=settings.name, type=settings.type)\n</code></pre>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.SQLiteDataSource(settings)","title":"<code>settings</code>","text":""},{"location":"reference/kamihi/datasources/#kamihi.datasources.SQLiteDataSource.NamedRecord","title":"NamedRecord  <code>cached</code> <code>property</code>","text":"<pre><code>NamedRecord: type\n</code></pre> <p>Create a named record class for aiosqlite rows.</p>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.SQLiteDataSource.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; None\n</code></pre> <p>Connect to the SQLite database.</p> <p>This method establishes a connection to the SQLite database specified in the settings. It uses the aiosqlite library for asynchronous database operations.</p> Source code in <code>src/kamihi/datasources/sqlite.py</code> <pre><code>async def connect(self) -&gt; None:\n    \"\"\"\n    Connect to the SQLite database.\n\n    This method establishes a connection to the SQLite database specified in the\n    settings. It uses the aiosqlite library for asynchronous database operations.\n\n    \"\"\"\n    import aiosqlite\n\n    if self._db is not None:\n        self._logger.warning(\"Already connected, skipping re-initialization\")\n        return\n\n    try:\n        self._db = await aiosqlite.connect(self.settings.path)\n        self._db.row_factory = self.NamedRecord\n        self._logger.info(\"Connected to {datasource}\", datasource=self.settings.name)\n    except aiosqlite.Error as e:\n        raise RuntimeError(\"Failed to connect\") from e\n</code></pre>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.SQLiteDataSource.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the SQLite database.</p> <p>This method closes the connection to the SQLite database.</p> Source code in <code>src/kamihi/datasources/sqlite.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnect from the SQLite database.\n\n    This method closes the connection to the SQLite database.\n\n    \"\"\"\n    if self._db:\n        self._logger.trace(\"Closing database connection...\")\n        await self._db.close()\n        self._logger.info(\"Disconnected\")\n        self._db = None\n</code></pre>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.SQLiteDataSource.fetch","title":"fetch  <code>async</code>","text":"<pre><code>fetch(request: Path | str) -&gt; list[NamedRecord]\n</code></pre> <p>Fetch data from the SQLite database.</p> <p>This method executes a query against the SQLite database and returns the results.</p> <p>Parameters:</p> Name Type Description Default <code>Path | str</code> <p>The SQL query to execute. This can be a path to a SQL file                   or a raw SQL string.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>list[NamedRecord]</code> <p>The results of the query.</p> Source code in <code>src/kamihi/datasources/sqlite.py</code> <pre><code>async def fetch(self, request: Path | str) -&gt; list[NamedRecord]:\n    \"\"\"\n    Fetch data from the SQLite database.\n\n    This method executes a query against the SQLite database and returns the results.\n\n    Args:\n        request (Path | str): The SQL query to execute. This can be a path to a SQL file\n                              or a raw SQL string.\n\n    Returns:\n        Any: The results of the query.\n\n    \"\"\"\n    if not self._db:\n        raise RuntimeError(\"Database connection is not established. Call connect() first.\")\n\n    with self._logger.contextualize(request=str(request)), timer(self._logger, \"Executed command\"):\n        async with self._db.execute(\n            request if isinstance(request, str) else await anyio.Path(request).read_text()\n        ) as cursor:\n            self._logger.trace(\"Created cursor and executed query\")\n            results = await cursor.fetchall()\n            self._logger.trace(\"Fetched {results} results from datasource\", results=len(results))\n    return results\n</code></pre>"},{"location":"reference/kamihi/datasources/#kamihi.datasources.SQLiteDataSource.fetch(request)","title":"<code>request</code>","text":""},{"location":"reference/kamihi/datasources/#kamihi.datasources.SQLiteDataSourceConfig","title":"SQLiteDataSourceConfig","text":"<p>               Bases: <code>DataSourceConfig</code></p> <p>Configuration model for SQLite data sources.</p> <p>This model extends the base DataSourceConfig to include specific parameters required for connecting to an SQLite database.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['sqlite']</code> <p>The type of the data source, which is \"sqlite\".</p> <code>path</code> <code>str | Path</code> <p>The path to the SQLite database file.</p>"},{"location":"reference/kamihi/datasources/datasource/","title":"datasource","text":""},{"location":"reference/kamihi/datasources/datasource/#kamihi.datasources.datasource","title":"kamihi.datasources.datasource","text":"<p>Base class for data sources in Kamihi.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>DataSource</code> <p>Base class for data sources in Kamihi.</p> <code>DataSourceConfig</code> <p>Configuration model for data sources.</p>"},{"location":"reference/kamihi/datasources/datasource/#kamihi.datasources.datasource.DataSource","title":"DataSource","text":"<pre><code>DataSource(settings: DataSourceConfig)\n</code></pre> <p>Base class for data sources in Kamihi.</p> <p>This class serves as a template for creating specific data source implementations. It defines the basic structure and methods that all data sources should implement.</p> <p>Initialize the DataSource with a name.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name of the data source.</p> required <p>Methods:</p> Name Description <code>connect</code> <p>Connect to the data source.</p> <code>disconnect</code> <p>Disconnect from the data source.</p> <code>fetch</code> <p>Asynchronously fetch data from the data source.</p> <code>get_datasource_class</code> <p>Get the data source class by its type name.</p> Source code in <code>src/kamihi/datasources/datasource.py</code> <pre><code>def __init__(self, settings: DataSourceConfig) -&gt; None:\n    \"\"\"\n    Initialize the DataSource with a name.\n\n    Args:\n        settings (str): The name of the data source.\n\n    \"\"\"\n    self.settings = settings\n</code></pre>"},{"location":"reference/kamihi/datasources/datasource/#kamihi.datasources.datasource.DataSource(settings)","title":"<code>settings</code>","text":""},{"location":"reference/kamihi/datasources/datasource/#kamihi.datasources.datasource.DataSource.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; None\n</code></pre> <p>Connect to the data source.</p> <p>This method can be implemented, if needed, to establish a connection to the data source. By default, it does nothing.</p> Source code in <code>src/kamihi/datasources/datasource.py</code> <pre><code>async def connect(self) -&gt; None:  # noqa: ANN002, ANN003, ARG002\n    \"\"\"\n    Connect to the data source.\n\n    This method can be implemented, if needed, to establish a connection\n    to the data source. By default, it does nothing.\n\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"reference/kamihi/datasources/datasource/#kamihi.datasources.datasource.DataSource.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the data source.</p> <p>This method can be implemented, if needed, to close the connection to the data source. By default, it does nothing.</p> Source code in <code>src/kamihi/datasources/datasource.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnect from the data source.\n\n    This method can be implemented, if needed, to close the connection\n    to the data source. By default, it does nothing.\n\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"reference/kamihi/datasources/datasource/#kamihi.datasources.datasource.DataSource.fetch","title":"fetch  <code>async</code>","text":"<pre><code>fetch(request: Path | str) -&gt; Any\n</code></pre> <p>Asynchronously fetch data from the data source.</p> <p>This method should be implemented by subclasses to define how data is retrieved from the specific data source in an asynchronous manner.</p> <p>Parameters:</p> Name Type Description Default <code>Path | str</code> <p>The request to fetch data from the data source. This could be a file path, URL, or any identifier for the data.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The fetched data.</p> Source code in <code>src/kamihi/datasources/datasource.py</code> <pre><code>async def fetch(self, request: Path | str) -&gt; Any:  # noqa: ANN002, ANN003, ANN401\n    \"\"\"\n    Asynchronously fetch data from the data source.\n\n    This method should be implemented by subclasses to define how data is retrieved\n    from the specific data source in an asynchronous manner.\n\n    Args:\n        request (Path | str): The request to fetch data from the data source.\n            This could be a file path, URL, or any identifier for the data.\n\n    Returns:\n        The fetched data.\n\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"reference/kamihi/datasources/datasource/#kamihi.datasources.datasource.DataSource.fetch(request)","title":"<code>request</code>","text":""},{"location":"reference/kamihi/datasources/datasource/#kamihi.datasources.datasource.DataSource.get_datasource_class","title":"get_datasource_class  <code>classmethod</code>","text":"<pre><code>get_datasource_class(\n    type_name: str,\n) -&gt; type[DataSource] | None\n</code></pre> <p>Get the data source class by its type name.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The type name of the data source.</p> required <p>Returns:</p> Type Description <code>type[DataSource] | None</code> <p>type[DataSource] | None: The data source class if found, otherwise None.</p> Source code in <code>src/kamihi/datasources/datasource.py</code> <pre><code>@classmethod\ndef get_datasource_class(cls, type_name: str) -&gt; type[\"DataSource\"] | None:\n    \"\"\"\n    Get the data source class by its type name.\n\n    Args:\n        type_name (str): The type name of the data source.\n\n    Returns:\n        type[DataSource] | None: The data source class if found, otherwise None.\n\n    \"\"\"\n    if not cls._registry:\n        cls._build_registry()\n    return cls._registry.get(type_name)\n</code></pre>"},{"location":"reference/kamihi/datasources/datasource/#kamihi.datasources.datasource.DataSource.get_datasource_class(type_name)","title":"<code>type_name</code>","text":""},{"location":"reference/kamihi/datasources/datasource/#kamihi.datasources.datasource.DataSourceConfig","title":"DataSourceConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration model for data sources.</p> <p>This model defines the configuration schema for data sources in Kamihi. It includes the name of the data source and any additional parameters required for its initialization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the data source. Must be unique across all data sources.</p> <p>Methods:</p> Name Description <code>union_type</code> <p>Get a union type of all registered data source configuration classes.</p>"},{"location":"reference/kamihi/datasources/datasource/#kamihi.datasources.datasource.DataSourceConfig.union_type","title":"union_type  <code>classmethod</code>","text":"<pre><code>union_type() -&gt; type[Annotated] | NoneType\n</code></pre> <p>Get a union type of all registered data source configuration classes.</p> <p>Returns:</p> Type Description <code>type[Annotated] | NoneType</code> <p>Union[type[DataSourceConfig], ...]: A union type of all registered data source configuration classes.</p> Source code in <code>src/kamihi/datasources/datasource.py</code> <pre><code>@classmethod\ndef union_type(cls) -&gt; type[Annotated] | NoneType:\n    \"\"\"\n    Get a union type of all registered data source configuration classes.\n\n    Returns:\n        Union[type[DataSourceConfig], ...]: A union type of all registered data source configuration classes.\n\n    \"\"\"\n    if not cls._registry.values():\n        cls._build_registry()\n    return (\n        Annotated[\n            Union[tuple(cls._registry.values())],  # noqa: UP007\n            Field(discriminator=\"type\"),\n        ]\n        if cls._registry\n        else NoneType\n    )\n</code></pre>"},{"location":"reference/kamihi/datasources/postgres/","title":"postgres","text":""},{"location":"reference/kamihi/datasources/postgres/#kamihi.datasources.postgres","title":"kamihi.datasources.postgres","text":"<p>PostgreSQL datasource module.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>PostgresDataSource</code> <p>PostgreSQL data source implementation.</p> <code>PostgresDataSourceConfig</code> <p>Configuration model for PostgreSQL data sources.</p>"},{"location":"reference/kamihi/datasources/postgres/#kamihi.datasources.postgres.PostgresDataSource","title":"PostgresDataSource","text":"<pre><code>PostgresDataSource(settings: PostgresDataSourceConfig)\n</code></pre> <p>               Bases: <code>DataSource</code></p> <p>PostgreSQL data source implementation.</p> <p>This class implements the DataSource interface for connecting to and interacting with a PostgreSQL database.</p> <p>Initialize the PostgresDataSource with the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>PostgresDataSourceConfig</code> <p>The configuration for the PostgreSQL data source.</p> required <p>Methods:</p> Name Description <code>connect</code> <p>Initialize the connection pool for the PostgreSQL database.</p> <code>disconnect</code> <p>Disconnect from the PostgreSQL database asynchronously.</p> <code>fetch</code> <p>Fetch data asynchronously from the PostgreSQL database.</p> <p>Attributes:</p> Name Type Description <code>NamedRecord</code> <code>type</code> <p>Create a named record class for asyncpg records.</p> Source code in <code>src/kamihi/datasources/postgres.py</code> <pre><code>@requires(\"postgresql\")\ndef __init__(self, settings: PostgresDataSourceConfig) -&gt; None:\n    \"\"\"\n    Initialize the PostgresDataSource with the provided configuration.\n\n    Args:\n        settings (PostgresDataSourceConfig): The configuration for the PostgreSQL data source.\n\n    \"\"\"\n    super().__init__(settings)\n    self.settings = settings\n    self._logger = logger.bind(datasource=settings.name, type=settings.type)\n</code></pre>"},{"location":"reference/kamihi/datasources/postgres/#kamihi.datasources.postgres.PostgresDataSource(settings)","title":"<code>settings</code>","text":""},{"location":"reference/kamihi/datasources/postgres/#kamihi.datasources.postgres.PostgresDataSource.NamedRecord","title":"NamedRecord  <code>cached</code> <code>property</code>","text":"<pre><code>NamedRecord: type\n</code></pre> <p>Create a named record class for asyncpg records.</p>"},{"location":"reference/kamihi/datasources/postgres/#kamihi.datasources.postgres.PostgresDataSource.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(*args, **kwargs) -&gt; None\n</code></pre> <p>Initialize the connection pool for the PostgreSQL database.</p> <p>This method is called to set up the connection pool for the PostgreSQL database. It uses asyncpg to create a connection pool with the provided settings.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If asyncpg is not installed.</p> <code>ConnectionError</code> <p>If the connection pool initialization fails.</p> Source code in <code>src/kamihi/datasources/postgres.py</code> <pre><code>async def connect(self, *args, **kwargs) -&gt; None:  # noqa: ANN002, ANN003, ARG002\n    \"\"\"\n    Initialize the connection pool for the PostgreSQL database.\n\n    This method is called to set up the connection pool for the PostgreSQL database.\n    It uses asyncpg to create a connection pool with the provided settings.\n\n    Raises:\n        RuntimeError: If asyncpg is not installed.\n        ConnectionError: If the connection pool initialization fails.\n\n    \"\"\"\n    import asyncpg\n\n    if self._pool is not None:\n        self._logger.warning(\"Connection pool already initialized, skipping re-initialization\")\n        return\n\n    try:\n        self._pool = await asyncpg.create_pool(\n            host=self.settings.host,\n            port=self.settings.port,\n            database=self.settings.database,\n            user=self.settings.user,\n            password=self.settings.password,\n            min_size=self.settings.min_pool_size,\n            max_size=self.settings.max_pool_size,\n            timeout=self.settings.timeout,\n            record_class=self.NamedRecord,\n        )\n        self._logger.info(\"Connected to {datasource}\", datasource=self.settings.name)\n    except asyncpg.PostgresError as e:\n        raise ConnectionError(\"Failed to initialize connection pool\") from e\n</code></pre>"},{"location":"reference/kamihi/datasources/postgres/#kamihi.datasources.postgres.PostgresDataSource.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the PostgreSQL database asynchronously.</p> <p>This method closes the connection pool if it is initialized.</p> Source code in <code>src/kamihi/datasources/postgres.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnect from the PostgreSQL database asynchronously.\n\n    This method closes the connection pool if it is initialized.\n\n    \"\"\"\n    if self._pool is not None:\n        self._logger.trace(\"Closing connection pool...\")\n        await self._pool.close()\n        self._logger.info(\"Disconnected\")\n        self._pool = None\n</code></pre>"},{"location":"reference/kamihi/datasources/postgres/#kamihi.datasources.postgres.PostgresDataSource.fetch","title":"fetch  <code>async</code>","text":"<pre><code>fetch(request: Path | str) -&gt; list[NamedRecord]\n</code></pre> <p>Fetch data asynchronously from the PostgreSQL database.</p> <p>This method executes a SQL request from a file and returns the results.</p> <p>Parameters:</p> Name Type Description Default <code>Path | str</code> <p>The path to the SQL request file or the SQL query as a string.</p> required <p>Returns:</p> Type Description <code>list[NamedRecord]</code> <p>list[NamedRecord]: The results obtained from the SQL request.</p> Source code in <code>src/kamihi/datasources/postgres.py</code> <pre><code>async def fetch(self, request: Path | str) -&gt; list[NamedRecord]:\n    \"\"\"\n    Fetch data asynchronously from the PostgreSQL database.\n\n    This method executes a SQL request from a file and returns the results.\n\n    Args:\n        request (Path | str): The path to the SQL request file or the SQL query as a string.\n\n    Returns:\n        list[NamedRecord]: The results obtained from the SQL request.\n\n    \"\"\"\n    if not self._pool:\n        raise RuntimeError(\"Connection pool is not initialized. Call connect() first.\")\n\n    with self._logger.contextualize(request=str(request)), timer(self._logger, \"Executed command\"):\n        async with self._pool.acquire() as conn:\n            self._logger.trace(\"Acquired connection from pool\")\n            results = await conn.fetch(anyio.read_text() if isinstance(request, Path) else request)\n            self._logger.trace(\"Fetched {results} results from datasource\", results=len(results))\n    return results\n</code></pre>"},{"location":"reference/kamihi/datasources/postgres/#kamihi.datasources.postgres.PostgresDataSource.fetch(request)","title":"<code>request</code>","text":""},{"location":"reference/kamihi/datasources/postgres/#kamihi.datasources.postgres.PostgresDataSourceConfig","title":"PostgresDataSourceConfig","text":"<p>               Bases: <code>DataSourceConfig</code></p> <p>Configuration model for PostgreSQL data sources.</p> <p>This model extends the base DataSourceConfig to include specific parameters required for connecting to a PostgreSQL database.</p> <p>Attributes:</p> Name Type Description <code>host</code> <code>str</code> <p>The hostname of the PostgreSQL server.</p> <code>port</code> <code>int</code> <p>The port number of the PostgreSQL server.</p> <code>database</code> <code>str</code> <p>The name of the PostgreSQL database to connect to.</p> <code>user</code> <code>str</code> <p>The username for connecting to the PostgreSQL database.</p> <code>password</code> <code>str</code> <p>The password for the specified user.</p> <code>min_pool_size</code> <code>int</code> <p>The minimum number of connections in the pool.</p> <code>max_pool_size</code> <code>int</code> <p>The maximum number of connections in the pool.</p> <code>timeout</code> <code>int</code> <p>The timeout duration for establishing connections, in seconds.</p>"},{"location":"reference/kamihi/datasources/sqlite/","title":"sqlite","text":""},{"location":"reference/kamihi/datasources/sqlite/#kamihi.datasources.sqlite","title":"kamihi.datasources.sqlite","text":"<p>SQLite datasource module.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>SQLiteDataSource</code> <p>SQLite data source implementation.</p> <code>SQLiteDataSourceConfig</code> <p>Configuration model for SQLite data sources.</p>"},{"location":"reference/kamihi/datasources/sqlite/#kamihi.datasources.sqlite.SQLiteDataSource","title":"SQLiteDataSource","text":"<pre><code>SQLiteDataSource(settings: SQLiteDataSourceConfig)\n</code></pre> <p>               Bases: <code>DataSource</code></p> <p>SQLite data source implementation.</p> <p>This class implements the DataSource interface for connecting to and interacting with an SQLite database.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['sqlite']</code> <p>The type of the data source, which is \"sqlite\".</p> <code>settings</code> <code>SQLiteDataSourceConfig</code> <p>The configuration for the SQLite data source.</p> <p>Initialize the SQLiteDataSource with the provided configuration.</p> <p>Parameters:</p> Name Type Description Default <code>SQLiteDataSourceConfig</code> <p>The configuration for the SQLite data source.</p> required <p>Methods:</p> Name Description <code>connect</code> <p>Connect to the SQLite database.</p> <code>disconnect</code> <p>Disconnect from the SQLite database.</p> <code>fetch</code> <p>Fetch data from the SQLite database.</p> Source code in <code>src/kamihi/datasources/sqlite.py</code> <pre><code>@requires(\"sqlite\")\ndef __init__(self, settings: SQLiteDataSourceConfig) -&gt; None:\n    \"\"\"\n    Initialize the SQLiteDataSource with the provided configuration.\n\n    Args:\n        settings (SQLiteDataSourceConfig): The configuration for the SQLite data source.\n\n    \"\"\"\n    super().__init__(settings)\n    self.settings = settings\n    self._logger = logger.bind(datasource=settings.name, type=settings.type)\n</code></pre>"},{"location":"reference/kamihi/datasources/sqlite/#kamihi.datasources.sqlite.SQLiteDataSource(settings)","title":"<code>settings</code>","text":""},{"location":"reference/kamihi/datasources/sqlite/#kamihi.datasources.sqlite.SQLiteDataSource.NamedRecord","title":"NamedRecord  <code>cached</code> <code>property</code>","text":"<pre><code>NamedRecord: type\n</code></pre> <p>Create a named record class for aiosqlite rows.</p>"},{"location":"reference/kamihi/datasources/sqlite/#kamihi.datasources.sqlite.SQLiteDataSource.connect","title":"connect  <code>async</code>","text":"<pre><code>connect() -&gt; None\n</code></pre> <p>Connect to the SQLite database.</p> <p>This method establishes a connection to the SQLite database specified in the settings. It uses the aiosqlite library for asynchronous database operations.</p> Source code in <code>src/kamihi/datasources/sqlite.py</code> <pre><code>async def connect(self) -&gt; None:\n    \"\"\"\n    Connect to the SQLite database.\n\n    This method establishes a connection to the SQLite database specified in the\n    settings. It uses the aiosqlite library for asynchronous database operations.\n\n    \"\"\"\n    import aiosqlite\n\n    if self._db is not None:\n        self._logger.warning(\"Already connected, skipping re-initialization\")\n        return\n\n    try:\n        self._db = await aiosqlite.connect(self.settings.path)\n        self._db.row_factory = self.NamedRecord\n        self._logger.info(\"Connected to {datasource}\", datasource=self.settings.name)\n    except aiosqlite.Error as e:\n        raise RuntimeError(\"Failed to connect\") from e\n</code></pre>"},{"location":"reference/kamihi/datasources/sqlite/#kamihi.datasources.sqlite.SQLiteDataSource.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect() -&gt; None\n</code></pre> <p>Disconnect from the SQLite database.</p> <p>This method closes the connection to the SQLite database.</p> Source code in <code>src/kamihi/datasources/sqlite.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnect from the SQLite database.\n\n    This method closes the connection to the SQLite database.\n\n    \"\"\"\n    if self._db:\n        self._logger.trace(\"Closing database connection...\")\n        await self._db.close()\n        self._logger.info(\"Disconnected\")\n        self._db = None\n</code></pre>"},{"location":"reference/kamihi/datasources/sqlite/#kamihi.datasources.sqlite.SQLiteDataSource.fetch","title":"fetch  <code>async</code>","text":"<pre><code>fetch(request: Path | str) -&gt; list[NamedRecord]\n</code></pre> <p>Fetch data from the SQLite database.</p> <p>This method executes a query against the SQLite database and returns the results.</p> <p>Parameters:</p> Name Type Description Default <code>Path | str</code> <p>The SQL query to execute. This can be a path to a SQL file                   or a raw SQL string.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>list[NamedRecord]</code> <p>The results of the query.</p> Source code in <code>src/kamihi/datasources/sqlite.py</code> <pre><code>async def fetch(self, request: Path | str) -&gt; list[NamedRecord]:\n    \"\"\"\n    Fetch data from the SQLite database.\n\n    This method executes a query against the SQLite database and returns the results.\n\n    Args:\n        request (Path | str): The SQL query to execute. This can be a path to a SQL file\n                              or a raw SQL string.\n\n    Returns:\n        Any: The results of the query.\n\n    \"\"\"\n    if not self._db:\n        raise RuntimeError(\"Database connection is not established. Call connect() first.\")\n\n    with self._logger.contextualize(request=str(request)), timer(self._logger, \"Executed command\"):\n        async with self._db.execute(\n            request if isinstance(request, str) else await anyio.Path(request).read_text()\n        ) as cursor:\n            self._logger.trace(\"Created cursor and executed query\")\n            results = await cursor.fetchall()\n            self._logger.trace(\"Fetched {results} results from datasource\", results=len(results))\n    return results\n</code></pre>"},{"location":"reference/kamihi/datasources/sqlite/#kamihi.datasources.sqlite.SQLiteDataSource.fetch(request)","title":"<code>request</code>","text":""},{"location":"reference/kamihi/datasources/sqlite/#kamihi.datasources.sqlite.SQLiteDataSourceConfig","title":"SQLiteDataSourceConfig","text":"<p>               Bases: <code>DataSourceConfig</code></p> <p>Configuration model for SQLite data sources.</p> <p>This model extends the base DataSourceConfig to include specific parameters required for connecting to an SQLite database.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['sqlite']</code> <p>The type of the data source, which is \"sqlite\".</p> <code>path</code> <code>str | Path</code> <p>The path to the SQLite database file.</p>"},{"location":"reference/kamihi/db/","title":"db","text":""},{"location":"reference/kamihi/db/#kamihi.db","title":"kamihi.db","text":"<p>Database connections module for the Kamihi framework.</p> License <p>MIT</p> <p>Modules:</p> Name Description <code>db</code> <p>Database connection module for the Kamihi framework.</p> <code>models</code> <p>Internal models for Kamihi.</p> <p>Classes:</p> Name Description <code>BaseUser</code> <p>Base class for user models.</p> <code>Job</code> <p>Model for scheduled jobs.</p> <code>Pages</code> <p>Model for pages in a paginated media type.</p> <code>Permission</code> <p>Model for permissions.</p> <code>RegisteredAction</code> <p>Model for registered actions.</p> <code>Role</code> <p>Model for roles.</p> <p>Functions:</p> Name Description <code>get_engine</code> <p>Create a database engine.</p> <code>init_engine</code> <p>Initialize the database engine.</p>"},{"location":"reference/kamihi/db/#kamihi.db.BaseUser","title":"BaseUser","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for user models.</p> <p>This class should be extended in user code to create a custom user model.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p> <code>telegram_id</code> <code>int</code> <p>Unique Telegram ID of the user.</p> <code>is_admin</code> <code>bool</code> <p>Whether the user is an admin.</p> <code>roles</code> <code>list[Role]</code> <p>List of roles associated with the user.</p> <code>permissions</code> <code>list[Permission]</code> <p>List of permissions associated with the user.</p> <p>Methods:</p> Name Description <code>admin_repr</code> <p>Define the representation of the user in the admin interface.</p> <code>cls</code> <p>Get the active user class.</p>"},{"location":"reference/kamihi/db/#kamihi.db.BaseUser.admin_repr","title":"admin_repr","text":"<pre><code>admin_repr() -&gt; str\n</code></pre> <p>Define the representation of the user in the admin interface.</p> Source code in <code>src/kamihi/db/models.py</code> <pre><code>def admin_repr(self) -&gt; str:\n    \"\"\"Define the representation of the user in the admin interface.\"\"\"\n    return str(self.telegram_id)\n</code></pre>"},{"location":"reference/kamihi/db/#kamihi.db.BaseUser.cls","title":"cls  <code>classmethod</code>","text":"<pre><code>cls() -&gt; type[BaseUser]\n</code></pre> <p>Get the active user class.</p> Source code in <code>src/kamihi/db/models.py</code> <pre><code>@classmethod\ndef cls(cls) -&gt; type[BaseUser]:\n    \"\"\"Get the active user class.\"\"\"\n    return cls._active_class or globals()[\"User\"]\n</code></pre>"},{"location":"reference/kamihi/db/#kamihi.db.Job","title":"Job","text":"<p>               Bases: <code>BaseUuidModel</code></p> <p>Model for scheduled jobs.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p> <code>action_id</code> <code>int</code> <p>Foreign key to the registered action.</p> <code>action</code> <code>RegisteredAction</code> <p>The registered action associated with the job.</p> <code>cron_expression</code> <code>str</code> <p>Cron expression defining the job schedule.</p> <code>enabled</code> <code>bool</code> <p>Whether the job is active.</p> <code>args</code> <code>dict</code> <p>Arguments to pass to the job when executed.</p> <code>users</code> <code>list[User]</code> <p>List of users associated with the job.</p>"},{"location":"reference/kamihi/db/#kamihi.db.Job.effective_users","title":"effective_users  <code>property</code>","text":"<pre><code>effective_users: list[BaseUser]\n</code></pre> <p>Get the list of users associated with this job, either directly or through roles.</p> <p>Returns:</p> Type Description <code>list[BaseUser]</code> <p>list[User]: List of users associated with this job.</p>"},{"location":"reference/kamihi/db/#kamihi.db.Pages","title":"Pages","text":"<p>               Bases: <code>BaseUuidModel</code></p> <p>Model for pages in a paginated media type.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p>"},{"location":"reference/kamihi/db/#kamihi.db.Permission","title":"Permission","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for permissions.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p> <code>action_id</code> <code>int | None</code> <p>Foreign key to the registered action.</p> <code>action</code> <code>RegisteredAction</code> <p>The registered action associated with the permission.</p> <code>users</code> <code>list[User]</code> <p>List of users associated with the permission.</p> <code>roles</code> <code>list[Role]</code> <p>List of roles associated with the permission.</p> <p>Methods:</p> Name Description <code>is_user_allowed</code> <p>Check if a user has this permission.</p>"},{"location":"reference/kamihi/db/#kamihi.db.Permission.effective_users","title":"effective_users  <code>property</code>","text":"<pre><code>effective_users: list[BaseUser]\n</code></pre> <p>Get the list of users who have this permission, either directly or through roles.</p> <p>Returns:</p> Type Description <code>list[BaseUser]</code> <p>list[User]: List of users with this permission.</p>"},{"location":"reference/kamihi/db/#kamihi.db.Permission.is_user_allowed","title":"is_user_allowed","text":"<pre><code>is_user_allowed(user: BaseUser) -&gt; bool\n</code></pre> <p>Check if a user has this permission.</p> <p>Parameters:</p> Name Type Description Default <code>User</code> <p>The user to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the user has this permission, False otherwise.</p> Source code in <code>src/kamihi/db/models.py</code> <pre><code>def is_user_allowed(self, user: BaseUser) -&gt; bool:\n    \"\"\"\n    Check if a user has this permission.\n\n    Args:\n        user (User): The user to check.\n\n    Returns:\n        bool: True if the user has this permission, False otherwise.\n\n    \"\"\"\n    return user in self.effective_users\n</code></pre>"},{"location":"reference/kamihi/db/#kamihi.db.Permission.is_user_allowed(user)","title":"<code>user</code>","text":""},{"location":"reference/kamihi/db/#kamihi.db.RegisteredAction","title":"RegisteredAction","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for registered actions.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p> <code>name</code> <code>str</code> <p>Name of the action.</p> <code>description</code> <code>str | None</code> <p>Description of the action.</p> <code>permissions</code> <code>list[Permission]</code> <p>List of permissions associated with the action.</p>"},{"location":"reference/kamihi/db/#kamihi.db.Role","title":"Role","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for roles.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p> <code>name</code> <code>str</code> <p>Name of the role.</p> <code>users</code> <code>list[User]</code> <p>List of users associated with the role.</p> <code>permissions</code> <code>list[Permission]</code> <p>List of permissions associated with the role.</p>"},{"location":"reference/kamihi/db/#kamihi.db.get_engine","title":"get_engine","text":"<pre><code>get_engine() -&gt; Engine\n</code></pre> <p>Create a database engine.</p> <p>Returns:</p> Name Type Description <code>Engine</code> <code>Engine</code> <p>The database engine.</p> Source code in <code>src/kamihi/db/db.py</code> <pre><code>def get_engine() -&gt; Engine:\n    \"\"\"\n    Create a database engine.\n\n    Returns:\n        Engine: The database engine.\n\n    \"\"\"\n    if _engine is None:\n        raise RuntimeError(\"Database engine is not initialized. Call init_engine() first.\")\n    return _engine\n</code></pre>"},{"location":"reference/kamihi/db/#kamihi.db.init_engine","title":"init_engine","text":"<pre><code>init_engine() -&gt; None\n</code></pre> <p>Initialize the database engine.</p> Source code in <code>src/kamihi/db/db.py</code> <pre><code>def init_engine() -&gt; None:\n    \"\"\"Initialize the database engine.\"\"\"\n    global _engine  # skipcq: PYL-W0603\n\n    db_settings = get_settings().db\n\n    if _engine is None:\n        _engine = create_engine(db_settings.url)\n</code></pre>"},{"location":"reference/kamihi/db/db/","title":"db","text":""},{"location":"reference/kamihi/db/db/#kamihi.db.db","title":"kamihi.db.db","text":"<p>Database connection module for the Kamihi framework.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>after_cursor_execute</code> <p>Events after execution.</p> <code>get_engine</code> <p>Create a database engine.</p> <code>init_engine</code> <p>Initialize the database engine.</p>"},{"location":"reference/kamihi/db/db/#kamihi.db.db.after_cursor_execute","title":"after_cursor_execute","text":"<pre><code>after_cursor_execute(\n    _conn,\n    _cursor,\n    statement,\n    _parameters,\n    context,\n    _executemany,\n) -&gt; None\n</code></pre> <p>Events after execution.</p> Source code in <code>src/kamihi/db/db.py</code> <pre><code>@event.listens_for(Engine, \"after_cursor_execute\")\ndef after_cursor_execute(\n    _conn,  # noqa: ANN001\n    _cursor,  # noqa: ANN001\n    statement,  # noqa: ANN001\n    _parameters,  # noqa: ANN001\n    context,  # noqa: ANN001\n    _executemany,  # noqa: ANN001\n) -&gt; None:\n    \"\"\"Events after execution.\"\"\"\n    total = time.time() - context.query_start_time\n    logger.bind(statement=statement, ms=round(total * 1000, 2)).trace(\"Executed statement\")\n</code></pre>"},{"location":"reference/kamihi/db/db/#kamihi.db.db.get_engine","title":"get_engine","text":"<pre><code>get_engine() -&gt; Engine\n</code></pre> <p>Create a database engine.</p> <p>Returns:</p> Name Type Description <code>Engine</code> <code>Engine</code> <p>The database engine.</p> Source code in <code>src/kamihi/db/db.py</code> <pre><code>def get_engine() -&gt; Engine:\n    \"\"\"\n    Create a database engine.\n\n    Returns:\n        Engine: The database engine.\n\n    \"\"\"\n    if _engine is None:\n        raise RuntimeError(\"Database engine is not initialized. Call init_engine() first.\")\n    return _engine\n</code></pre>"},{"location":"reference/kamihi/db/db/#kamihi.db.db.init_engine","title":"init_engine","text":"<pre><code>init_engine() -&gt; None\n</code></pre> <p>Initialize the database engine.</p> Source code in <code>src/kamihi/db/db.py</code> <pre><code>def init_engine() -&gt; None:\n    \"\"\"Initialize the database engine.\"\"\"\n    global _engine  # skipcq: PYL-W0603\n\n    db_settings = get_settings().db\n\n    if _engine is None:\n        _engine = create_engine(db_settings.url)\n</code></pre>"},{"location":"reference/kamihi/db/models/","title":"models","text":""},{"location":"reference/kamihi/db/models/#kamihi.db.models","title":"kamihi.db.models","text":"<p>Internal models for Kamihi.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>BaseModel</code> <p>Base model with common attributes.</p> <code>BaseUser</code> <p>Base class for user models.</p> <code>BaseUuidModel</code> <p>Base model with UUID primary key.</p> <code>Job</code> <p>Model for scheduled jobs.</p> <code>JobRoleLink</code> <p>Association table for many-to-many relationship between jobs and roles.</p> <code>JobUserLink</code> <p>Association table for many-to-many relationship between jobs and users.</p> <code>Pages</code> <p>Model for pages in a paginated media type.</p> <code>Permission</code> <p>Model for permissions.</p> <code>PermissionRoleLink</code> <p>Association table for many-to-many relationship between permissions and roles.</p> <code>PermissionUserLink</code> <p>Association table for many-to-many relationship between permissions and users.</p> <code>RegisteredAction</code> <p>Model for registered actions.</p> <code>Role</code> <p>Model for roles.</p> <code>UserRoleLink</code> <p>Association table for many-to-many relationship between users and roles.</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.BaseModel","title":"BaseModel","text":"<p>               Bases: <code>Base</code></p> <p>Base model with common attributes.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p> <code>created_at</code> <code>datetime</code> <p>Timestamp of creation.</p> <code>updated_at</code> <code>datetime</code> <p>Timestamp of last update.</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.BaseUser","title":"BaseUser","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for user models.</p> <p>This class should be extended in user code to create a custom user model.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p> <code>telegram_id</code> <code>int</code> <p>Unique Telegram ID of the user.</p> <code>is_admin</code> <code>bool</code> <p>Whether the user is an admin.</p> <code>roles</code> <code>list[Role]</code> <p>List of roles associated with the user.</p> <code>permissions</code> <code>list[Permission]</code> <p>List of permissions associated with the user.</p> <p>Methods:</p> Name Description <code>admin_repr</code> <p>Define the representation of the user in the admin interface.</p> <code>cls</code> <p>Get the active user class.</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.BaseUser.admin_repr","title":"admin_repr","text":"<pre><code>admin_repr() -&gt; str\n</code></pre> <p>Define the representation of the user in the admin interface.</p> Source code in <code>src/kamihi/db/models.py</code> <pre><code>def admin_repr(self) -&gt; str:\n    \"\"\"Define the representation of the user in the admin interface.\"\"\"\n    return str(self.telegram_id)\n</code></pre>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.BaseUser.cls","title":"cls  <code>classmethod</code>","text":"<pre><code>cls() -&gt; type[BaseUser]\n</code></pre> <p>Get the active user class.</p> Source code in <code>src/kamihi/db/models.py</code> <pre><code>@classmethod\ndef cls(cls) -&gt; type[BaseUser]:\n    \"\"\"Get the active user class.\"\"\"\n    return cls._active_class or globals()[\"User\"]\n</code></pre>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.BaseUuidModel","title":"BaseUuidModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model with UUID primary key.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Primary key (UUID).</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.Job","title":"Job","text":"<p>               Bases: <code>BaseUuidModel</code></p> <p>Model for scheduled jobs.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p> <code>action_id</code> <code>int</code> <p>Foreign key to the registered action.</p> <code>action</code> <code>RegisteredAction</code> <p>The registered action associated with the job.</p> <code>cron_expression</code> <code>str</code> <p>Cron expression defining the job schedule.</p> <code>enabled</code> <code>bool</code> <p>Whether the job is active.</p> <code>args</code> <code>dict</code> <p>Arguments to pass to the job when executed.</p> <code>users</code> <code>list[User]</code> <p>List of users associated with the job.</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.Job.effective_users","title":"effective_users  <code>property</code>","text":"<pre><code>effective_users: list[BaseUser]\n</code></pre> <p>Get the list of users associated with this job, either directly or through roles.</p> <p>Returns:</p> Type Description <code>list[BaseUser]</code> <p>list[User]: List of users associated with this job.</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.JobRoleLink","title":"JobRoleLink","text":"<p>               Bases: <code>Base</code></p> <p>Association table for many-to-many relationship between jobs and roles.</p> <p>Attributes:</p> Name Type Description <code>job_id</code> <code>str</code> <p>Foreign key to the job.</p> <code>role_id</code> <code>int</code> <p>Foreign key to the role.</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.JobUserLink","title":"JobUserLink","text":"<p>               Bases: <code>Base</code></p> <p>Association table for many-to-many relationship between jobs and users.</p> <p>Attributes:</p> Name Type Description <code>job_id</code> <code>str</code> <p>Foreign key to the job.</p> <code>user_id</code> <code>int</code> <p>Foreign key to the user.</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.Pages","title":"Pages","text":"<p>               Bases: <code>BaseUuidModel</code></p> <p>Model for pages in a paginated media type.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.Permission","title":"Permission","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for permissions.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p> <code>action_id</code> <code>int | None</code> <p>Foreign key to the registered action.</p> <code>action</code> <code>RegisteredAction</code> <p>The registered action associated with the permission.</p> <code>users</code> <code>list[User]</code> <p>List of users associated with the permission.</p> <code>roles</code> <code>list[Role]</code> <p>List of roles associated with the permission.</p> <p>Methods:</p> Name Description <code>is_user_allowed</code> <p>Check if a user has this permission.</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.Permission.effective_users","title":"effective_users  <code>property</code>","text":"<pre><code>effective_users: list[BaseUser]\n</code></pre> <p>Get the list of users who have this permission, either directly or through roles.</p> <p>Returns:</p> Type Description <code>list[BaseUser]</code> <p>list[User]: List of users with this permission.</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.Permission.is_user_allowed","title":"is_user_allowed","text":"<pre><code>is_user_allowed(user: BaseUser) -&gt; bool\n</code></pre> <p>Check if a user has this permission.</p> <p>Parameters:</p> Name Type Description Default <code>User</code> <p>The user to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the user has this permission, False otherwise.</p> Source code in <code>src/kamihi/db/models.py</code> <pre><code>def is_user_allowed(self, user: BaseUser) -&gt; bool:\n    \"\"\"\n    Check if a user has this permission.\n\n    Args:\n        user (User): The user to check.\n\n    Returns:\n        bool: True if the user has this permission, False otherwise.\n\n    \"\"\"\n    return user in self.effective_users\n</code></pre>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.Permission.is_user_allowed(user)","title":"<code>user</code>","text":""},{"location":"reference/kamihi/db/models/#kamihi.db.models.PermissionRoleLink","title":"PermissionRoleLink","text":"<p>               Bases: <code>Base</code></p> <p>Association table for many-to-many relationship between permissions and roles.</p> <p>Attributes:</p> Name Type Description <code>permission_id</code> <code>int</code> <p>Foreign key to the permission.</p> <code>role_id</code> <code>int</code> <p>Foreign key to the role.</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.PermissionUserLink","title":"PermissionUserLink","text":"<p>               Bases: <code>Base</code></p> <p>Association table for many-to-many relationship between permissions and users.</p> <p>Attributes:</p> Name Type Description <code>permission_id</code> <code>int</code> <p>Foreign key to the permission.</p> <code>user_id</code> <code>int</code> <p>Foreign key to the user.</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.RegisteredAction","title":"RegisteredAction","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for registered actions.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p> <code>name</code> <code>str</code> <p>Name of the action.</p> <code>description</code> <code>str | None</code> <p>Description of the action.</p> <code>permissions</code> <code>list[Permission]</code> <p>List of permissions associated with the action.</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.Role","title":"Role","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for roles.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p> <code>name</code> <code>str</code> <p>Name of the role.</p> <code>users</code> <code>list[User]</code> <p>List of users associated with the role.</p> <code>permissions</code> <code>list[Permission]</code> <p>List of permissions associated with the role.</p>"},{"location":"reference/kamihi/db/models/#kamihi.db.models.UserRoleLink","title":"UserRoleLink","text":"<p>               Bases: <code>Base</code></p> <p>Association table for many-to-many relationship between users and roles.</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <code>int</code> <p>Foreign key to the user.</p> <code>role_id</code> <code>int</code> <p>Foreign key to the role.</p>"},{"location":"reference/kamihi/questions/","title":"questions","text":""},{"location":"reference/kamihi/questions/#kamihi.questions","title":"kamihi.questions","text":"<p>Questions module for Kamihi.</p> License <p>MIT</p> <p>Modules:</p> Name Description <code>bool</code> <p>Generic boolean reusable question.</p> <code>choice</code> <p>Generic choice reusable question.</p> <code>date</code> <p>Generic date reusable question.</p> <code>datetime</code> <p>Generic datetime reusable question.</p> <code>dynamic_choice</code> <p>Generic dynamic choice reusable question.</p> <code>file</code> <p>Generic file reusable question.</p> <code>image</code> <p>Generic image reusable question.</p> <code>integer</code> <p>Generic integer reusable question.</p> <code>question</code> <p>Base question class.</p> <code>string</code> <p>Generic string reusable question.</p> <code>time</code> <p>Generic time reusable question.</p> <p>Classes:</p> Name Description <code>Bool</code> <p>Generic boolean reusable question.</p> <code>Choice</code> <p>Generic choice reusable question.</p> <code>Date</code> <p>Generic date reusable question.</p> <code>Datetime</code> <p>Generic date reusable question.</p> <code>DynamicChoice</code> <p>Generic dynamic choice reusable question.</p> <code>File</code> <p>Generic file reusable question.</p> <code>Image</code> <p>Generic image reusable question.</p> <code>Integer</code> <p>Generic integer reusable question.</p> <code>Question</code> <p>Base class for questions.</p> <code>String</code> <p>Generic string reusable question.</p> <code>Time</code> <p>Generic time reusable question.</p>"},{"location":"reference/kamihi/questions/#kamihi.questions.Bool","title":"Bool","text":"<pre><code>Bool(\n    text: str,\n    error_text: str = None,\n    true_values: set[str] = None,\n    false_values: set[str] = None,\n)\n</code></pre> <p>               Bases: <code>Question</code></p> <p>Generic boolean reusable question.</p> <p>Initialize an instance of the Bool question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a value from settings.</p> <code>None</code> <code>set[str]</code> <p>A set of strings that represent true values. Defaults to a value from settings.</p> <code>None</code> <code>set[str]</code> <p>A set of strings that represent false values. Defaults to a value from settings.</p> <code>None</code> Source code in <code>src/kamihi/questions/bool.py</code> <pre><code>def __init__(\n    self, text: str, error_text: str = None, true_values: set[str] = None, false_values: set[str] = None\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the Bool question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        true_values (set[str], optional): A set of strings that represent true values. Defaults to a value from settings.\n        false_values (set[str], optional): A set of strings that represent false values. Defaults to a value from settings.\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    if true_values is not None:\n        self.true_values.update(true_values)\n\n    if false_values is not None:\n        self.false_values.update(false_values)\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Bool(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Bool(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Bool(true_values)","title":"<code>true_values</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Bool(false_values)","title":"<code>false_values</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Choice","title":"Choice","text":"<pre><code>Choice(\n    text: str,\n    choices: dict[str, Any]\n    | Iterable[str | tuple[str, Any]]\n    | Callable,\n    error_text: str = None,\n    reply_type: Literal[\n        \"simple\", \"keyboard\", \"inline\"\n    ] = \"simple\",\n    cols: int = 1,\n)\n</code></pre> <p>               Bases: <code>Question</code></p> <p>Generic choice reusable question.</p> <p>Initialize an instance of a multiple-choice question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>dict[str, Any] | Iterable[str | tuple[str, Any]]</code> <p>The available choices for the question. Can be one of: - A dictionary mapping display text to return values. - An iterable of strings (where each string is both the display text and return value). - An iterable of tuples (where each tuple contains display text and return value). - A callable that returns one of the above.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a value from settings.</p> <code>None</code> <code>Literal['simple', 'keyboard', 'inline']</code> <p>The type of choice question. Defaults to \"simple\".</p> <code>'simple'</code> <code>int</code> <p>The number of columns for keyboard or inline button layouts. Defaults to 1.</p> <code>1</code> <p>Methods:</p> Name Description <code>ask_question</code> <p>Ask the choice question to the user.</p> <code>get_response</code> <p>Get the response from the user.</p> <code>handler</code> <p>Return the handler for the answer to the question.</p> <p>Attributes:</p> Name Type Description <code>choices</code> <code>dict[str, Any]</code> <p>Get the available choices for the question.</p> Source code in <code>src/kamihi/questions/choice.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    choices: dict[str, Any] | Iterable[str | tuple[str, Any]] | Callable,\n    error_text: str = None,\n    reply_type: Literal[\"simple\", \"keyboard\", \"inline\"] = \"simple\",\n    cols: int = 1,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of a multiple-choice question.\n\n    Args:\n        text (str): The text of the question.\n        choices (dict[str, Any] | Iterable[str | tuple[str, Any]]): The available choices for the question. Can be one of:\n            - A dictionary mapping display text to return values.\n            - An iterable of strings (where each string is both the display text and return value).\n            - An iterable of tuples (where each tuple contains display text and return value).\n            - A callable that returns one of the above.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        reply_type (Literal[\"simple\", \"keyboard\", \"inline\"], optional): The type of choice question. Defaults to \"simple\".\n        cols (int, optional): The number of columns for keyboard or inline button layouts. Defaults to 1.\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    if isinstance(choices, dict) or callable(choices):\n        self._choices = choices\n    else:\n        self._choices = {}\n        for choice in choices:\n            if isinstance(choice, tuple):\n                display_text, return_value = choice\n                self._choices[display_text] = return_value\n            else:\n                self._choices[choice] = choice\n\n    self.reply_type = reply_type\n    self.cols = max(1, cols)\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Choice(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Choice(choices)","title":"<code>choices</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Choice(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Choice(reply_type)","title":"<code>reply_type</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Choice(cols)","title":"<code>cols</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Choice.choices","title":"choices  <code>property</code>","text":"<pre><code>choices: dict[str, Any]\n</code></pre> <p>Get the available choices for the question.</p>"},{"location":"reference/kamihi/questions/#kamihi.questions.Choice.ask_question","title":"ask_question  <code>async</code>","text":"<pre><code>ask_question(\n    update: Update, context: CallbackContext\n) -&gt; None\n</code></pre> <p>Ask the choice question to the user.</p> <p>Override this method to customize how the question is asked based on the reply type.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required Source code in <code>src/kamihi/questions/choice.py</code> <pre><code>async def ask_question(self, update: Update, context: CallbackContext) -&gt; None:\n    \"\"\"\n    Ask the choice question to the user.\n\n    Override this method to customize how the question is asked based on the reply type.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    \"\"\"\n    reply_markup = None\n    match self.reply_type:\n        case \"keyboard\":\n            keyboard = [\n                list(list(self.choices.keys())[i : i + self.cols]) for i in range(0, len(self.choices), self.cols)\n            ]\n            reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)\n        case \"inline\":\n            keyboard = [\n                [\n                    InlineKeyboardButton(choice, callback_data=self._param_name + \"_\" + choice)\n                    for choice in list(self.choices.keys())[i : i + self.cols]\n                ]\n                for i in range(0, len(self.choices), self.cols)\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n    await send(self.question_text, update, context, reply_markup)\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Choice.ask_question(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Choice.ask_question(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Choice.get_response","title":"get_response  <code>async</code>","text":"<pre><code>get_response(\n    update: Update, context: CallbackContext\n) -&gt; Any\n</code></pre> <p>Get the response from the user.</p> <p>Override this method to customize how the response is retrieved from the update and/or context.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The response from the user, which can be of any type.</p> Source code in <code>src/kamihi/questions/choice.py</code> <pre><code>async def get_response(self, update: Update, context: CallbackContext) -&gt; Any:\n    \"\"\"\n    Get the response from the user.\n\n    Override this method to customize how the response is retrieved from the update and/or context.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    Returns:\n        Any: The response from the user, which can be of any type.\n\n    \"\"\"\n    match self.reply_type:\n        case \"simple\":\n            return update.message.text\n        case \"keyboard\":\n            msg = await send(\n                get_settings().questions.remove_keyboard_text, update, context, reply_markup=ReplyKeyboardRemove()\n            )\n            await msg.delete()\n            return update.message.text\n        case \"inline\":\n            await context.bot.answer_callback_query(callback_query_id=update.callback_query.id)\n            return update.callback_query.data.removeprefix(self._param_name + \"_\")\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Choice.get_response(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Choice.get_response(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Choice.handler","title":"handler","text":"<pre><code>handler(\n    func: Callable[\n        [Update, CallbackContext], Coroutine[Any, Any, Any]\n    ],\n) -&gt; MessageHandler | CallbackQueryHandler\n</code></pre> <p>Return the handler for the answer to the question.</p> <p>Do not override this method. Instead, override the <code>filters</code> property to customize the filters used.</p> <p>Parameters:</p> Name Type Description Default <code>Callable</code> <p>The function to handle the user's response.</p> required <p>Returns:</p> Name Type Description <code>MessageHandler</code> <code>MessageHandler | CallbackQueryHandler</code> <p>The handler for the answer to the question.</p> Source code in <code>src/kamihi/questions/choice.py</code> <pre><code>def handler(\n    self, func: Callable[[Update, CallbackContext], Coroutine[Any, Any, Any]]\n) -&gt; MessageHandler | CallbackQueryHandler:\n    \"\"\"\n    Return the handler for the answer to the question.\n\n    Do not override this method. Instead, override the `filters` property to customize the filters used.\n\n    Args:\n        func (Callable): The function to handle the user's response.\n\n    Returns:\n        MessageHandler: The handler for the answer to the question.\n\n    \"\"\"\n    if self.reply_type == \"inline\":\n        return CallbackQueryHandler(func, pattern=rf\"^{self._param_name}_\")\n    return MessageHandler(self.filters, func)\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Choice.handler(func)","title":"<code>func</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Date","title":"Date","text":"<pre><code>Date(\n    text: str,\n    error_text: str = None,\n    before: date | None = None,\n    after: date | None = None,\n    in_the_past: bool = False,\n    in_the_future: bool = False,\n)\n</code></pre> <p>               Bases: <code>Datetime</code></p> <p>Generic date reusable question.</p> <p>Initialize an instance of the Date question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a value from settings.</p> <code>None</code> <code>date | None</code> <p>The latest acceptable date (exclusive). Defaults to None.</p> <code>None</code> <code>date | None</code> <p>The earliest acceptable date (exclusive). Defaults to None</p> <code>None</code> <code>bool</code> <p>Whether the date must be in the past. Defaults to False.</p> <code>False</code> <code>bool</code> <p>Whether the date must be in the future. Defaults to False.</p> <code>False</code> Source code in <code>src/kamihi/questions/date.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    error_text: str = None,\n    before: date | None = None,\n    after: date | None = None,\n    in_the_past: bool = False,  # noqa: FBT001, FBT002\n    in_the_future: bool = False,  # noqa: FBT001, FBT002\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the Date question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        before (date | None, optional): The latest acceptable date (exclusive). Defaults to None.\n        after (date | None, optional): The earliest acceptable date (exclusive). Defaults to None\n        in_the_past (bool, optional): Whether the date must be in the past. Defaults to False.\n        in_the_future (bool, optional): Whether the date must be in the future. Defaults to False.\n\n    \"\"\"\n    super().__init__(\n        text=text,\n        error_text=error_text,\n        before=None if before is None else datetime.combine(before, datetime.min.time()),\n        after=None if after is None else datetime.combine(after, datetime.min.time()),\n        in_the_past=in_the_past,\n        in_the_future=in_the_future,\n    )\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Date(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Date(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Date(before)","title":"<code>before</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Date(after)","title":"<code>after</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Date(in_the_past)","title":"<code>in_the_past</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Date(in_the_future)","title":"<code>in_the_future</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Datetime","title":"Datetime","text":"<pre><code>Datetime(\n    text: str,\n    error_text: str = None,\n    before: datetime | None = None,\n    after: datetime | None = None,\n    in_the_past: bool = False,\n    in_the_future: bool = False,\n)\n</code></pre> <p>               Bases: <code>Question</code></p> <p>Generic date reusable question.</p> <p>Initialize an instance of the Datetime question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a value from settings.</p> <code>None</code> <code>datetime | None</code> <p>The latest acceptable date (exclusive). Defaults to None.</p> <code>None</code> <code>datetime | None</code> <p>The earliest acceptable date (exclusive). Defaults to None</p> <code>None</code> <code>bool</code> <p>Whether the date must be in the past. Defaults to False.</p> <code>False</code> <code>bool</code> <p>Whether the date must be in the future. Defaults to False.</p> <code>False</code> Source code in <code>src/kamihi/questions/datetime.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    error_text: str = None,\n    before: datetime | None = None,\n    after: datetime | None = None,\n    in_the_past: bool = False,  # noqa: FBT001, FBT002\n    in_the_future: bool = False,  # noqa: FBT001, FBT002\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the Datetime question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        before (datetime | None, optional): The latest acceptable date (exclusive). Defaults to None.\n        after (datetime | None, optional): The earliest acceptable date (exclusive). Defaults to None\n        in_the_past (bool, optional): Whether the date must be in the past. Defaults to False.\n        in_the_future (bool, optional): Whether the date must be in the future. Defaults to False.\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    self.before = before\n    if self.before and not before.tzinfo:\n        self.before = before.replace(tzinfo=get_settings().timezone_obj)\n\n    self.after = after\n    if self.after and not after.tzinfo:\n        self.after = after.replace(tzinfo=get_settings().timezone_obj)\n\n    self.in_the_past = in_the_past\n    self.in_the_future = in_the_future\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Datetime(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Datetime(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Datetime(before)","title":"<code>before</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Datetime(after)","title":"<code>after</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Datetime(in_the_past)","title":"<code>in_the_past</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Datetime(in_the_future)","title":"<code>in_the_future</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice","title":"DynamicChoice","text":"<pre><code>DynamicChoice(\n    text: str,\n    request: str | Path = None,\n    error_text: str = None,\n    reply_type: Literal[\n        \"simple\", \"keyboard\", \"inline\"\n    ] = \"simple\",\n    cols: int = 1,\n)\n</code></pre> <p>               Bases: <code>Question</code></p> <p>Generic dynamic choice reusable question.</p> <p>Initialize an instance of a multiple-choice question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str | Path</code> <p>The name of the request file from which the choices will be obtained.</p> <code>None</code> <code>str</code> <p>The error text to display for invalid responses. Defaults to a value from settings.</p> <code>None</code> <code>Literal['simple', 'keyboard', 'inline']</code> <p>The type of choice question. Defaults to \"simple\".</p> <code>'simple'</code> <code>int</code> <p>The number of columns for keyboard or inline button layouts. Defaults to 1.</p> <code>1</code> <p>Methods:</p> Name Description <code>ask_question</code> <p>Ask the choice question to the user, fetching dynamic choices.</p> <code>get_choices</code> <p>Get the available choices for the question and save them in chat_data.</p> <code>get_response</code> <p>Get the response from the user.</p> <code>handler</code> <p>Return the handler for the answer to the question.</p> Source code in <code>src/kamihi/questions/dynamic_choice.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    request: str | Path = None,\n    error_text: str = None,\n    reply_type: Literal[\"simple\", \"keyboard\", \"inline\"] = \"simple\",\n    cols: int = 1,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of a multiple-choice question.\n\n    Args:\n        text (str): The text of the question.\n        request (str | Path): The name of the request file from which the choices will be obtained.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        reply_type (Literal[\"simple\", \"keyboard\", \"inline\"], optional): The type of choice question. Defaults to \"simple\".\n        cols (int, optional): The number of columns for keyboard or inline button layouts. Defaults to 1.\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    if not hasattr(self, \"request\") and request:\n        self.request = request if isinstance(request, Path) else Path(request)\n    elif not hasattr(self, \"request\"):\n        raise ValueError(\"A request file must be provided for DynamicChoice questions.\")\n\n    if not self.request.is_absolute():\n        self.request = Path.cwd() / \"questions\" / self.request\n\n    self.reply_type = reply_type\n    self.cols = max(1, cols)\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice(request)","title":"<code>request</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice(reply_type)","title":"<code>reply_type</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice(cols)","title":"<code>cols</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice.ask_question","title":"ask_question  <code>async</code>","text":"<pre><code>ask_question(\n    update: Update, context: CallbackContext\n) -&gt; None\n</code></pre> <p>Ask the choice question to the user, fetching dynamic choices.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required Source code in <code>src/kamihi/questions/dynamic_choice.py</code> <pre><code>async def ask_question(self, update: Update, context: CallbackContext) -&gt; None:\n    \"\"\"\n    Ask the choice question to the user, fetching dynamic choices.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    \"\"\"\n    choices = await self.get_choices(context)\n\n    reply_markup = None\n    match self.reply_type:\n        case \"keyboard\":\n            keyboard = [list(list(choices.keys())[i : i + self.cols]) for i in range(0, len(choices), self.cols)]\n            reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)\n        case \"inline\":\n            keyboard = [\n                [\n                    InlineKeyboardButton(choice, callback_data=self._param_name + \"_\" + choice)\n                    for choice in list(choices.keys())[i : i + self.cols]\n                ]\n                for i in range(0, len(choices), self.cols)\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n    await send(self.question_text, update, context, reply_markup)\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice.ask_question(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice.ask_question(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice.get_choices","title":"get_choices  <code>async</code>","text":"<pre><code>get_choices(context: CallbackContext) -&gt; dict[str, Any]\n</code></pre> <p>Get the available choices for the question and save them in chat_data.</p> <p>Parameters:</p> Name Type Description Default <code>CallbackContext</code> <p>The callback context.</p> required Source code in <code>src/kamihi/questions/dynamic_choice.py</code> <pre><code>async def get_choices(self, context: CallbackContext) -&gt; dict[str, Any]:\n    \"\"\"\n    Get the available choices for the question and save them in chat_data.\n\n    Args:\n        context (CallbackContext): The callback context.\n\n    \"\"\"\n    datasources: dict[str, DataSource] = context.bot_data.get(\"datasources\", {})\n    ds = datasources[self.request.stem.split(\".\")[-1]]\n    res = await ds.fetch(self.request)\n    choices = {}\n    for row in res:\n        if len(row) &gt;= 2:\n            choices[str(row[0]).strip()] = row[1]\n        elif len(row) == 1:\n            choices[str(row[0]).strip()] = row[0]\n\n    context.chat_data[\"questions\"][self._param_name] = choices\n    return choices\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice.get_choices(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice.get_response","title":"get_response  <code>async</code>","text":"<pre><code>get_response(\n    update: Update, context: CallbackContext\n) -&gt; Any\n</code></pre> <p>Get the response from the user.</p> <p>Override this method to customize how the response is retrieved from the update and/or context.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The response from the user, which can be of any type.</p> Source code in <code>src/kamihi/questions/dynamic_choice.py</code> <pre><code>async def get_response(self, update: Update, context: CallbackContext) -&gt; Any:\n    \"\"\"\n    Get the response from the user.\n\n    Override this method to customize how the response is retrieved from the update and/or context.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    Returns:\n        Any: The response from the user, which can be of any type.\n\n    \"\"\"\n    match self.reply_type:\n        case \"simple\":\n            return update.message.text\n        case \"keyboard\":\n            msg = await send(\n                get_settings().questions.remove_keyboard_text, update, context, reply_markup=ReplyKeyboardRemove()\n            )\n            await msg.delete()\n            return update.message.text\n        case \"inline\":\n            await context.bot.answer_callback_query(callback_query_id=update.callback_query.id)\n            return update.callback_query.data.removeprefix(self._param_name + \"_\")\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice.get_response(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice.get_response(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice.handler","title":"handler","text":"<pre><code>handler(\n    func: Callable[\n        [Update, CallbackContext], Coroutine[Any, Any, Any]\n    ],\n) -&gt; MessageHandler | CallbackQueryHandler\n</code></pre> <p>Return the handler for the answer to the question.</p> <p>Do not override this method. Instead, override the <code>filters</code> property to customize the filters used.</p> <p>Parameters:</p> Name Type Description Default <code>Callable</code> <p>The function to handle the user's response.</p> required <p>Returns:</p> Name Type Description <code>MessageHandler</code> <code>MessageHandler | CallbackQueryHandler</code> <p>The handler for the answer to the question.</p> Source code in <code>src/kamihi/questions/dynamic_choice.py</code> <pre><code>def handler(\n    self, func: Callable[[Update, CallbackContext], Coroutine[Any, Any, Any]]\n) -&gt; MessageHandler | CallbackQueryHandler:\n    \"\"\"\n    Return the handler for the answer to the question.\n\n    Do not override this method. Instead, override the `filters` property to customize the filters used.\n\n    Args:\n        func (Callable): The function to handle the user's response.\n\n    Returns:\n        MessageHandler: The handler for the answer to the question.\n\n    \"\"\"\n    if self.reply_type == \"inline\":\n        return CallbackQueryHandler(func, pattern=rf\"^{self._param_name}_\")\n    return MessageHandler(self.filters, func)\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.DynamicChoice.handler(func)","title":"<code>func</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.File","title":"File","text":"<pre><code>File(\n    text: str,\n    error_text: str = None,\n    return_as: Literal[\"path\", \"bytes\"] = \"path\",\n    max_size: int = None,\n    allowed_extensions: list[str] = None,\n    allowed_mime_types: list[str] = None,\n)\n</code></pre> <p>               Bases: <code>Question</code></p> <p>Generic file reusable question.</p> <p>Initialize an instance of the File question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a preset message.</p> <code>None</code> <code>Literal['path', 'bytes']</code> <p>The format in which to return the file. Defaults to \"path\".</p> <code>'path'</code> <code>int</code> <p>The maximum allowed file size in bytes. Defaults to FileSizeLimit.FILESIZE_DOWNLOAD.</p> <code>None</code> <code>list[str]</code> <p>List of allowed file extensions (without leading dot!). Defaults to an empty list.</p> <code>None</code> <code>list[str]</code> <p>List of allowed MIME types. Defaults to an empty list.</p> <code>None</code> <p>Methods:</p> Name Description <code>cast</code> <p>Convert the saved file path to the desired return type.</p> <code>get_response</code> <p>Extract and validate the file from the user's response.</p> <p>Attributes:</p> Name Type Description <code>filters</code> <code>BaseFilter</code> <p>Return the filters for the answer to the file question.</p> Source code in <code>src/kamihi/questions/file.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    error_text: str = None,\n    return_as: Literal[\"path\", \"bytes\"] = \"path\",\n    max_size: int = None,\n    allowed_extensions: list[str] = None,\n    allowed_mime_types: list[str] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the File question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a preset message.\n        return_as (Literal[\"path\", \"bytes\"], optional): The format in which to return the file. Defaults to \"path\".\n        max_size (int, optional): The maximum allowed file size in bytes. Defaults to FileSizeLimit.FILESIZE_DOWNLOAD.\n        allowed_extensions (list[str], optional): List of allowed file extensions (without leading dot!). Defaults to an empty list.\n        allowed_mime_types (list[str], optional): List of allowed MIME types. Defaults to an empty list.\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    if max_size is not None:\n        self.max_size = max_size\n\n    if allowed_extensions is not None:\n        if any(ext.endswith(\".\") for ext in allowed_extensions):\n            raise ValueError(\"File extensions must not end with a dot (e.g., use 'pdf' instead of 'pdf.').\")\n        self.allowed_extensions = list(set(allowed_extensions))\n\n    if allowed_mime_types is not None:\n        self.allowed_mime_types = list(set(allowed_mime_types))\n\n    self.return_as = return_as\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.File(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.File(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.File(return_as)","title":"<code>return_as</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.File(max_size)","title":"<code>max_size</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.File(allowed_extensions)","title":"<code>allowed_extensions</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.File(allowed_mime_types)","title":"<code>allowed_mime_types</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.File.filters","title":"filters  <code>property</code>","text":"<pre><code>filters: BaseFilter\n</code></pre> <p>Return the filters for the answer to the file question.</p> <p>Returns:</p> Type Description <code>BaseFilter</code> <p>filters.BaseFilter: The filters to capture valid file responses.</p>"},{"location":"reference/kamihi/questions/#kamihi.questions.File.cast","title":"cast","text":"<pre><code>cast(path: Path) -&gt; Path | bytes\n</code></pre> <p>Convert the saved file path to the desired return type.</p> <p>Parameters:</p> Name Type Description Default <code>Path</code> <p>The path to the saved file.</p> required <p>Returns:</p> Name Type Description <code>ReturnT</code> <code>Path | bytes</code> <p>The file in the desired return type (Path or bytes).</p> Source code in <code>src/kamihi/questions/file.py</code> <pre><code>def cast(self, path: Path) -&gt; Path | bytes:\n    \"\"\"\n    Convert the saved file path to the desired return type.\n\n    Args:\n        path (Path): The path to the saved file.\n\n    Returns:\n        ReturnT: The file in the desired return type (Path or bytes).\n\n    \"\"\"\n    if self.return_as == \"bytes\":\n        return path.read_bytes()\n    return path\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.File.cast(path)","title":"<code>path</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.File.get_response","title":"get_response  <code>async</code>","text":"<pre><code>get_response(\n    update: Update, context: CallbackContext\n) -&gt; Document\n</code></pre> <p>Extract and validate the file from the user's response.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required <p>Returns:</p> Name Type Description <code>Document</code> <code>Document</code> <p>The Telegram Document object from the update.</p> Source code in <code>src/kamihi/questions/file.py</code> <pre><code>async def get_response(self, update: Update, context: CallbackContext) -&gt; Document:\n    \"\"\"\n    Extract and validate the file from the user's response.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    Returns:\n        Document: The Telegram Document object from the update.\n\n    \"\"\"\n    return update.message.document\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.File.get_response(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.File.get_response(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Image","title":"Image","text":"<pre><code>Image(\n    text: str,\n    error_text: str = \"Please upload a valid image.\",\n    return_as: Literal[\"path\", \"bytes\", \"pil\"] = \"path\",\n    max_size: int = None,\n    allowed_extensions: list[str] = None,\n    allowed_mime_types: list[str] = None,\n)\n</code></pre> <p>               Bases: <code>File</code></p> <p>Generic image reusable question.</p> <p>Initialize an instance of the Image question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a preset message.</p> <code>'Please upload a valid image.'</code> <code>Literal['path', 'bytes', 'pil']</code> <p>The format in which to return the image. Defaults to \"path\".</p> <code>'path'</code> <code>int</code> <p>The maximum allowed file size in bytes. Defaults to FileSizeLimit.FILESIZE_DOWNLOAD.</p> <code>None</code> <code>list[str]</code> <p>List of allowed file extensions (without leading dot!). Defaults to common image formats.</p> <code>None</code> <code>list[str]</code> <p>List of allowed MIME types. Defaults to common image MIME types.</p> <code>None</code> <p>Methods:</p> Name Description <code>cast</code> <p>Convert the saved file path to the desired return type.</p> <code>get_response</code> <p>Extract and validate the file from the user's response.</p> <p>Attributes:</p> Name Type Description <code>filters</code> <code>BaseFilter</code> <p>Return the filters for the answer to the image question.</p> Source code in <code>src/kamihi/questions/image.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    error_text: str = \"Please upload a valid image.\",\n    return_as: Literal[\"path\", \"bytes\", \"pil\"] = \"path\",\n    max_size: int = None,\n    allowed_extensions: list[str] = None,\n    allowed_mime_types: list[str] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the Image question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a preset message.\n        return_as (Literal[\"path\", \"bytes\", \"pil\"], optional): The format in which to return the image. Defaults to \"path\".\n        max_size (int, optional): The maximum allowed file size in bytes. Defaults to FileSizeLimit.FILESIZE_DOWNLOAD.\n        allowed_extensions (list[str], optional): List of allowed file extensions (without leading dot!). Defaults to common image formats.\n        allowed_mime_types (list[str], optional): List of allowed MIME types. Defaults to common image MIME types.\n\n    \"\"\"\n    super().__init__(\n        text,\n        error_text=error_text,\n        return_as=\"path\",\n        max_size=max_size,\n        allowed_extensions=allowed_extensions,\n        allowed_mime_types=allowed_mime_types,\n    )\n    self.return_as = return_as\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Image(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Image(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Image(return_as)","title":"<code>return_as</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Image(max_size)","title":"<code>max_size</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Image(allowed_extensions)","title":"<code>allowed_extensions</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Image(allowed_mime_types)","title":"<code>allowed_mime_types</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Image.filters","title":"filters  <code>property</code>","text":"<pre><code>filters: BaseFilter\n</code></pre> <p>Return the filters for the answer to the image question.</p>"},{"location":"reference/kamihi/questions/#kamihi.questions.Image.cast","title":"cast","text":"<pre><code>cast(path: Path) -&gt; Path | bytes | PILImage.Image\n</code></pre> <p>Convert the saved file path to the desired return type.</p> <p>Parameters:</p> Name Type Description Default <code>Path</code> <p>The path to the saved file.</p> required <p>Returns:</p> Name Type Description <code>ReturnT</code> <code>Path | bytes | Image</code> <p>The file in the desired return type (Path or bytes).</p> Source code in <code>src/kamihi/questions/image.py</code> <pre><code>def cast(self, path: Path) -&gt; Path | bytes | PILImage.Image:\n    \"\"\"\n    Convert the saved file path to the desired return type.\n\n    Args:\n        path (Path): The path to the saved file.\n\n    Returns:\n        ReturnT: The file in the desired return type (Path or bytes).\n\n    \"\"\"\n    if self.return_as == \"bytes\":\n        return path.read_bytes()\n    if self.return_as == \"pil\":\n        return PILImage.open(path)\n    return path\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Image.cast(path)","title":"<code>path</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Image.get_response","title":"get_response  <code>async</code>","text":"<pre><code>get_response(\n    update: Update, context: CallbackContext\n) -&gt; PhotoSize\n</code></pre> <p>Extract and validate the file from the user's response.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required <p>Returns:</p> Name Type Description <code>Document</code> <code>PhotoSize</code> <p>The Telegram Document object from the update.</p> Source code in <code>src/kamihi/questions/image.py</code> <pre><code>async def get_response(self, update: Update, context: CallbackContext) -&gt; PhotoSize:\n    \"\"\"\n    Extract and validate the file from the user's response.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    Returns:\n        Document: The Telegram Document object from the update.\n\n    \"\"\"\n    return update.message.photo[-1]\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Image.get_response(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Image.get_response(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Integer","title":"Integer","text":"<pre><code>Integer(\n    text: str,\n    error_text: str = None,\n    le: int | None = None,\n    ge: int | None = None,\n    lt: int | None = None,\n    gt: int | None = None,\n    multiple_of: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Question</code></p> <p>Generic integer reusable question.</p> <p>Initialize an instance of the Integer question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a value from settings.</p> <code>None</code> <code>int | None</code> <p>The maximum acceptable value (exclusive). Defaults to None.</p> <code>None</code> <code>int | None</code> <p>The minimum acceptable value (exclusive). Defaults to None</p> <code>None</code> <code>int | None</code> <p>The maximum acceptable value (inclusive). Defaults to None.</p> <code>None</code> <code>int | None</code> <p>The minimum acceptable value (inclusive). Defaults to None</p> <code>None</code> <code>int | None</code> <p>The value must be a multiple of this number. Defaults to None.</p> <code>None</code> Source code in <code>src/kamihi/questions/integer.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    error_text: str = None,\n    le: int | None = None,\n    ge: int | None = None,\n    lt: int | None = None,\n    gt: int | None = None,\n    multiple_of: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the Integer question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        le (int | None, optional): The maximum acceptable value (exclusive). Defaults to None.\n        ge (int | None, optional): The minimum acceptable value (exclusive). Defaults to None\n        lt (int | None, optional): The maximum acceptable value (inclusive). Defaults to None.\n        gt (int | None, optional): The minimum acceptable value (inclusive). Defaults to None\n        multiple_of (int | None, optional): The value must be a multiple of this number. Defaults to None.\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    self.le = le\n    self.ge = ge\n    self.lt = lt\n    self.gt = gt\n    self.multiple_of = multiple_of\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Integer(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Integer(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Integer(le)","title":"<code>le</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Integer(ge)","title":"<code>ge</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Integer(lt)","title":"<code>lt</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Integer(gt)","title":"<code>gt</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Integer(multiple_of)","title":"<code>multiple_of</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question","title":"Question","text":"<p>Base class for questions.</p> <p>Methods:</p> Name Description <code>ask_question</code> <p>Send the question text to the user.</p> <code>entry</code> <p>Return the entry function for the question.</p> <code>exit</code> <p>Return the exit function for the question.</p> <code>get_response</code> <p>Get the response from the user.</p> <code>handler</code> <p>Return the handler for the answer to the question.</p> <code>validate</code> <p>Validate the user's response.</p> <code>validate_after</code> <p>Validate the user's response after Kamihi's built-in validation.</p> <code>validate_before</code> <p>Validate the user's response before Kamihi's built-in validation.</p> <code>with_action</code> <p>Set the parameter name for the question.</p> <p>Attributes:</p> Name Type Description <code>filters</code> <code>BaseFilter</code> <p>Return the filters for the answer to the question.</p>"},{"location":"reference/kamihi/questions/#kamihi.questions.Question.filters","title":"filters  <code>property</code>","text":"<pre><code>filters: BaseFilter\n</code></pre> <p>Return the filters for the answer to the question.</p> <p>Override this method to customize the filters used to capture the user's response.</p> <p>Returns:</p> Type Description <code>BaseFilter</code> <p>filters.BaseFilter: The filters for the answer to the question.</p>"},{"location":"reference/kamihi/questions/#kamihi.questions.Question.ask_question","title":"ask_question  <code>async</code>","text":"<pre><code>ask_question(\n    update: Update, context: CallbackContext\n) -&gt; None\n</code></pre> <p>Send the question text to the user.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required Source code in <code>src/kamihi/questions/question.py</code> <pre><code>async def ask_question(self, update: Update, context: CallbackContext) -&gt; None:\n    \"\"\"\n    Send the question text to the user.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    \"\"\"\n    await send(self.question_text, update, context)\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Question.ask_question(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.ask_question(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.entry","title":"entry","text":"<pre><code>entry(\n    current_state: int,\n    prev_exit: Callable[\n        [Update, CallbackContext], Coroutine[Any, Any, bool]\n    ]\n    | None = None,\n) -&gt; Callable[\n    [Update, CallbackContext], Coroutine[Any, Any, int]\n]\n</code></pre> <p>Return the entry function for the question.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The current state of the conversation.</p> required <code>Callable</code> <p>The exit function of the last question. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable[[Update, CallbackContext], Coroutine[Any, Any, int]]</code> <p>The entry function for the question.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>def entry(\n    self,\n    current_state: int,\n    prev_exit: Callable[[Update, CallbackContext], Coroutine[Any, Any, bool]] | None = None,\n) -&gt; Callable[[Update, CallbackContext], Coroutine[Any, Any, int]]:\n    \"\"\"\n    Return the entry function for the question.\n\n    Args:\n        current_state (int): The current state of the conversation.\n        prev_exit (Callable, optional): The exit function of the last question. Defaults to None.\n\n    Returns:\n        Callable: The entry function for the question.\n\n    \"\"\"\n\n    async def _enter(update: Update, context: CallbackContext) -&gt; int:\n        \"\"\"Entry function for the question.\"\"\"\n        self._logger.trace(\"Entered\")\n        if prev_exit:\n            self._logger.debug(\"Calling previous exit\")\n            prev_exited_successfully = await prev_exit(update, context)\n            if not prev_exited_successfully:\n                return current_state\n\n        self._logger.debug(\"Asking\")\n        await self.ask_question(update, context)\n        self._logger.trace(\"Now awaiting user response\")\n        return current_state + 1\n\n    return _enter\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Question.entry(current_state)","title":"<code>current_state</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.entry(prev_exit)","title":"<code>prev_exit</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.exit","title":"exit","text":"<pre><code>exit() -&gt; Callable[\n    [Update, CallbackContext], Coroutine[Any, Any, bool]\n]\n</code></pre> <p>Return the exit function for the question.</p> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable[[Update, CallbackContext], Coroutine[Any, Any, bool]]</code> <p>The exit function for the question.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>def exit(self) -&gt; Callable[[Update, CallbackContext], Coroutine[Any, Any, bool]]:\n    \"\"\"\n    Return the exit function for the question.\n\n    Returns:\n        Callable: The exit function for the question.\n\n    \"\"\"\n\n    async def _exit(update: Update, context: CallbackContext) -&gt; bool:\n        \"\"\"Exit function for the question.\"\"\"\n        self._logger.trace(\"Starting exit\")\n        res = await self.get_response(update, context)\n\n        try:\n            res = await self.validate(res, update, context)\n            self._logger.trace(\"Validation successful\")\n        except ValueError as e:\n            self._logger.debug(\"Validation failed: {}\", e)\n            await send(str(e), update, context)\n            return False\n\n        await self._save(res, context)\n        self._logger.debug(\"Exited\")\n        return True\n\n    return _exit\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Question.get_response","title":"get_response  <code>async</code>","text":"<pre><code>get_response(\n    update: Update, context: CallbackContext\n) -&gt; Any\n</code></pre> <p>Get the response from the user.</p> <p>Override this method to customize how the response is retrieved from the update and/or context.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The response from the user, which can be of any type.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>async def get_response(self, update: Update, context: CallbackContext) -&gt; Any:  # skipcq: PYL-R0201\n    \"\"\"\n    Get the response from the user.\n\n    Override this method to customize how the response is retrieved from the update and/or context.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    Returns:\n        Any: The response from the user, which can be of any type.\n\n    \"\"\"\n    return update.message.text\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Question.get_response(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.get_response(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.handler","title":"handler","text":"<pre><code>handler(\n    func: Callable[\n        [Update, CallbackContext], Coroutine[Any, Any, Any]\n    ],\n) -&gt; MessageHandler\n</code></pre> <p>Return the handler for the answer to the question.</p> <p>Do not override this method. Instead, override the <code>filters</code> property to customize the filters used.</p> <p>Parameters:</p> Name Type Description Default <code>Callable</code> <p>The function to handle the user's response.</p> required <p>Returns:</p> Name Type Description <code>MessageHandler</code> <code>MessageHandler</code> <p>The handler for the answer to the question.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>def handler(self, func: Callable[[Update, CallbackContext], Coroutine[Any, Any, Any]]) -&gt; MessageHandler:\n    \"\"\"\n    Return the handler for the answer to the question.\n\n    Do not override this method. Instead, override the `filters` property to customize the filters used.\n\n    Args:\n        func (Callable): The function to handle the user's response.\n\n    Returns:\n        MessageHandler: The handler for the answer to the question.\n\n    \"\"\"\n    return MessageHandler(self.filters, func)\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Question.handler(func)","title":"<code>func</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.validate","title":"validate  <code>async</code>","text":"<pre><code>validate(\n    response: Any,\n    update: Update | None = None,\n    context: CallbackContext | None = None,\n) -&gt; Any\n</code></pre> <p>Validate the user's response.</p> <p>This method is what unifies the validation process. It first calls <code>validate_before</code>, then performs any built-in validation (if applicable), and finally calls <code>validate_after</code>. Only override this method if you want to completely replace the validation process.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The response from the user.</p> required <code>Update</code> <p>The update object. Defaults to None.</p> <code>None</code> <code>CallbackContext</code> <p>The callback context. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The validated response, which can be of any type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the response is invalid.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>async def validate(\n    self,\n    response: Any,\n    update: Update | None = None,\n    context: CallbackContext | None = None,\n) -&gt; Any:\n    \"\"\"\n    Validate the user's response.\n\n    This method is what unifies the validation process. It first calls `validate_before`, then performs any built-in\n    validation (if applicable), and finally calls `validate_after`. Only override this method if you want to\n    completely replace the validation process.\n\n    Args:\n        response (Any): The response from the user.\n        update (Update, optional): The update object. Defaults to None.\n        context (CallbackContext, optional): The callback context. Defaults to None.\n\n    Returns:\n        Any: The validated response, which can be of any type.\n\n    Raises:\n        ValueError: If the response is invalid.\n\n    \"\"\"\n    response = await self.validate_before(response, update, context)\n    response = await self._validate_internal(response, update, context)\n    return await self.validate_after(response, update, context)\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Question.validate(response)","title":"<code>response</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.validate(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.validate(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.validate_after","title":"validate_after  <code>async</code>","text":"<pre><code>validate_after(\n    response: Any,\n    update: Update | None = None,\n    context: CallbackContext | None = None,\n) -&gt; Any\n</code></pre> <p>Validate the user's response after Kamihi's built-in validation.</p> <p>Override this method to add validation after Kamihi's built-in validation. Raising a ValueError indicates an invalid response, and the error message will be sent to the user.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The response from the user.</p> required <code>Update</code> <p>The update object. Defaults to None.</p> <code>None</code> <code>CallbackContext</code> <p>The callback context. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The further validated response, which can be of any type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the response is invalid.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>async def validate_after(  # skipcq: PYL-R0201\n    self,\n    response: Any,\n    update: Update | None = None,\n    context: CallbackContext | None = None,\n) -&gt; Any:\n    \"\"\"\n    Validate the user's response after Kamihi's built-in validation.\n\n    Override this method to add validation after Kamihi's built-in validation. Raising a ValueError indicates an invalid\n    response, and the error message will be sent to the user.\n\n    Args:\n        response (Any): The response from the user.\n        update (Update, optional): The update object. Defaults to None.\n        context (CallbackContext, optional): The callback context. Defaults to None.\n\n    Returns:\n        Any: The further validated response, which can be of any type.\n\n    Raises:\n        ValueError: If the response is invalid.\n\n    \"\"\"\n    return response\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Question.validate_after(response)","title":"<code>response</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.validate_after(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.validate_after(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.validate_before","title":"validate_before  <code>async</code>","text":"<pre><code>validate_before(\n    response: Any,\n    update: Update | None = None,\n    context: CallbackContext | None = None,\n) -&gt; Any\n</code></pre> <p>Validate the user's response before Kamihi's built-in validation.</p> <p>Override this method to add validation before Kamihi's built-in validation. Raising a ValueError indicates an invalid response, and the error message will be sent to the user.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The response from the user.</p> required <code>Update</code> <p>The update object. Defaults to None.</p> <code>None</code> <code>CallbackContext</code> <p>The callback context. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The further validated response, which can be of any type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the response is invalid.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>async def validate_before(  # skipcq: PYL-R0201\n    self,\n    response: Any,\n    update: Update | None = None,\n    context: CallbackContext | None = None,\n) -&gt; Any:\n    \"\"\"\n    Validate the user's response before Kamihi's built-in validation.\n\n    Override this method to add validation before Kamihi's built-in validation. Raising a ValueError indicates an invalid\n    response, and the error message will be sent to the user.\n\n    Args:\n        response (Any): The response from the user.\n        update (Update, optional): The update object. Defaults to None.\n        context (CallbackContext, optional): The callback context. Defaults to None.\n\n    Returns:\n        Any: The further validated response, which can be of any type.\n\n    Raises:\n        ValueError: If the response is invalid.\n\n    \"\"\"\n    return response\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Question.validate_before(response)","title":"<code>response</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.validate_before(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.validate_before(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.with_action","title":"with_action","text":"<pre><code>with_action(param_name: str, logger: Logger) -&gt; Question\n</code></pre> <p>Set the parameter name for the question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name of the parameter.</p> required <code>Logger</code> <p>The action's logger.</p> required <p>Returns:</p> Name Type Description <code>Question</code> <code>Question</code> <p>The question instance with the parameter name set.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>def with_action(self, param_name: str, logger: loguru.Logger) -&gt; Question:\n    \"\"\"\n    Set the parameter name for the question.\n\n    Args:\n        param_name (str): The name of the parameter.\n        logger (loguru.Logger): The action's logger.\n\n    Returns:\n        Question: The question instance with the parameter name set.\n\n    \"\"\"\n    self._param_name = param_name\n    self._logger = logger.bind(param=param_name, type=self.__class__.__name__)\n    return self\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.Question.with_action(param_name)","title":"<code>param_name</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Question.with_action(logger)","title":"<code>logger</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.String","title":"String","text":"<pre><code>String(\n    text: str,\n    error_text: str = None,\n    pattern: str | None = None,\n    min_length: int | None = None,\n    max_length: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Question</code></p> <p>Generic string reusable question.</p> <p>Initialize an instance of the String question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a value from settings.</p> <code>None</code> <code>str | None</code> <p>A regex pattern that the response must match. Defaults to None.</p> <code>None</code> <code>int | None</code> <p>The minimum length of the string. Defaults to None.</p> <code>None</code> <code>int | None</code> <p>The maximum length of the string. Defaults to</p> <code>None</code> Source code in <code>src/kamihi/questions/string.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    error_text: str = None,\n    pattern: str | None = None,\n    min_length: int | None = None,\n    max_length: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the String question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        pattern (str | None, optional): A regex pattern that the response must match. Defaults to None.\n        min_length (int | None, optional): The minimum length of the string. Defaults to None.\n        max_length (int | None, optional): The maximum length of the string. Defaults to\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    self.pattern = pattern\n    self.min_length = min_length\n    self.max_length = max_length\n</code></pre>"},{"location":"reference/kamihi/questions/#kamihi.questions.String(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.String(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.String(pattern)","title":"<code>pattern</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.String(min_length)","title":"<code>min_length</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.String(max_length)","title":"<code>max_length</code>","text":""},{"location":"reference/kamihi/questions/#kamihi.questions.Time","title":"Time","text":"<pre><code>Time(\n    text: str,\n    error_text: str = None,\n    before: datetime | None = None,\n    after: datetime | None = None,\n    in_the_past: bool = False,\n    in_the_future: bool = False,\n)\n</code></pre> <p>               Bases: <code>Datetime</code></p> <p>Generic time reusable question.</p> Source code in <code>src/kamihi/questions/datetime.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    error_text: str = None,\n    before: datetime | None = None,\n    after: datetime | None = None,\n    in_the_past: bool = False,  # noqa: FBT001, FBT002\n    in_the_future: bool = False,  # noqa: FBT001, FBT002\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the Datetime question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        before (datetime | None, optional): The latest acceptable date (exclusive). Defaults to None.\n        after (datetime | None, optional): The earliest acceptable date (exclusive). Defaults to None\n        in_the_past (bool, optional): Whether the date must be in the past. Defaults to False.\n        in_the_future (bool, optional): Whether the date must be in the future. Defaults to False.\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    self.before = before\n    if self.before and not before.tzinfo:\n        self.before = before.replace(tzinfo=get_settings().timezone_obj)\n\n    self.after = after\n    if self.after and not after.tzinfo:\n        self.after = after.replace(tzinfo=get_settings().timezone_obj)\n\n    self.in_the_past = in_the_past\n    self.in_the_future = in_the_future\n</code></pre>"},{"location":"reference/kamihi/questions/bool/","title":"bool","text":""},{"location":"reference/kamihi/questions/bool/#kamihi.questions.bool","title":"kamihi.questions.bool","text":"<p>Generic boolean reusable question.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>Bool</code> <p>Generic boolean reusable question.</p>"},{"location":"reference/kamihi/questions/bool/#kamihi.questions.bool.Bool","title":"Bool","text":"<pre><code>Bool(\n    text: str,\n    error_text: str = None,\n    true_values: set[str] = None,\n    false_values: set[str] = None,\n)\n</code></pre> <p>               Bases: <code>Question</code></p> <p>Generic boolean reusable question.</p> <p>Initialize an instance of the Bool question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a value from settings.</p> <code>None</code> <code>set[str]</code> <p>A set of strings that represent true values. Defaults to a value from settings.</p> <code>None</code> <code>set[str]</code> <p>A set of strings that represent false values. Defaults to a value from settings.</p> <code>None</code> Source code in <code>src/kamihi/questions/bool.py</code> <pre><code>def __init__(\n    self, text: str, error_text: str = None, true_values: set[str] = None, false_values: set[str] = None\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the Bool question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        true_values (set[str], optional): A set of strings that represent true values. Defaults to a value from settings.\n        false_values (set[str], optional): A set of strings that represent false values. Defaults to a value from settings.\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    if true_values is not None:\n        self.true_values.update(true_values)\n\n    if false_values is not None:\n        self.false_values.update(false_values)\n</code></pre>"},{"location":"reference/kamihi/questions/bool/#kamihi.questions.bool.Bool(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/bool/#kamihi.questions.bool.Bool(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/bool/#kamihi.questions.bool.Bool(true_values)","title":"<code>true_values</code>","text":""},{"location":"reference/kamihi/questions/bool/#kamihi.questions.bool.Bool(false_values)","title":"<code>false_values</code>","text":""},{"location":"reference/kamihi/questions/choice/","title":"choice","text":""},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice","title":"kamihi.questions.choice","text":"<p>Generic choice reusable question.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>Choice</code> <p>Generic choice reusable question.</p>"},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice","title":"Choice","text":"<pre><code>Choice(\n    text: str,\n    choices: dict[str, Any]\n    | Iterable[str | tuple[str, Any]]\n    | Callable,\n    error_text: str = None,\n    reply_type: Literal[\n        \"simple\", \"keyboard\", \"inline\"\n    ] = \"simple\",\n    cols: int = 1,\n)\n</code></pre> <p>               Bases: <code>Question</code></p> <p>Generic choice reusable question.</p> <p>Initialize an instance of a multiple-choice question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>dict[str, Any] | Iterable[str | tuple[str, Any]]</code> <p>The available choices for the question. Can be one of: - A dictionary mapping display text to return values. - An iterable of strings (where each string is both the display text and return value). - An iterable of tuples (where each tuple contains display text and return value). - A callable that returns one of the above.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a value from settings.</p> <code>None</code> <code>Literal['simple', 'keyboard', 'inline']</code> <p>The type of choice question. Defaults to \"simple\".</p> <code>'simple'</code> <code>int</code> <p>The number of columns for keyboard or inline button layouts. Defaults to 1.</p> <code>1</code> <p>Methods:</p> Name Description <code>ask_question</code> <p>Ask the choice question to the user.</p> <code>get_response</code> <p>Get the response from the user.</p> <code>handler</code> <p>Return the handler for the answer to the question.</p> <p>Attributes:</p> Name Type Description <code>choices</code> <code>dict[str, Any]</code> <p>Get the available choices for the question.</p> Source code in <code>src/kamihi/questions/choice.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    choices: dict[str, Any] | Iterable[str | tuple[str, Any]] | Callable,\n    error_text: str = None,\n    reply_type: Literal[\"simple\", \"keyboard\", \"inline\"] = \"simple\",\n    cols: int = 1,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of a multiple-choice question.\n\n    Args:\n        text (str): The text of the question.\n        choices (dict[str, Any] | Iterable[str | tuple[str, Any]]): The available choices for the question. Can be one of:\n            - A dictionary mapping display text to return values.\n            - An iterable of strings (where each string is both the display text and return value).\n            - An iterable of tuples (where each tuple contains display text and return value).\n            - A callable that returns one of the above.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        reply_type (Literal[\"simple\", \"keyboard\", \"inline\"], optional): The type of choice question. Defaults to \"simple\".\n        cols (int, optional): The number of columns for keyboard or inline button layouts. Defaults to 1.\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    if isinstance(choices, dict) or callable(choices):\n        self._choices = choices\n    else:\n        self._choices = {}\n        for choice in choices:\n            if isinstance(choice, tuple):\n                display_text, return_value = choice\n                self._choices[display_text] = return_value\n            else:\n                self._choices[choice] = choice\n\n    self.reply_type = reply_type\n    self.cols = max(1, cols)\n</code></pre>"},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice(choices)","title":"<code>choices</code>","text":""},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice(reply_type)","title":"<code>reply_type</code>","text":""},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice(cols)","title":"<code>cols</code>","text":""},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice.choices","title":"choices  <code>property</code>","text":"<pre><code>choices: dict[str, Any]\n</code></pre> <p>Get the available choices for the question.</p>"},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice.ask_question","title":"ask_question  <code>async</code>","text":"<pre><code>ask_question(\n    update: Update, context: CallbackContext\n) -&gt; None\n</code></pre> <p>Ask the choice question to the user.</p> <p>Override this method to customize how the question is asked based on the reply type.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required Source code in <code>src/kamihi/questions/choice.py</code> <pre><code>async def ask_question(self, update: Update, context: CallbackContext) -&gt; None:\n    \"\"\"\n    Ask the choice question to the user.\n\n    Override this method to customize how the question is asked based on the reply type.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    \"\"\"\n    reply_markup = None\n    match self.reply_type:\n        case \"keyboard\":\n            keyboard = [\n                list(list(self.choices.keys())[i : i + self.cols]) for i in range(0, len(self.choices), self.cols)\n            ]\n            reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)\n        case \"inline\":\n            keyboard = [\n                [\n                    InlineKeyboardButton(choice, callback_data=self._param_name + \"_\" + choice)\n                    for choice in list(self.choices.keys())[i : i + self.cols]\n                ]\n                for i in range(0, len(self.choices), self.cols)\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n    await send(self.question_text, update, context, reply_markup)\n</code></pre>"},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice.ask_question(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice.ask_question(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice.get_response","title":"get_response  <code>async</code>","text":"<pre><code>get_response(\n    update: Update, context: CallbackContext\n) -&gt; Any\n</code></pre> <p>Get the response from the user.</p> <p>Override this method to customize how the response is retrieved from the update and/or context.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The response from the user, which can be of any type.</p> Source code in <code>src/kamihi/questions/choice.py</code> <pre><code>async def get_response(self, update: Update, context: CallbackContext) -&gt; Any:\n    \"\"\"\n    Get the response from the user.\n\n    Override this method to customize how the response is retrieved from the update and/or context.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    Returns:\n        Any: The response from the user, which can be of any type.\n\n    \"\"\"\n    match self.reply_type:\n        case \"simple\":\n            return update.message.text\n        case \"keyboard\":\n            msg = await send(\n                get_settings().questions.remove_keyboard_text, update, context, reply_markup=ReplyKeyboardRemove()\n            )\n            await msg.delete()\n            return update.message.text\n        case \"inline\":\n            await context.bot.answer_callback_query(callback_query_id=update.callback_query.id)\n            return update.callback_query.data.removeprefix(self._param_name + \"_\")\n</code></pre>"},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice.get_response(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice.get_response(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice.handler","title":"handler","text":"<pre><code>handler(\n    func: Callable[\n        [Update, CallbackContext], Coroutine[Any, Any, Any]\n    ],\n) -&gt; MessageHandler | CallbackQueryHandler\n</code></pre> <p>Return the handler for the answer to the question.</p> <p>Do not override this method. Instead, override the <code>filters</code> property to customize the filters used.</p> <p>Parameters:</p> Name Type Description Default <code>Callable</code> <p>The function to handle the user's response.</p> required <p>Returns:</p> Name Type Description <code>MessageHandler</code> <code>MessageHandler | CallbackQueryHandler</code> <p>The handler for the answer to the question.</p> Source code in <code>src/kamihi/questions/choice.py</code> <pre><code>def handler(\n    self, func: Callable[[Update, CallbackContext], Coroutine[Any, Any, Any]]\n) -&gt; MessageHandler | CallbackQueryHandler:\n    \"\"\"\n    Return the handler for the answer to the question.\n\n    Do not override this method. Instead, override the `filters` property to customize the filters used.\n\n    Args:\n        func (Callable): The function to handle the user's response.\n\n    Returns:\n        MessageHandler: The handler for the answer to the question.\n\n    \"\"\"\n    if self.reply_type == \"inline\":\n        return CallbackQueryHandler(func, pattern=rf\"^{self._param_name}_\")\n    return MessageHandler(self.filters, func)\n</code></pre>"},{"location":"reference/kamihi/questions/choice/#kamihi.questions.choice.Choice.handler(func)","title":"<code>func</code>","text":""},{"location":"reference/kamihi/questions/date/","title":"date","text":""},{"location":"reference/kamihi/questions/date/#kamihi.questions.date","title":"kamihi.questions.date","text":"<p>Generic date reusable question.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>Date</code> <p>Generic date reusable question.</p>"},{"location":"reference/kamihi/questions/date/#kamihi.questions.date.Date","title":"Date","text":"<pre><code>Date(\n    text: str,\n    error_text: str = None,\n    before: date | None = None,\n    after: date | None = None,\n    in_the_past: bool = False,\n    in_the_future: bool = False,\n)\n</code></pre> <p>               Bases: <code>Datetime</code></p> <p>Generic date reusable question.</p> <p>Initialize an instance of the Date question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a value from settings.</p> <code>None</code> <code>date | None</code> <p>The latest acceptable date (exclusive). Defaults to None.</p> <code>None</code> <code>date | None</code> <p>The earliest acceptable date (exclusive). Defaults to None</p> <code>None</code> <code>bool</code> <p>Whether the date must be in the past. Defaults to False.</p> <code>False</code> <code>bool</code> <p>Whether the date must be in the future. Defaults to False.</p> <code>False</code> Source code in <code>src/kamihi/questions/date.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    error_text: str = None,\n    before: date | None = None,\n    after: date | None = None,\n    in_the_past: bool = False,  # noqa: FBT001, FBT002\n    in_the_future: bool = False,  # noqa: FBT001, FBT002\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the Date question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        before (date | None, optional): The latest acceptable date (exclusive). Defaults to None.\n        after (date | None, optional): The earliest acceptable date (exclusive). Defaults to None\n        in_the_past (bool, optional): Whether the date must be in the past. Defaults to False.\n        in_the_future (bool, optional): Whether the date must be in the future. Defaults to False.\n\n    \"\"\"\n    super().__init__(\n        text=text,\n        error_text=error_text,\n        before=None if before is None else datetime.combine(before, datetime.min.time()),\n        after=None if after is None else datetime.combine(after, datetime.min.time()),\n        in_the_past=in_the_past,\n        in_the_future=in_the_future,\n    )\n</code></pre>"},{"location":"reference/kamihi/questions/date/#kamihi.questions.date.Date(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/date/#kamihi.questions.date.Date(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/date/#kamihi.questions.date.Date(before)","title":"<code>before</code>","text":""},{"location":"reference/kamihi/questions/date/#kamihi.questions.date.Date(after)","title":"<code>after</code>","text":""},{"location":"reference/kamihi/questions/date/#kamihi.questions.date.Date(in_the_past)","title":"<code>in_the_past</code>","text":""},{"location":"reference/kamihi/questions/date/#kamihi.questions.date.Date(in_the_future)","title":"<code>in_the_future</code>","text":""},{"location":"reference/kamihi/questions/datetime/","title":"datetime","text":""},{"location":"reference/kamihi/questions/datetime/#kamihi.questions.datetime","title":"kamihi.questions.datetime","text":"<p>Generic datetime reusable question.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>Datetime</code> <p>Generic date reusable question.</p>"},{"location":"reference/kamihi/questions/datetime/#kamihi.questions.datetime.Datetime","title":"Datetime","text":"<pre><code>Datetime(\n    text: str,\n    error_text: str = None,\n    before: datetime | None = None,\n    after: datetime | None = None,\n    in_the_past: bool = False,\n    in_the_future: bool = False,\n)\n</code></pre> <p>               Bases: <code>Question</code></p> <p>Generic date reusable question.</p> <p>Initialize an instance of the Datetime question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a value from settings.</p> <code>None</code> <code>datetime | None</code> <p>The latest acceptable date (exclusive). Defaults to None.</p> <code>None</code> <code>datetime | None</code> <p>The earliest acceptable date (exclusive). Defaults to None</p> <code>None</code> <code>bool</code> <p>Whether the date must be in the past. Defaults to False.</p> <code>False</code> <code>bool</code> <p>Whether the date must be in the future. Defaults to False.</p> <code>False</code> Source code in <code>src/kamihi/questions/datetime.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    error_text: str = None,\n    before: datetime | None = None,\n    after: datetime | None = None,\n    in_the_past: bool = False,  # noqa: FBT001, FBT002\n    in_the_future: bool = False,  # noqa: FBT001, FBT002\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the Datetime question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        before (datetime | None, optional): The latest acceptable date (exclusive). Defaults to None.\n        after (datetime | None, optional): The earliest acceptable date (exclusive). Defaults to None\n        in_the_past (bool, optional): Whether the date must be in the past. Defaults to False.\n        in_the_future (bool, optional): Whether the date must be in the future. Defaults to False.\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    self.before = before\n    if self.before and not before.tzinfo:\n        self.before = before.replace(tzinfo=get_settings().timezone_obj)\n\n    self.after = after\n    if self.after and not after.tzinfo:\n        self.after = after.replace(tzinfo=get_settings().timezone_obj)\n\n    self.in_the_past = in_the_past\n    self.in_the_future = in_the_future\n</code></pre>"},{"location":"reference/kamihi/questions/datetime/#kamihi.questions.datetime.Datetime(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/datetime/#kamihi.questions.datetime.Datetime(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/datetime/#kamihi.questions.datetime.Datetime(before)","title":"<code>before</code>","text":""},{"location":"reference/kamihi/questions/datetime/#kamihi.questions.datetime.Datetime(after)","title":"<code>after</code>","text":""},{"location":"reference/kamihi/questions/datetime/#kamihi.questions.datetime.Datetime(in_the_past)","title":"<code>in_the_past</code>","text":""},{"location":"reference/kamihi/questions/datetime/#kamihi.questions.datetime.Datetime(in_the_future)","title":"<code>in_the_future</code>","text":""},{"location":"reference/kamihi/questions/dynamic_choice/","title":"dynamic_choice","text":""},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice","title":"kamihi.questions.dynamic_choice","text":"<p>Generic dynamic choice reusable question.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>DynamicChoice</code> <p>Generic dynamic choice reusable question.</p>"},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice","title":"DynamicChoice","text":"<pre><code>DynamicChoice(\n    text: str,\n    request: str | Path = None,\n    error_text: str = None,\n    reply_type: Literal[\n        \"simple\", \"keyboard\", \"inline\"\n    ] = \"simple\",\n    cols: int = 1,\n)\n</code></pre> <p>               Bases: <code>Question</code></p> <p>Generic dynamic choice reusable question.</p> <p>Initialize an instance of a multiple-choice question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str | Path</code> <p>The name of the request file from which the choices will be obtained.</p> <code>None</code> <code>str</code> <p>The error text to display for invalid responses. Defaults to a value from settings.</p> <code>None</code> <code>Literal['simple', 'keyboard', 'inline']</code> <p>The type of choice question. Defaults to \"simple\".</p> <code>'simple'</code> <code>int</code> <p>The number of columns for keyboard or inline button layouts. Defaults to 1.</p> <code>1</code> <p>Methods:</p> Name Description <code>ask_question</code> <p>Ask the choice question to the user, fetching dynamic choices.</p> <code>get_choices</code> <p>Get the available choices for the question and save them in chat_data.</p> <code>get_response</code> <p>Get the response from the user.</p> <code>handler</code> <p>Return the handler for the answer to the question.</p> Source code in <code>src/kamihi/questions/dynamic_choice.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    request: str | Path = None,\n    error_text: str = None,\n    reply_type: Literal[\"simple\", \"keyboard\", \"inline\"] = \"simple\",\n    cols: int = 1,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of a multiple-choice question.\n\n    Args:\n        text (str): The text of the question.\n        request (str | Path): The name of the request file from which the choices will be obtained.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        reply_type (Literal[\"simple\", \"keyboard\", \"inline\"], optional): The type of choice question. Defaults to \"simple\".\n        cols (int, optional): The number of columns for keyboard or inline button layouts. Defaults to 1.\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    if not hasattr(self, \"request\") and request:\n        self.request = request if isinstance(request, Path) else Path(request)\n    elif not hasattr(self, \"request\"):\n        raise ValueError(\"A request file must be provided for DynamicChoice questions.\")\n\n    if not self.request.is_absolute():\n        self.request = Path.cwd() / \"questions\" / self.request\n\n    self.reply_type = reply_type\n    self.cols = max(1, cols)\n</code></pre>"},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice(request)","title":"<code>request</code>","text":""},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice(reply_type)","title":"<code>reply_type</code>","text":""},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice(cols)","title":"<code>cols</code>","text":""},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice.ask_question","title":"ask_question  <code>async</code>","text":"<pre><code>ask_question(\n    update: Update, context: CallbackContext\n) -&gt; None\n</code></pre> <p>Ask the choice question to the user, fetching dynamic choices.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required Source code in <code>src/kamihi/questions/dynamic_choice.py</code> <pre><code>async def ask_question(self, update: Update, context: CallbackContext) -&gt; None:\n    \"\"\"\n    Ask the choice question to the user, fetching dynamic choices.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    \"\"\"\n    choices = await self.get_choices(context)\n\n    reply_markup = None\n    match self.reply_type:\n        case \"keyboard\":\n            keyboard = [list(list(choices.keys())[i : i + self.cols]) for i in range(0, len(choices), self.cols)]\n            reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)\n        case \"inline\":\n            keyboard = [\n                [\n                    InlineKeyboardButton(choice, callback_data=self._param_name + \"_\" + choice)\n                    for choice in list(choices.keys())[i : i + self.cols]\n                ]\n                for i in range(0, len(choices), self.cols)\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n    await send(self.question_text, update, context, reply_markup)\n</code></pre>"},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice.ask_question(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice.ask_question(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice.get_choices","title":"get_choices  <code>async</code>","text":"<pre><code>get_choices(context: CallbackContext) -&gt; dict[str, Any]\n</code></pre> <p>Get the available choices for the question and save them in chat_data.</p> <p>Parameters:</p> Name Type Description Default <code>CallbackContext</code> <p>The callback context.</p> required Source code in <code>src/kamihi/questions/dynamic_choice.py</code> <pre><code>async def get_choices(self, context: CallbackContext) -&gt; dict[str, Any]:\n    \"\"\"\n    Get the available choices for the question and save them in chat_data.\n\n    Args:\n        context (CallbackContext): The callback context.\n\n    \"\"\"\n    datasources: dict[str, DataSource] = context.bot_data.get(\"datasources\", {})\n    ds = datasources[self.request.stem.split(\".\")[-1]]\n    res = await ds.fetch(self.request)\n    choices = {}\n    for row in res:\n        if len(row) &gt;= 2:\n            choices[str(row[0]).strip()] = row[1]\n        elif len(row) == 1:\n            choices[str(row[0]).strip()] = row[0]\n\n    context.chat_data[\"questions\"][self._param_name] = choices\n    return choices\n</code></pre>"},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice.get_choices(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice.get_response","title":"get_response  <code>async</code>","text":"<pre><code>get_response(\n    update: Update, context: CallbackContext\n) -&gt; Any\n</code></pre> <p>Get the response from the user.</p> <p>Override this method to customize how the response is retrieved from the update and/or context.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The response from the user, which can be of any type.</p> Source code in <code>src/kamihi/questions/dynamic_choice.py</code> <pre><code>async def get_response(self, update: Update, context: CallbackContext) -&gt; Any:\n    \"\"\"\n    Get the response from the user.\n\n    Override this method to customize how the response is retrieved from the update and/or context.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    Returns:\n        Any: The response from the user, which can be of any type.\n\n    \"\"\"\n    match self.reply_type:\n        case \"simple\":\n            return update.message.text\n        case \"keyboard\":\n            msg = await send(\n                get_settings().questions.remove_keyboard_text, update, context, reply_markup=ReplyKeyboardRemove()\n            )\n            await msg.delete()\n            return update.message.text\n        case \"inline\":\n            await context.bot.answer_callback_query(callback_query_id=update.callback_query.id)\n            return update.callback_query.data.removeprefix(self._param_name + \"_\")\n</code></pre>"},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice.get_response(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice.get_response(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice.handler","title":"handler","text":"<pre><code>handler(\n    func: Callable[\n        [Update, CallbackContext], Coroutine[Any, Any, Any]\n    ],\n) -&gt; MessageHandler | CallbackQueryHandler\n</code></pre> <p>Return the handler for the answer to the question.</p> <p>Do not override this method. Instead, override the <code>filters</code> property to customize the filters used.</p> <p>Parameters:</p> Name Type Description Default <code>Callable</code> <p>The function to handle the user's response.</p> required <p>Returns:</p> Name Type Description <code>MessageHandler</code> <code>MessageHandler | CallbackQueryHandler</code> <p>The handler for the answer to the question.</p> Source code in <code>src/kamihi/questions/dynamic_choice.py</code> <pre><code>def handler(\n    self, func: Callable[[Update, CallbackContext], Coroutine[Any, Any, Any]]\n) -&gt; MessageHandler | CallbackQueryHandler:\n    \"\"\"\n    Return the handler for the answer to the question.\n\n    Do not override this method. Instead, override the `filters` property to customize the filters used.\n\n    Args:\n        func (Callable): The function to handle the user's response.\n\n    Returns:\n        MessageHandler: The handler for the answer to the question.\n\n    \"\"\"\n    if self.reply_type == \"inline\":\n        return CallbackQueryHandler(func, pattern=rf\"^{self._param_name}_\")\n    return MessageHandler(self.filters, func)\n</code></pre>"},{"location":"reference/kamihi/questions/dynamic_choice/#kamihi.questions.dynamic_choice.DynamicChoice.handler(func)","title":"<code>func</code>","text":""},{"location":"reference/kamihi/questions/file/","title":"file","text":""},{"location":"reference/kamihi/questions/file/#kamihi.questions.file","title":"kamihi.questions.file","text":"<p>Generic file reusable question.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>File</code> <p>Generic file reusable question.</p>"},{"location":"reference/kamihi/questions/file/#kamihi.questions.file.File","title":"File","text":"<pre><code>File(\n    text: str,\n    error_text: str = None,\n    return_as: Literal[\"path\", \"bytes\"] = \"path\",\n    max_size: int = None,\n    allowed_extensions: list[str] = None,\n    allowed_mime_types: list[str] = None,\n)\n</code></pre> <p>               Bases: <code>Question</code></p> <p>Generic file reusable question.</p> <p>Initialize an instance of the File question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a preset message.</p> <code>None</code> <code>Literal['path', 'bytes']</code> <p>The format in which to return the file. Defaults to \"path\".</p> <code>'path'</code> <code>int</code> <p>The maximum allowed file size in bytes. Defaults to FileSizeLimit.FILESIZE_DOWNLOAD.</p> <code>None</code> <code>list[str]</code> <p>List of allowed file extensions (without leading dot!). Defaults to an empty list.</p> <code>None</code> <code>list[str]</code> <p>List of allowed MIME types. Defaults to an empty list.</p> <code>None</code> <p>Methods:</p> Name Description <code>cast</code> <p>Convert the saved file path to the desired return type.</p> <code>get_response</code> <p>Extract and validate the file from the user's response.</p> <p>Attributes:</p> Name Type Description <code>filters</code> <code>BaseFilter</code> <p>Return the filters for the answer to the file question.</p> Source code in <code>src/kamihi/questions/file.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    error_text: str = None,\n    return_as: Literal[\"path\", \"bytes\"] = \"path\",\n    max_size: int = None,\n    allowed_extensions: list[str] = None,\n    allowed_mime_types: list[str] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the File question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a preset message.\n        return_as (Literal[\"path\", \"bytes\"], optional): The format in which to return the file. Defaults to \"path\".\n        max_size (int, optional): The maximum allowed file size in bytes. Defaults to FileSizeLimit.FILESIZE_DOWNLOAD.\n        allowed_extensions (list[str], optional): List of allowed file extensions (without leading dot!). Defaults to an empty list.\n        allowed_mime_types (list[str], optional): List of allowed MIME types. Defaults to an empty list.\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    if max_size is not None:\n        self.max_size = max_size\n\n    if allowed_extensions is not None:\n        if any(ext.endswith(\".\") for ext in allowed_extensions):\n            raise ValueError(\"File extensions must not end with a dot (e.g., use 'pdf' instead of 'pdf.').\")\n        self.allowed_extensions = list(set(allowed_extensions))\n\n    if allowed_mime_types is not None:\n        self.allowed_mime_types = list(set(allowed_mime_types))\n\n    self.return_as = return_as\n</code></pre>"},{"location":"reference/kamihi/questions/file/#kamihi.questions.file.File(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/file/#kamihi.questions.file.File(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/file/#kamihi.questions.file.File(return_as)","title":"<code>return_as</code>","text":""},{"location":"reference/kamihi/questions/file/#kamihi.questions.file.File(max_size)","title":"<code>max_size</code>","text":""},{"location":"reference/kamihi/questions/file/#kamihi.questions.file.File(allowed_extensions)","title":"<code>allowed_extensions</code>","text":""},{"location":"reference/kamihi/questions/file/#kamihi.questions.file.File(allowed_mime_types)","title":"<code>allowed_mime_types</code>","text":""},{"location":"reference/kamihi/questions/file/#kamihi.questions.file.File.filters","title":"filters  <code>property</code>","text":"<pre><code>filters: BaseFilter\n</code></pre> <p>Return the filters for the answer to the file question.</p> <p>Returns:</p> Type Description <code>BaseFilter</code> <p>filters.BaseFilter: The filters to capture valid file responses.</p>"},{"location":"reference/kamihi/questions/file/#kamihi.questions.file.File.cast","title":"cast","text":"<pre><code>cast(path: Path) -&gt; Path | bytes\n</code></pre> <p>Convert the saved file path to the desired return type.</p> <p>Parameters:</p> Name Type Description Default <code>Path</code> <p>The path to the saved file.</p> required <p>Returns:</p> Name Type Description <code>ReturnT</code> <code>Path | bytes</code> <p>The file in the desired return type (Path or bytes).</p> Source code in <code>src/kamihi/questions/file.py</code> <pre><code>def cast(self, path: Path) -&gt; Path | bytes:\n    \"\"\"\n    Convert the saved file path to the desired return type.\n\n    Args:\n        path (Path): The path to the saved file.\n\n    Returns:\n        ReturnT: The file in the desired return type (Path or bytes).\n\n    \"\"\"\n    if self.return_as == \"bytes\":\n        return path.read_bytes()\n    return path\n</code></pre>"},{"location":"reference/kamihi/questions/file/#kamihi.questions.file.File.cast(path)","title":"<code>path</code>","text":""},{"location":"reference/kamihi/questions/file/#kamihi.questions.file.File.get_response","title":"get_response  <code>async</code>","text":"<pre><code>get_response(\n    update: Update, context: CallbackContext\n) -&gt; Document\n</code></pre> <p>Extract and validate the file from the user's response.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required <p>Returns:</p> Name Type Description <code>Document</code> <code>Document</code> <p>The Telegram Document object from the update.</p> Source code in <code>src/kamihi/questions/file.py</code> <pre><code>async def get_response(self, update: Update, context: CallbackContext) -&gt; Document:\n    \"\"\"\n    Extract and validate the file from the user's response.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    Returns:\n        Document: The Telegram Document object from the update.\n\n    \"\"\"\n    return update.message.document\n</code></pre>"},{"location":"reference/kamihi/questions/file/#kamihi.questions.file.File.get_response(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/file/#kamihi.questions.file.File.get_response(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/image/","title":"image","text":""},{"location":"reference/kamihi/questions/image/#kamihi.questions.image","title":"kamihi.questions.image","text":"<p>Generic image reusable question.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>Image</code> <p>Generic image reusable question.</p>"},{"location":"reference/kamihi/questions/image/#kamihi.questions.image.Image","title":"Image","text":"<pre><code>Image(\n    text: str,\n    error_text: str = \"Please upload a valid image.\",\n    return_as: Literal[\"path\", \"bytes\", \"pil\"] = \"path\",\n    max_size: int = None,\n    allowed_extensions: list[str] = None,\n    allowed_mime_types: list[str] = None,\n)\n</code></pre> <p>               Bases: <code>File</code></p> <p>Generic image reusable question.</p> <p>Initialize an instance of the Image question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a preset message.</p> <code>'Please upload a valid image.'</code> <code>Literal['path', 'bytes', 'pil']</code> <p>The format in which to return the image. Defaults to \"path\".</p> <code>'path'</code> <code>int</code> <p>The maximum allowed file size in bytes. Defaults to FileSizeLimit.FILESIZE_DOWNLOAD.</p> <code>None</code> <code>list[str]</code> <p>List of allowed file extensions (without leading dot!). Defaults to common image formats.</p> <code>None</code> <code>list[str]</code> <p>List of allowed MIME types. Defaults to common image MIME types.</p> <code>None</code> <p>Methods:</p> Name Description <code>cast</code> <p>Convert the saved file path to the desired return type.</p> <code>get_response</code> <p>Extract and validate the file from the user's response.</p> <p>Attributes:</p> Name Type Description <code>filters</code> <code>BaseFilter</code> <p>Return the filters for the answer to the image question.</p> Source code in <code>src/kamihi/questions/image.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    error_text: str = \"Please upload a valid image.\",\n    return_as: Literal[\"path\", \"bytes\", \"pil\"] = \"path\",\n    max_size: int = None,\n    allowed_extensions: list[str] = None,\n    allowed_mime_types: list[str] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the Image question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a preset message.\n        return_as (Literal[\"path\", \"bytes\", \"pil\"], optional): The format in which to return the image. Defaults to \"path\".\n        max_size (int, optional): The maximum allowed file size in bytes. Defaults to FileSizeLimit.FILESIZE_DOWNLOAD.\n        allowed_extensions (list[str], optional): List of allowed file extensions (without leading dot!). Defaults to common image formats.\n        allowed_mime_types (list[str], optional): List of allowed MIME types. Defaults to common image MIME types.\n\n    \"\"\"\n    super().__init__(\n        text,\n        error_text=error_text,\n        return_as=\"path\",\n        max_size=max_size,\n        allowed_extensions=allowed_extensions,\n        allowed_mime_types=allowed_mime_types,\n    )\n    self.return_as = return_as\n</code></pre>"},{"location":"reference/kamihi/questions/image/#kamihi.questions.image.Image(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/image/#kamihi.questions.image.Image(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/image/#kamihi.questions.image.Image(return_as)","title":"<code>return_as</code>","text":""},{"location":"reference/kamihi/questions/image/#kamihi.questions.image.Image(max_size)","title":"<code>max_size</code>","text":""},{"location":"reference/kamihi/questions/image/#kamihi.questions.image.Image(allowed_extensions)","title":"<code>allowed_extensions</code>","text":""},{"location":"reference/kamihi/questions/image/#kamihi.questions.image.Image(allowed_mime_types)","title":"<code>allowed_mime_types</code>","text":""},{"location":"reference/kamihi/questions/image/#kamihi.questions.image.Image.filters","title":"filters  <code>property</code>","text":"<pre><code>filters: BaseFilter\n</code></pre> <p>Return the filters for the answer to the image question.</p>"},{"location":"reference/kamihi/questions/image/#kamihi.questions.image.Image.cast","title":"cast","text":"<pre><code>cast(path: Path) -&gt; Path | bytes | PILImage.Image\n</code></pre> <p>Convert the saved file path to the desired return type.</p> <p>Parameters:</p> Name Type Description Default <code>Path</code> <p>The path to the saved file.</p> required <p>Returns:</p> Name Type Description <code>ReturnT</code> <code>Path | bytes | Image</code> <p>The file in the desired return type (Path or bytes).</p> Source code in <code>src/kamihi/questions/image.py</code> <pre><code>def cast(self, path: Path) -&gt; Path | bytes | PILImage.Image:\n    \"\"\"\n    Convert the saved file path to the desired return type.\n\n    Args:\n        path (Path): The path to the saved file.\n\n    Returns:\n        ReturnT: The file in the desired return type (Path or bytes).\n\n    \"\"\"\n    if self.return_as == \"bytes\":\n        return path.read_bytes()\n    if self.return_as == \"pil\":\n        return PILImage.open(path)\n    return path\n</code></pre>"},{"location":"reference/kamihi/questions/image/#kamihi.questions.image.Image.cast(path)","title":"<code>path</code>","text":""},{"location":"reference/kamihi/questions/image/#kamihi.questions.image.Image.get_response","title":"get_response  <code>async</code>","text":"<pre><code>get_response(\n    update: Update, context: CallbackContext\n) -&gt; PhotoSize\n</code></pre> <p>Extract and validate the file from the user's response.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required <p>Returns:</p> Name Type Description <code>Document</code> <code>PhotoSize</code> <p>The Telegram Document object from the update.</p> Source code in <code>src/kamihi/questions/image.py</code> <pre><code>async def get_response(self, update: Update, context: CallbackContext) -&gt; PhotoSize:\n    \"\"\"\n    Extract and validate the file from the user's response.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    Returns:\n        Document: The Telegram Document object from the update.\n\n    \"\"\"\n    return update.message.photo[-1]\n</code></pre>"},{"location":"reference/kamihi/questions/image/#kamihi.questions.image.Image.get_response(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/image/#kamihi.questions.image.Image.get_response(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/integer/","title":"integer","text":""},{"location":"reference/kamihi/questions/integer/#kamihi.questions.integer","title":"kamihi.questions.integer","text":"<p>Generic integer reusable question.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>Integer</code> <p>Generic integer reusable question.</p>"},{"location":"reference/kamihi/questions/integer/#kamihi.questions.integer.Integer","title":"Integer","text":"<pre><code>Integer(\n    text: str,\n    error_text: str = None,\n    le: int | None = None,\n    ge: int | None = None,\n    lt: int | None = None,\n    gt: int | None = None,\n    multiple_of: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Question</code></p> <p>Generic integer reusable question.</p> <p>Initialize an instance of the Integer question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a value from settings.</p> <code>None</code> <code>int | None</code> <p>The maximum acceptable value (exclusive). Defaults to None.</p> <code>None</code> <code>int | None</code> <p>The minimum acceptable value (exclusive). Defaults to None</p> <code>None</code> <code>int | None</code> <p>The maximum acceptable value (inclusive). Defaults to None.</p> <code>None</code> <code>int | None</code> <p>The minimum acceptable value (inclusive). Defaults to None</p> <code>None</code> <code>int | None</code> <p>The value must be a multiple of this number. Defaults to None.</p> <code>None</code> Source code in <code>src/kamihi/questions/integer.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    error_text: str = None,\n    le: int | None = None,\n    ge: int | None = None,\n    lt: int | None = None,\n    gt: int | None = None,\n    multiple_of: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the Integer question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        le (int | None, optional): The maximum acceptable value (exclusive). Defaults to None.\n        ge (int | None, optional): The minimum acceptable value (exclusive). Defaults to None\n        lt (int | None, optional): The maximum acceptable value (inclusive). Defaults to None.\n        gt (int | None, optional): The minimum acceptable value (inclusive). Defaults to None\n        multiple_of (int | None, optional): The value must be a multiple of this number. Defaults to None.\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    self.le = le\n    self.ge = ge\n    self.lt = lt\n    self.gt = gt\n    self.multiple_of = multiple_of\n</code></pre>"},{"location":"reference/kamihi/questions/integer/#kamihi.questions.integer.Integer(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/integer/#kamihi.questions.integer.Integer(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/integer/#kamihi.questions.integer.Integer(le)","title":"<code>le</code>","text":""},{"location":"reference/kamihi/questions/integer/#kamihi.questions.integer.Integer(ge)","title":"<code>ge</code>","text":""},{"location":"reference/kamihi/questions/integer/#kamihi.questions.integer.Integer(lt)","title":"<code>lt</code>","text":""},{"location":"reference/kamihi/questions/integer/#kamihi.questions.integer.Integer(gt)","title":"<code>gt</code>","text":""},{"location":"reference/kamihi/questions/integer/#kamihi.questions.integer.Integer(multiple_of)","title":"<code>multiple_of</code>","text":""},{"location":"reference/kamihi/questions/question/","title":"question","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question","title":"kamihi.questions.question","text":"<p>Base question class.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>Question</code> <p>Base class for questions.</p>"},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question","title":"Question","text":"<p>Base class for questions.</p> <p>Methods:</p> Name Description <code>ask_question</code> <p>Send the question text to the user.</p> <code>entry</code> <p>Return the entry function for the question.</p> <code>exit</code> <p>Return the exit function for the question.</p> <code>get_response</code> <p>Get the response from the user.</p> <code>handler</code> <p>Return the handler for the answer to the question.</p> <code>validate</code> <p>Validate the user's response.</p> <code>validate_after</code> <p>Validate the user's response after Kamihi's built-in validation.</p> <code>validate_before</code> <p>Validate the user's response before Kamihi's built-in validation.</p> <code>with_action</code> <p>Set the parameter name for the question.</p> <p>Attributes:</p> Name Type Description <code>filters</code> <code>BaseFilter</code> <p>Return the filters for the answer to the question.</p>"},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.filters","title":"filters  <code>property</code>","text":"<pre><code>filters: BaseFilter\n</code></pre> <p>Return the filters for the answer to the question.</p> <p>Override this method to customize the filters used to capture the user's response.</p> <p>Returns:</p> Type Description <code>BaseFilter</code> <p>filters.BaseFilter: The filters for the answer to the question.</p>"},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.ask_question","title":"ask_question  <code>async</code>","text":"<pre><code>ask_question(\n    update: Update, context: CallbackContext\n) -&gt; None\n</code></pre> <p>Send the question text to the user.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required Source code in <code>src/kamihi/questions/question.py</code> <pre><code>async def ask_question(self, update: Update, context: CallbackContext) -&gt; None:\n    \"\"\"\n    Send the question text to the user.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    \"\"\"\n    await send(self.question_text, update, context)\n</code></pre>"},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.ask_question(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.ask_question(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.entry","title":"entry","text":"<pre><code>entry(\n    current_state: int,\n    prev_exit: Callable[\n        [Update, CallbackContext], Coroutine[Any, Any, bool]\n    ]\n    | None = None,\n) -&gt; Callable[\n    [Update, CallbackContext], Coroutine[Any, Any, int]\n]\n</code></pre> <p>Return the entry function for the question.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The current state of the conversation.</p> required <code>Callable</code> <p>The exit function of the last question. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable[[Update, CallbackContext], Coroutine[Any, Any, int]]</code> <p>The entry function for the question.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>def entry(\n    self,\n    current_state: int,\n    prev_exit: Callable[[Update, CallbackContext], Coroutine[Any, Any, bool]] | None = None,\n) -&gt; Callable[[Update, CallbackContext], Coroutine[Any, Any, int]]:\n    \"\"\"\n    Return the entry function for the question.\n\n    Args:\n        current_state (int): The current state of the conversation.\n        prev_exit (Callable, optional): The exit function of the last question. Defaults to None.\n\n    Returns:\n        Callable: The entry function for the question.\n\n    \"\"\"\n\n    async def _enter(update: Update, context: CallbackContext) -&gt; int:\n        \"\"\"Entry function for the question.\"\"\"\n        self._logger.trace(\"Entered\")\n        if prev_exit:\n            self._logger.debug(\"Calling previous exit\")\n            prev_exited_successfully = await prev_exit(update, context)\n            if not prev_exited_successfully:\n                return current_state\n\n        self._logger.debug(\"Asking\")\n        await self.ask_question(update, context)\n        self._logger.trace(\"Now awaiting user response\")\n        return current_state + 1\n\n    return _enter\n</code></pre>"},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.entry(current_state)","title":"<code>current_state</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.entry(prev_exit)","title":"<code>prev_exit</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.exit","title":"exit","text":"<pre><code>exit() -&gt; Callable[\n    [Update, CallbackContext], Coroutine[Any, Any, bool]\n]\n</code></pre> <p>Return the exit function for the question.</p> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable[[Update, CallbackContext], Coroutine[Any, Any, bool]]</code> <p>The exit function for the question.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>def exit(self) -&gt; Callable[[Update, CallbackContext], Coroutine[Any, Any, bool]]:\n    \"\"\"\n    Return the exit function for the question.\n\n    Returns:\n        Callable: The exit function for the question.\n\n    \"\"\"\n\n    async def _exit(update: Update, context: CallbackContext) -&gt; bool:\n        \"\"\"Exit function for the question.\"\"\"\n        self._logger.trace(\"Starting exit\")\n        res = await self.get_response(update, context)\n\n        try:\n            res = await self.validate(res, update, context)\n            self._logger.trace(\"Validation successful\")\n        except ValueError as e:\n            self._logger.debug(\"Validation failed: {}\", e)\n            await send(str(e), update, context)\n            return False\n\n        await self._save(res, context)\n        self._logger.debug(\"Exited\")\n        return True\n\n    return _exit\n</code></pre>"},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.get_response","title":"get_response  <code>async</code>","text":"<pre><code>get_response(\n    update: Update, context: CallbackContext\n) -&gt; Any\n</code></pre> <p>Get the response from the user.</p> <p>Override this method to customize how the response is retrieved from the update and/or context.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>The update object.</p> required <code>CallbackContext</code> <p>The callback context.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The response from the user, which can be of any type.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>async def get_response(self, update: Update, context: CallbackContext) -&gt; Any:  # skipcq: PYL-R0201\n    \"\"\"\n    Get the response from the user.\n\n    Override this method to customize how the response is retrieved from the update and/or context.\n\n    Args:\n        update (Update): The update object.\n        context (CallbackContext): The callback context.\n\n    Returns:\n        Any: The response from the user, which can be of any type.\n\n    \"\"\"\n    return update.message.text\n</code></pre>"},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.get_response(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.get_response(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.handler","title":"handler","text":"<pre><code>handler(\n    func: Callable[\n        [Update, CallbackContext], Coroutine[Any, Any, Any]\n    ],\n) -&gt; MessageHandler\n</code></pre> <p>Return the handler for the answer to the question.</p> <p>Do not override this method. Instead, override the <code>filters</code> property to customize the filters used.</p> <p>Parameters:</p> Name Type Description Default <code>Callable</code> <p>The function to handle the user's response.</p> required <p>Returns:</p> Name Type Description <code>MessageHandler</code> <code>MessageHandler</code> <p>The handler for the answer to the question.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>def handler(self, func: Callable[[Update, CallbackContext], Coroutine[Any, Any, Any]]) -&gt; MessageHandler:\n    \"\"\"\n    Return the handler for the answer to the question.\n\n    Do not override this method. Instead, override the `filters` property to customize the filters used.\n\n    Args:\n        func (Callable): The function to handle the user's response.\n\n    Returns:\n        MessageHandler: The handler for the answer to the question.\n\n    \"\"\"\n    return MessageHandler(self.filters, func)\n</code></pre>"},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.handler(func)","title":"<code>func</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.validate","title":"validate  <code>async</code>","text":"<pre><code>validate(\n    response: Any,\n    update: Update | None = None,\n    context: CallbackContext | None = None,\n) -&gt; Any\n</code></pre> <p>Validate the user's response.</p> <p>This method is what unifies the validation process. It first calls <code>validate_before</code>, then performs any built-in validation (if applicable), and finally calls <code>validate_after</code>. Only override this method if you want to completely replace the validation process.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The response from the user.</p> required <code>Update</code> <p>The update object. Defaults to None.</p> <code>None</code> <code>CallbackContext</code> <p>The callback context. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The validated response, which can be of any type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the response is invalid.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>async def validate(\n    self,\n    response: Any,\n    update: Update | None = None,\n    context: CallbackContext | None = None,\n) -&gt; Any:\n    \"\"\"\n    Validate the user's response.\n\n    This method is what unifies the validation process. It first calls `validate_before`, then performs any built-in\n    validation (if applicable), and finally calls `validate_after`. Only override this method if you want to\n    completely replace the validation process.\n\n    Args:\n        response (Any): The response from the user.\n        update (Update, optional): The update object. Defaults to None.\n        context (CallbackContext, optional): The callback context. Defaults to None.\n\n    Returns:\n        Any: The validated response, which can be of any type.\n\n    Raises:\n        ValueError: If the response is invalid.\n\n    \"\"\"\n    response = await self.validate_before(response, update, context)\n    response = await self._validate_internal(response, update, context)\n    return await self.validate_after(response, update, context)\n</code></pre>"},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.validate(response)","title":"<code>response</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.validate(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.validate(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.validate_after","title":"validate_after  <code>async</code>","text":"<pre><code>validate_after(\n    response: Any,\n    update: Update | None = None,\n    context: CallbackContext | None = None,\n) -&gt; Any\n</code></pre> <p>Validate the user's response after Kamihi's built-in validation.</p> <p>Override this method to add validation after Kamihi's built-in validation. Raising a ValueError indicates an invalid response, and the error message will be sent to the user.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The response from the user.</p> required <code>Update</code> <p>The update object. Defaults to None.</p> <code>None</code> <code>CallbackContext</code> <p>The callback context. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The further validated response, which can be of any type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the response is invalid.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>async def validate_after(  # skipcq: PYL-R0201\n    self,\n    response: Any,\n    update: Update | None = None,\n    context: CallbackContext | None = None,\n) -&gt; Any:\n    \"\"\"\n    Validate the user's response after Kamihi's built-in validation.\n\n    Override this method to add validation after Kamihi's built-in validation. Raising a ValueError indicates an invalid\n    response, and the error message will be sent to the user.\n\n    Args:\n        response (Any): The response from the user.\n        update (Update, optional): The update object. Defaults to None.\n        context (CallbackContext, optional): The callback context. Defaults to None.\n\n    Returns:\n        Any: The further validated response, which can be of any type.\n\n    Raises:\n        ValueError: If the response is invalid.\n\n    \"\"\"\n    return response\n</code></pre>"},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.validate_after(response)","title":"<code>response</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.validate_after(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.validate_after(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.validate_before","title":"validate_before  <code>async</code>","text":"<pre><code>validate_before(\n    response: Any,\n    update: Update | None = None,\n    context: CallbackContext | None = None,\n) -&gt; Any\n</code></pre> <p>Validate the user's response before Kamihi's built-in validation.</p> <p>Override this method to add validation before Kamihi's built-in validation. Raising a ValueError indicates an invalid response, and the error message will be sent to the user.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The response from the user.</p> required <code>Update</code> <p>The update object. Defaults to None.</p> <code>None</code> <code>CallbackContext</code> <p>The callback context. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The further validated response, which can be of any type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the response is invalid.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>async def validate_before(  # skipcq: PYL-R0201\n    self,\n    response: Any,\n    update: Update | None = None,\n    context: CallbackContext | None = None,\n) -&gt; Any:\n    \"\"\"\n    Validate the user's response before Kamihi's built-in validation.\n\n    Override this method to add validation before Kamihi's built-in validation. Raising a ValueError indicates an invalid\n    response, and the error message will be sent to the user.\n\n    Args:\n        response (Any): The response from the user.\n        update (Update, optional): The update object. Defaults to None.\n        context (CallbackContext, optional): The callback context. Defaults to None.\n\n    Returns:\n        Any: The further validated response, which can be of any type.\n\n    Raises:\n        ValueError: If the response is invalid.\n\n    \"\"\"\n    return response\n</code></pre>"},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.validate_before(response)","title":"<code>response</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.validate_before(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.validate_before(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.with_action","title":"with_action","text":"<pre><code>with_action(param_name: str, logger: Logger) -&gt; Question\n</code></pre> <p>Set the parameter name for the question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name of the parameter.</p> required <code>Logger</code> <p>The action's logger.</p> required <p>Returns:</p> Name Type Description <code>Question</code> <code>Question</code> <p>The question instance with the parameter name set.</p> Source code in <code>src/kamihi/questions/question.py</code> <pre><code>def with_action(self, param_name: str, logger: loguru.Logger) -&gt; Question:\n    \"\"\"\n    Set the parameter name for the question.\n\n    Args:\n        param_name (str): The name of the parameter.\n        logger (loguru.Logger): The action's logger.\n\n    Returns:\n        Question: The question instance with the parameter name set.\n\n    \"\"\"\n    self._param_name = param_name\n    self._logger = logger.bind(param=param_name, type=self.__class__.__name__)\n    return self\n</code></pre>"},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.with_action(param_name)","title":"<code>param_name</code>","text":""},{"location":"reference/kamihi/questions/question/#kamihi.questions.question.Question.with_action(logger)","title":"<code>logger</code>","text":""},{"location":"reference/kamihi/questions/string/","title":"string","text":""},{"location":"reference/kamihi/questions/string/#kamihi.questions.string","title":"kamihi.questions.string","text":"<p>Generic string reusable question.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>String</code> <p>Generic string reusable question.</p>"},{"location":"reference/kamihi/questions/string/#kamihi.questions.string.String","title":"String","text":"<pre><code>String(\n    text: str,\n    error_text: str = None,\n    pattern: str | None = None,\n    min_length: int | None = None,\n    max_length: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Question</code></p> <p>Generic string reusable question.</p> <p>Initialize an instance of the String question.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The text of the question.</p> required <code>str</code> <p>The error text to display for invalid responses. Defaults to a value from settings.</p> <code>None</code> <code>str | None</code> <p>A regex pattern that the response must match. Defaults to None.</p> <code>None</code> <code>int | None</code> <p>The minimum length of the string. Defaults to None.</p> <code>None</code> <code>int | None</code> <p>The maximum length of the string. Defaults to</p> <code>None</code> Source code in <code>src/kamihi/questions/string.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    error_text: str = None,\n    pattern: str | None = None,\n    min_length: int | None = None,\n    max_length: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the String question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        pattern (str | None, optional): A regex pattern that the response must match. Defaults to None.\n        min_length (int | None, optional): The minimum length of the string. Defaults to None.\n        max_length (int | None, optional): The maximum length of the string. Defaults to\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    self.pattern = pattern\n    self.min_length = min_length\n    self.max_length = max_length\n</code></pre>"},{"location":"reference/kamihi/questions/string/#kamihi.questions.string.String(text)","title":"<code>text</code>","text":""},{"location":"reference/kamihi/questions/string/#kamihi.questions.string.String(error_text)","title":"<code>error_text</code>","text":""},{"location":"reference/kamihi/questions/string/#kamihi.questions.string.String(pattern)","title":"<code>pattern</code>","text":""},{"location":"reference/kamihi/questions/string/#kamihi.questions.string.String(min_length)","title":"<code>min_length</code>","text":""},{"location":"reference/kamihi/questions/string/#kamihi.questions.string.String(max_length)","title":"<code>max_length</code>","text":""},{"location":"reference/kamihi/questions/time/","title":"time","text":""},{"location":"reference/kamihi/questions/time/#kamihi.questions.time","title":"kamihi.questions.time","text":"<p>Generic time reusable question.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>Time</code> <p>Generic time reusable question.</p>"},{"location":"reference/kamihi/questions/time/#kamihi.questions.time.Time","title":"Time","text":"<pre><code>Time(\n    text: str,\n    error_text: str = None,\n    before: datetime | None = None,\n    after: datetime | None = None,\n    in_the_past: bool = False,\n    in_the_future: bool = False,\n)\n</code></pre> <p>               Bases: <code>Datetime</code></p> <p>Generic time reusable question.</p> Source code in <code>src/kamihi/questions/datetime.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    error_text: str = None,\n    before: datetime | None = None,\n    after: datetime | None = None,\n    in_the_past: bool = False,  # noqa: FBT001, FBT002\n    in_the_future: bool = False,  # noqa: FBT001, FBT002\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the Datetime question.\n\n    Args:\n        text (str): The text of the question.\n        error_text (str, optional): The error text to display for invalid responses. Defaults to a value from settings.\n        before (datetime | None, optional): The latest acceptable date (exclusive). Defaults to None.\n        after (datetime | None, optional): The earliest acceptable date (exclusive). Defaults to None\n        in_the_past (bool, optional): Whether the date must be in the past. Defaults to False.\n        in_the_future (bool, optional): Whether the date must be in the future. Defaults to False.\n\n    \"\"\"\n    super().__init__()\n    self.question_text = text\n\n    if error_text is not None:\n        self.error_text = error_text\n\n    self.before = before\n    if self.before and not before.tzinfo:\n        self.before = before.replace(tzinfo=get_settings().timezone_obj)\n\n    self.after = after\n    if self.after and not after.tzinfo:\n        self.after = after.replace(tzinfo=get_settings().timezone_obj)\n\n    self.in_the_past = in_the_past\n    self.in_the_future = in_the_future\n</code></pre>"},{"location":"reference/kamihi/tg/","title":"tg","text":""},{"location":"reference/kamihi/tg/#kamihi.tg","title":"kamihi.tg","text":"<p>Telegram module for Kamihi.</p> <p>This module provides the communication with the Telegram API</p> License <p>MIT</p> <p>Modules:</p> Name Description <code>client</code> <p>Telegram client module.</p> <code>default_handlers</code> <p>Default handlers.</p> <code>handlers</code> <p>Custom handlers for the Kamihi framework using python-telegram-bot.</p> <code>media</code> <p>Media types for the Kamihi bot.</p> <code>send</code> <p>Send functions for Telegram.</p> <p>Classes:</p> Name Description <code>TelegramClient</code> <p>Telegram client class.</p>"},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient","title":"TelegramClient","text":"<pre><code>TelegramClient(\n    _post_init: Callable, _post_shutdown: Callable\n)\n</code></pre> <p>Telegram client class.</p> <p>This class provides methods to send messages and handle commands.</p> <p>Initialize the Telegram client.</p> <p>Parameters:</p> Name Type Description Default <code>callable</code> <p>Function to call after the application is initialized.</p> required <code>callable</code> <p>Function to call after the application is shut down.</p> required <p>Methods:</p> Name Description <code>add_datasources</code> <p>Add data sources to the Telegram client.</p> <code>add_default_handlers</code> <p>Add default handlers to the Telegram client.</p> <code>add_handlers</code> <p>Add handlers to the Telegram client.</p> <code>add_jobs</code> <p>Add jobs to the Telegram client.</p> <code>add_pages_handler</code> <p>Add the pages handler to the Telegram client.</p> <code>reset_scopes</code> <p>Reset the command scopes for the bot.</p> <code>run</code> <p>Run the Telegram bot.</p> <code>run_job</code> <p>Run a job by its ID.</p> <code>set_scopes</code> <p>Set the command scopes for the bot.</p> <code>stop</code> <p>Stop the Telegram bot.</p> Source code in <code>src/kamihi/tg/client.py</code> <pre><code>def __init__(self, _post_init: Callable, _post_shutdown: Callable) -&gt; None:\n    \"\"\"\n    Initialize the Telegram client.\n\n    Args:\n        _post_init (callable): Function to call after the application is initialized.\n        _post_shutdown (callable): Function to call after the application is shut down.\n\n    \"\"\"\n    settings = get_settings()\n\n    if settings.testing:\n        self._base_url = \"https://api.telegram.org/bot{token}/test\"\n        self._base_file_url = \"https://api.telegram.org/file/bot{token}/test\"\n        self._testing = True\n\n    # Set up the application with all the settings\n    self._builder = Application.builder()\n    self._builder.base_url(self._base_url)\n    self._builder.base_file_url(self._base_file_url)\n    self._builder.token(settings.token)\n    self._builder.defaults(\n        Defaults(\n            tzinfo=settings.timezone_obj,\n            parse_mode=ParseMode.MARKDOWN_V2,\n        )\n    )\n    self._builder.post_init(_post_init)\n    self._builder.post_shutdown(_post_shutdown)\n\n    # Build the application\n    self.app: Application = self._builder.build()\n</code></pre>"},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient(_post_init)","title":"<code>_post_init</code>","text":""},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient(_post_shutdown)","title":"<code>_post_shutdown</code>","text":""},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient.add_datasources","title":"add_datasources","text":"<pre><code>add_datasources(datasources: dict[str, DataSource]) -&gt; None\n</code></pre> <p>Add data sources to the Telegram client.</p> <p>Parameters:</p> Name Type Description Default <code>dict[str, DataSource]</code> <p>Dictionary of data source names and their corresponding callables.</p> required Source code in <code>src/kamihi/tg/client.py</code> <pre><code>def add_datasources(self, datasources: dict[str, DataSource]) -&gt; None:\n    \"\"\"\n    Add data sources to the Telegram client.\n\n    Args:\n        datasources (dict[str, DataSource]): Dictionary of data source names and their corresponding callables.\n\n    \"\"\"\n    self.app.bot_data[\"datasources\"] = datasources\n</code></pre>"},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient.add_datasources(datasources)","title":"<code>datasources</code>","text":""},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient.add_default_handlers","title":"add_default_handlers","text":"<pre><code>add_default_handlers() -&gt; None\n</code></pre> <p>Add default handlers to the Telegram client.</p> Source code in <code>src/kamihi/tg/client.py</code> <pre><code>def add_default_handlers(self) -&gt; None:\n    \"\"\"Add default handlers to the Telegram client.\"\"\"\n    settings = get_settings()\n    with logger.catch(exception=TelegramError, level=\"ERROR\", message=\"Failed to register default handlers\"):\n        if settings.responses.default_enabled:\n            self.app.add_handler(MessageHandler(filters.TEXT, default))\n        self.app.add_error_handler(error)\n</code></pre>"},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient.add_handlers","title":"add_handlers","text":"<pre><code>add_handlers(handlers: list[BaseHandler]) -&gt; None\n</code></pre> <p>Add handlers to the Telegram client.</p> <p>Parameters:</p> Name Type Description Default <code>list[BaseHandler]</code> <p>List of handlers to add.</p> required Source code in <code>src/kamihi/tg/client.py</code> <pre><code>def add_handlers(self, handlers: list[BaseHandler]) -&gt; None:\n    \"\"\"\n    Add handlers to the Telegram client.\n\n    Args:\n        handlers (list[BaseHandler]): List of handlers to add.\n\n    \"\"\"\n    for handler in handlers:\n        with logger.catch(exception=TelegramError, level=\"ERROR\", message=\"Failed to register handler\"):\n            self.app.add_handler(handler)\n</code></pre>"},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient.add_handlers(handlers)","title":"<code>handlers</code>","text":""},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient.add_jobs","title":"add_jobs","text":"<pre><code>add_jobs(\n    jobs: list[\n        tuple[\n            Job,\n            Callable[\n                [CallbackContext], Coroutine[Any, Any, None]\n            ],\n        ]\n    ],\n) -&gt; None\n</code></pre> <p>Add jobs to the Telegram client.</p> Source code in <code>src/kamihi/tg/client.py</code> <pre><code>def add_jobs(self, jobs: list[tuple[Job, Callable[[CallbackContext], Coroutine[Any, Any, None]]]]) -&gt; None:\n    \"\"\"Add jobs to the Telegram client.\"\"\"\n    if not get_settings().jobs.enabled:\n        logger.debug(\"Jobs are disabled, skipping job registration\")\n        return\n\n    logger.trace(\"Registering jobs...\")\n    self.app.job_queue.scheduler.remove_all_jobs()\n    logger.trace(\"Removed all existing jobs\")\n    with Session(get_engine()) as session:\n        for job, callback in jobs:\n            session.add(job)\n            with logger.catch(exception=TelegramError, level=\"ERROR\", message=\"Failed to register job\"):\n                lg = logger.bind(job_id=job.id, action=\"/\" + job.action.name, cron_expression=job.cron_expression)\n                if not job.enabled:\n                    lg.info(\"Disabled, skipping\")\n                    continue\n                lg.trace(\"Registering job\")\n                self.app.job_queue.run_custom(\n                    callback,\n                    job_kwargs={\n                        \"trigger\": CronTrigger.from_crontab(job.cron_expression),\n                        \"replace_existing\": True,\n                    },\n                    data={\n                        \"args\": job.args,\n                        \"per_user\": job.per_user,\n                        \"users\": [user.telegram_id for user in job.effective_users],\n                    },\n                    name=job.id,\n                )\n                lg.debug(\"Job registered\")\n    logger.debug(\"All jobs registered\", jobs=len(jobs))\n</code></pre>"},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient.add_pages_handler","title":"add_pages_handler","text":"<pre><code>add_pages_handler() -&gt; None\n</code></pre> <p>Add the pages handler to the Telegram client.</p> Source code in <code>src/kamihi/tg/client.py</code> <pre><code>def add_pages_handler(self) -&gt; None:\n    \"\"\"Add the pages handler to the Telegram client.\"\"\"\n    with logger.catch(exception=TelegramError, level=\"ERROR\", message=\"Failed to register pages handler\"):\n        self.app.add_handler(CallbackQueryHandler(page_callback, pattern=rf\"^{UUID4_REGEX.pattern}#[0-9]+$\"))\n</code></pre>"},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient.reset_scopes","title":"reset_scopes  <code>async</code>","text":"<pre><code>reset_scopes() -&gt; None\n</code></pre> <p>Reset the command scopes for the bot.</p> <p>This method clears all command scopes and sets the default commands.</p> Source code in <code>src/kamihi/tg/client.py</code> <pre><code>async def reset_scopes(self) -&gt; None:  # noqa: ARG002\n    \"\"\"\n    Reset the command scopes for the bot.\n\n    This method clears all command scopes and sets the default commands.\n    \"\"\"\n    if self._testing:\n        logger.debug(\"Testing mode, skipping resetting scopes\")\n        return\n\n    with logger.catch(exception=TelegramError, message=\"Failed to reset scopes\"):\n        await self.app.bot.delete_my_commands()\n        logger.debug(\"Scopes erased\")\n</code></pre>"},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the Telegram bot.</p> Source code in <code>src/kamihi/tg/client.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the Telegram bot.\"\"\"\n    logger.trace(\"Starting main loop...\")\n    self.app.run_polling(allowed_updates=Update.ALL_TYPES)\n</code></pre>"},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient.run_job","title":"run_job  <code>async</code>","text":"<pre><code>run_job(job_id: str) -&gt; None\n</code></pre> <p>Run a job by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The ID of the job to run.</p> required Source code in <code>src/kamihi/tg/client.py</code> <pre><code>async def run_job(self, job_id: str) -&gt; None:\n    \"\"\"\n    Run a job by its ID.\n\n    Args:\n        job_id (str): The ID of the job to run.\n\n    \"\"\"\n    job = self.app.job_queue.get_jobs_by_name(job_id)\n    if not job:\n        logger.warning(f\"Job with ID {job_id} not found\")\n        return\n    lg = logger.bind(job_id=job_id)\n    lg.debug(\"Running job manually\")\n    await job[0].run(self.app)\n    lg.debug(\"Job run completed\")\n</code></pre>"},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient.run_job(job_id)","title":"<code>job_id</code>","text":""},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient.set_scopes","title":"set_scopes  <code>async</code>","text":"<pre><code>set_scopes(scopes: dict[int, list[BotCommand]]) -&gt; None\n</code></pre> <p>Set the command scopes for the bot.</p> <p>Parameters:</p> Name Type Description Default <code>dict[int, list[BotCommand]]</code> <p>The command scopes to set.</p> required Source code in <code>src/kamihi/tg/client.py</code> <pre><code>async def set_scopes(self, scopes: dict[int, list[BotCommand]]) -&gt; None:\n    \"\"\"\n    Set the command scopes for the bot.\n\n    Args:\n        scopes (dict[int, list[BotCommand]]): The command scopes to set.\n\n    \"\"\"\n    if self._testing:\n        logger.debug(\"Testing mode, skipping setting scopes\")\n        return\n\n    for user_id, commands in scopes.items():\n        lg = logger.bind(user_id=user_id, commands=[command.command for command in commands])\n        with lg.catch(\n            exception=TelegramError,\n            message=\"Failed to set scopes\",\n        ):\n            await self.app.bot.set_my_commands(\n                commands=commands,\n                scope=BotCommandScopeChat(user_id),\n            )\n            lg.debug(\"Scopes set\")\n</code></pre>"},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient.set_scopes(scopes)","title":"<code>scopes</code>","text":""},{"location":"reference/kamihi/tg/#kamihi.tg.TelegramClient.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the Telegram bot.</p> Source code in <code>src/kamihi/tg/client.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the Telegram bot.\"\"\"\n    logger.trace(\"Stopping main loop...\")\n    await self.app.stop()\n</code></pre>"},{"location":"reference/kamihi/tg/client/","title":"client","text":""},{"location":"reference/kamihi/tg/client/#kamihi.tg.client","title":"kamihi.tg.client","text":"<p>Telegram client module.</p> <p>This module provides a Telegram client for sending messages and handling commands.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>TelegramClient</code> <p>Telegram client class.</p>"},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient","title":"TelegramClient","text":"<pre><code>TelegramClient(\n    _post_init: Callable, _post_shutdown: Callable\n)\n</code></pre> <p>Telegram client class.</p> <p>This class provides methods to send messages and handle commands.</p> <p>Initialize the Telegram client.</p> <p>Parameters:</p> Name Type Description Default <code>callable</code> <p>Function to call after the application is initialized.</p> required <code>callable</code> <p>Function to call after the application is shut down.</p> required <p>Methods:</p> Name Description <code>add_datasources</code> <p>Add data sources to the Telegram client.</p> <code>add_default_handlers</code> <p>Add default handlers to the Telegram client.</p> <code>add_handlers</code> <p>Add handlers to the Telegram client.</p> <code>add_jobs</code> <p>Add jobs to the Telegram client.</p> <code>add_pages_handler</code> <p>Add the pages handler to the Telegram client.</p> <code>reset_scopes</code> <p>Reset the command scopes for the bot.</p> <code>run</code> <p>Run the Telegram bot.</p> <code>run_job</code> <p>Run a job by its ID.</p> <code>set_scopes</code> <p>Set the command scopes for the bot.</p> <code>stop</code> <p>Stop the Telegram bot.</p> Source code in <code>src/kamihi/tg/client.py</code> <pre><code>def __init__(self, _post_init: Callable, _post_shutdown: Callable) -&gt; None:\n    \"\"\"\n    Initialize the Telegram client.\n\n    Args:\n        _post_init (callable): Function to call after the application is initialized.\n        _post_shutdown (callable): Function to call after the application is shut down.\n\n    \"\"\"\n    settings = get_settings()\n\n    if settings.testing:\n        self._base_url = \"https://api.telegram.org/bot{token}/test\"\n        self._base_file_url = \"https://api.telegram.org/file/bot{token}/test\"\n        self._testing = True\n\n    # Set up the application with all the settings\n    self._builder = Application.builder()\n    self._builder.base_url(self._base_url)\n    self._builder.base_file_url(self._base_file_url)\n    self._builder.token(settings.token)\n    self._builder.defaults(\n        Defaults(\n            tzinfo=settings.timezone_obj,\n            parse_mode=ParseMode.MARKDOWN_V2,\n        )\n    )\n    self._builder.post_init(_post_init)\n    self._builder.post_shutdown(_post_shutdown)\n\n    # Build the application\n    self.app: Application = self._builder.build()\n</code></pre>"},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient(_post_init)","title":"<code>_post_init</code>","text":""},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient(_post_shutdown)","title":"<code>_post_shutdown</code>","text":""},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient.add_datasources","title":"add_datasources","text":"<pre><code>add_datasources(datasources: dict[str, DataSource]) -&gt; None\n</code></pre> <p>Add data sources to the Telegram client.</p> <p>Parameters:</p> Name Type Description Default <code>dict[str, DataSource]</code> <p>Dictionary of data source names and their corresponding callables.</p> required Source code in <code>src/kamihi/tg/client.py</code> <pre><code>def add_datasources(self, datasources: dict[str, DataSource]) -&gt; None:\n    \"\"\"\n    Add data sources to the Telegram client.\n\n    Args:\n        datasources (dict[str, DataSource]): Dictionary of data source names and their corresponding callables.\n\n    \"\"\"\n    self.app.bot_data[\"datasources\"] = datasources\n</code></pre>"},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient.add_datasources(datasources)","title":"<code>datasources</code>","text":""},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient.add_default_handlers","title":"add_default_handlers","text":"<pre><code>add_default_handlers() -&gt; None\n</code></pre> <p>Add default handlers to the Telegram client.</p> Source code in <code>src/kamihi/tg/client.py</code> <pre><code>def add_default_handlers(self) -&gt; None:\n    \"\"\"Add default handlers to the Telegram client.\"\"\"\n    settings = get_settings()\n    with logger.catch(exception=TelegramError, level=\"ERROR\", message=\"Failed to register default handlers\"):\n        if settings.responses.default_enabled:\n            self.app.add_handler(MessageHandler(filters.TEXT, default))\n        self.app.add_error_handler(error)\n</code></pre>"},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient.add_handlers","title":"add_handlers","text":"<pre><code>add_handlers(handlers: list[BaseHandler]) -&gt; None\n</code></pre> <p>Add handlers to the Telegram client.</p> <p>Parameters:</p> Name Type Description Default <code>list[BaseHandler]</code> <p>List of handlers to add.</p> required Source code in <code>src/kamihi/tg/client.py</code> <pre><code>def add_handlers(self, handlers: list[BaseHandler]) -&gt; None:\n    \"\"\"\n    Add handlers to the Telegram client.\n\n    Args:\n        handlers (list[BaseHandler]): List of handlers to add.\n\n    \"\"\"\n    for handler in handlers:\n        with logger.catch(exception=TelegramError, level=\"ERROR\", message=\"Failed to register handler\"):\n            self.app.add_handler(handler)\n</code></pre>"},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient.add_handlers(handlers)","title":"<code>handlers</code>","text":""},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient.add_jobs","title":"add_jobs","text":"<pre><code>add_jobs(\n    jobs: list[\n        tuple[\n            Job,\n            Callable[\n                [CallbackContext], Coroutine[Any, Any, None]\n            ],\n        ]\n    ],\n) -&gt; None\n</code></pre> <p>Add jobs to the Telegram client.</p> Source code in <code>src/kamihi/tg/client.py</code> <pre><code>def add_jobs(self, jobs: list[tuple[Job, Callable[[CallbackContext], Coroutine[Any, Any, None]]]]) -&gt; None:\n    \"\"\"Add jobs to the Telegram client.\"\"\"\n    if not get_settings().jobs.enabled:\n        logger.debug(\"Jobs are disabled, skipping job registration\")\n        return\n\n    logger.trace(\"Registering jobs...\")\n    self.app.job_queue.scheduler.remove_all_jobs()\n    logger.trace(\"Removed all existing jobs\")\n    with Session(get_engine()) as session:\n        for job, callback in jobs:\n            session.add(job)\n            with logger.catch(exception=TelegramError, level=\"ERROR\", message=\"Failed to register job\"):\n                lg = logger.bind(job_id=job.id, action=\"/\" + job.action.name, cron_expression=job.cron_expression)\n                if not job.enabled:\n                    lg.info(\"Disabled, skipping\")\n                    continue\n                lg.trace(\"Registering job\")\n                self.app.job_queue.run_custom(\n                    callback,\n                    job_kwargs={\n                        \"trigger\": CronTrigger.from_crontab(job.cron_expression),\n                        \"replace_existing\": True,\n                    },\n                    data={\n                        \"args\": job.args,\n                        \"per_user\": job.per_user,\n                        \"users\": [user.telegram_id for user in job.effective_users],\n                    },\n                    name=job.id,\n                )\n                lg.debug(\"Job registered\")\n    logger.debug(\"All jobs registered\", jobs=len(jobs))\n</code></pre>"},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient.add_pages_handler","title":"add_pages_handler","text":"<pre><code>add_pages_handler() -&gt; None\n</code></pre> <p>Add the pages handler to the Telegram client.</p> Source code in <code>src/kamihi/tg/client.py</code> <pre><code>def add_pages_handler(self) -&gt; None:\n    \"\"\"Add the pages handler to the Telegram client.\"\"\"\n    with logger.catch(exception=TelegramError, level=\"ERROR\", message=\"Failed to register pages handler\"):\n        self.app.add_handler(CallbackQueryHandler(page_callback, pattern=rf\"^{UUID4_REGEX.pattern}#[0-9]+$\"))\n</code></pre>"},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient.reset_scopes","title":"reset_scopes  <code>async</code>","text":"<pre><code>reset_scopes() -&gt; None\n</code></pre> <p>Reset the command scopes for the bot.</p> <p>This method clears all command scopes and sets the default commands.</p> Source code in <code>src/kamihi/tg/client.py</code> <pre><code>async def reset_scopes(self) -&gt; None:  # noqa: ARG002\n    \"\"\"\n    Reset the command scopes for the bot.\n\n    This method clears all command scopes and sets the default commands.\n    \"\"\"\n    if self._testing:\n        logger.debug(\"Testing mode, skipping resetting scopes\")\n        return\n\n    with logger.catch(exception=TelegramError, message=\"Failed to reset scopes\"):\n        await self.app.bot.delete_my_commands()\n        logger.debug(\"Scopes erased\")\n</code></pre>"},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the Telegram bot.</p> Source code in <code>src/kamihi/tg/client.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the Telegram bot.\"\"\"\n    logger.trace(\"Starting main loop...\")\n    self.app.run_polling(allowed_updates=Update.ALL_TYPES)\n</code></pre>"},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient.run_job","title":"run_job  <code>async</code>","text":"<pre><code>run_job(job_id: str) -&gt; None\n</code></pre> <p>Run a job by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The ID of the job to run.</p> required Source code in <code>src/kamihi/tg/client.py</code> <pre><code>async def run_job(self, job_id: str) -&gt; None:\n    \"\"\"\n    Run a job by its ID.\n\n    Args:\n        job_id (str): The ID of the job to run.\n\n    \"\"\"\n    job = self.app.job_queue.get_jobs_by_name(job_id)\n    if not job:\n        logger.warning(f\"Job with ID {job_id} not found\")\n        return\n    lg = logger.bind(job_id=job_id)\n    lg.debug(\"Running job manually\")\n    await job[0].run(self.app)\n    lg.debug(\"Job run completed\")\n</code></pre>"},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient.run_job(job_id)","title":"<code>job_id</code>","text":""},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient.set_scopes","title":"set_scopes  <code>async</code>","text":"<pre><code>set_scopes(scopes: dict[int, list[BotCommand]]) -&gt; None\n</code></pre> <p>Set the command scopes for the bot.</p> <p>Parameters:</p> Name Type Description Default <code>dict[int, list[BotCommand]]</code> <p>The command scopes to set.</p> required Source code in <code>src/kamihi/tg/client.py</code> <pre><code>async def set_scopes(self, scopes: dict[int, list[BotCommand]]) -&gt; None:\n    \"\"\"\n    Set the command scopes for the bot.\n\n    Args:\n        scopes (dict[int, list[BotCommand]]): The command scopes to set.\n\n    \"\"\"\n    if self._testing:\n        logger.debug(\"Testing mode, skipping setting scopes\")\n        return\n\n    for user_id, commands in scopes.items():\n        lg = logger.bind(user_id=user_id, commands=[command.command for command in commands])\n        with lg.catch(\n            exception=TelegramError,\n            message=\"Failed to set scopes\",\n        ):\n            await self.app.bot.set_my_commands(\n                commands=commands,\n                scope=BotCommandScopeChat(user_id),\n            )\n            lg.debug(\"Scopes set\")\n</code></pre>"},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient.set_scopes(scopes)","title":"<code>scopes</code>","text":""},{"location":"reference/kamihi/tg/client/#kamihi.tg.client.TelegramClient.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the Telegram bot.</p> Source code in <code>src/kamihi/tg/client.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop the Telegram bot.\"\"\"\n    logger.trace(\"Stopping main loop...\")\n    await self.app.stop()\n</code></pre>"},{"location":"reference/kamihi/tg/default_handlers/","title":"default_handlers","text":""},{"location":"reference/kamihi/tg/default_handlers/#kamihi.tg.default_handlers","title":"kamihi.tg.default_handlers","text":"<p>Default handlers.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>cancel</code> <p>Cancel the current operation.</p> <code>default</code> <p>Tells the user their message is not understood.</p> <code>error</code> <p>Apologizes to the user when an error happens.</p>"},{"location":"reference/kamihi/tg/default_handlers/#kamihi.tg.default_handlers.cancel","title":"cancel  <code>async</code>","text":"<pre><code>cancel(update: Update, context: CallbackContext) -&gt; None\n</code></pre> <p>Cancel the current operation.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>Update object</p> required <code>CallbackContext</code> <p>CallbackContext object</p> required Source code in <code>src/kamihi/tg/default_handlers.py</code> <pre><code>async def cancel(update: Update, context: CallbackContext) -&gt; None:\n    \"\"\"\n    Cancel the current operation.\n\n    Args:\n        update (Update): Update object\n        context (CallbackContext): CallbackContext object\n\n    \"\"\"\n    logger.bind(chat_id=update.effective_message.chat_id, message_id=update.effective_message.message_id).info(\n        \"User requested to cancel the current operation\"\n    )\n\n    text = context.bot_data[\"responses\"][\"cancel_message\"]\n    await send(text, update, context)\n    raise ApplicationHandlerStop\n</code></pre>"},{"location":"reference/kamihi/tg/default_handlers/#kamihi.tg.default_handlers.cancel(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/tg/default_handlers/#kamihi.tg.default_handlers.cancel(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/tg/default_handlers/#kamihi.tg.default_handlers.default","title":"default  <code>async</code>","text":"<pre><code>default(update: Update, context: CallbackContext) -&gt; None\n</code></pre> <p>Tells the user their message is not understood.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>Update object</p> required <code>CallbackContext</code> <p>CallbackContext object</p> required Source code in <code>src/kamihi/tg/default_handlers.py</code> <pre><code>async def default(update: Update, context: CallbackContext) -&gt; None:\n    \"\"\"\n    Tells the user their message is not understood.\n\n    Args:\n        update (Update): Update object\n        context (CallbackContext): CallbackContext object\n\n    \"\"\"\n    settings = get_settings().responses\n\n    logger.bind(chat_id=update.effective_message.chat_id, message_id=update.effective_message.message_id).debug(\n        \"Received message but no handler matched, so sending default response\"\n    )\n\n    await send(settings.default_message, update, context)\n    raise ApplicationHandlerStop\n</code></pre>"},{"location":"reference/kamihi/tg/default_handlers/#kamihi.tg.default_handlers.default(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/tg/default_handlers/#kamihi.tg.default_handlers.default(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/tg/default_handlers/#kamihi.tg.default_handlers.error","title":"error  <code>async</code>","text":"<pre><code>error(\n    update: object | None, context: CallbackContext\n) -&gt; None\n</code></pre> <p>Apologizes to the user when an error happens.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>Update object</p> required <code>CallbackContext</code> <p>CallbackContext object</p> required Source code in <code>src/kamihi/tg/default_handlers.py</code> <pre><code>async def error(update: object | None, context: CallbackContext) -&gt; None:\n    \"\"\"\n    Apologizes to the user when an error happens.\n\n    Args:\n        update (Update): Update object\n        context (CallbackContext): CallbackContext object\n\n    \"\"\"\n    settings = get_settings().responses\n\n    logger.opt(exception=context.error).error(\"An error occurred\")\n\n    if isinstance(update, Update):\n        await send(settings.error_message, update, context)\n\n    raise ApplicationHandlerStop\n</code></pre>"},{"location":"reference/kamihi/tg/default_handlers/#kamihi.tg.default_handlers.error(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/tg/default_handlers/#kamihi.tg.default_handlers.error(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/tg/handlers/","title":"handlers","text":""},{"location":"reference/kamihi/tg/handlers/#kamihi.tg.handlers","title":"kamihi.tg.handlers","text":"<p>Custom handlers for the Kamihi framework using python-telegram-bot.</p> License <p>MIT</p> <p>Modules:</p> Name Description <code>auth_handler</code> <p>Custom handler for Telegram bot that checks if a user is authorized to use a wrapped handler.</p> <code>page_handler</code> <p>Pages handler.</p> <p>Classes:</p> Name Description <code>AuthHandler</code> <p>Custom wrapper handler that checks if the user is authorized to use the wrapped handler before executing it.</p>"},{"location":"reference/kamihi/tg/handlers/#kamihi.tg.handlers.AuthHandler","title":"AuthHandler","text":"<pre><code>AuthHandler(handler: BaseHandler, name: str)\n</code></pre> <p>               Bases: <code>BaseHandler</code></p> <p>Custom wrapper handler that checks if the user is authorized to use the wrapped handler before executing it.</p> <p>Attributes:</p> Name Type Description <code>handler</code> <code>BaseHandler</code> <p>the handler to be wrapped.</p> <code>name</code> <code>str</code> <p>The name of the action.</p> <p>Initialize the AuthHandler with the callback function.</p> <p>Methods:</p> Name Description <code>check_update</code> <p>Determine if an update should be handled by this handler instance.</p> Source code in <code>src/kamihi/tg/handlers/auth_handler.py</code> <pre><code>def __init__(self, handler: BaseHandler, name: str) -&gt; None:\n    \"\"\"Initialize the AuthHandler with the callback function.\"\"\"\n    self.handler = handler\n    self.name = name\n    super().__init__(self.handler.callback)\n</code></pre>"},{"location":"reference/kamihi/tg/handlers/#kamihi.tg.handlers.AuthHandler.check_update","title":"check_update","text":"<pre><code>check_update(update: Update) -&gt; bool\n</code></pre> <p>Determine if an update should be handled by this handler instance.</p> Source code in <code>src/kamihi/tg/handlers/auth_handler.py</code> <pre><code>def check_update(self, update: Update) -&gt; bool:\n    \"\"\"Determine if an update should be handled by this handler instance.\"\"\"\n    if not isinstance(update, Update):\n        return False\n\n    if update.message and update.effective_user:\n        user = get_user_from_telegram_id(update.effective_user.id)\n\n        if user is None:\n            logger.bind(user_id=update.effective_user.id, action=self.name).debug(\n                \"User not found in the database tried to use action.\"\n            )\n            return False\n\n        if not is_user_authorized(user, self.name):\n            logger.bind(user_id=user.telegram_id, action=self.name).debug(\n                \"User is not authorized to use this action.\"\n            )\n            return False\n\n    return self.handler.check_update(update)\n</code></pre>"},{"location":"reference/kamihi/tg/handlers/auth_handler/","title":"auth_handler","text":""},{"location":"reference/kamihi/tg/handlers/auth_handler/#kamihi.tg.handlers.auth_handler","title":"kamihi.tg.handlers.auth_handler","text":"<p>Custom handler for Telegram bot that checks if a user is authorized to use a wrapped handler.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>AuthHandler</code> <p>Custom wrapper handler that checks if the user is authorized to use the wrapped handler before executing it.</p>"},{"location":"reference/kamihi/tg/handlers/auth_handler/#kamihi.tg.handlers.auth_handler.AuthHandler","title":"AuthHandler","text":"<pre><code>AuthHandler(handler: BaseHandler, name: str)\n</code></pre> <p>               Bases: <code>BaseHandler</code></p> <p>Custom wrapper handler that checks if the user is authorized to use the wrapped handler before executing it.</p> <p>Attributes:</p> Name Type Description <code>handler</code> <code>BaseHandler</code> <p>the handler to be wrapped.</p> <code>name</code> <code>str</code> <p>The name of the action.</p> <p>Initialize the AuthHandler with the callback function.</p> <p>Methods:</p> Name Description <code>check_update</code> <p>Determine if an update should be handled by this handler instance.</p> Source code in <code>src/kamihi/tg/handlers/auth_handler.py</code> <pre><code>def __init__(self, handler: BaseHandler, name: str) -&gt; None:\n    \"\"\"Initialize the AuthHandler with the callback function.\"\"\"\n    self.handler = handler\n    self.name = name\n    super().__init__(self.handler.callback)\n</code></pre>"},{"location":"reference/kamihi/tg/handlers/auth_handler/#kamihi.tg.handlers.auth_handler.AuthHandler.check_update","title":"check_update","text":"<pre><code>check_update(update: Update) -&gt; bool\n</code></pre> <p>Determine if an update should be handled by this handler instance.</p> Source code in <code>src/kamihi/tg/handlers/auth_handler.py</code> <pre><code>def check_update(self, update: Update) -&gt; bool:\n    \"\"\"Determine if an update should be handled by this handler instance.\"\"\"\n    if not isinstance(update, Update):\n        return False\n\n    if update.message and update.effective_user:\n        user = get_user_from_telegram_id(update.effective_user.id)\n\n        if user is None:\n            logger.bind(user_id=update.effective_user.id, action=self.name).debug(\n                \"User not found in the database tried to use action.\"\n            )\n            return False\n\n        if not is_user_authorized(user, self.name):\n            logger.bind(user_id=user.telegram_id, action=self.name).debug(\n                \"User is not authorized to use this action.\"\n            )\n            return False\n\n    return self.handler.check_update(update)\n</code></pre>"},{"location":"reference/kamihi/tg/handlers/page_handler/","title":"page_handler","text":""},{"location":"reference/kamihi/tg/handlers/page_handler/#kamihi.tg.handlers.page_handler","title":"kamihi.tg.handlers.page_handler","text":"<p>Pages handler.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>page_callback</code> <p>Handle page callbacks.</p>"},{"location":"reference/kamihi/tg/handlers/page_handler/#kamihi.tg.handlers.page_handler.page_callback","title":"page_callback  <code>async</code>","text":"<pre><code>page_callback(\n    update: Update, context: CallbackContext\n) -&gt; int\n</code></pre> <p>Handle page callbacks.</p> <p>Parameters:</p> Name Type Description Default <code>Update</code> <p>Update object</p> required <code>CallbackContext</code> <p>CallbackContext object</p> required Source code in <code>src/kamihi/tg/handlers/page_handler.py</code> <pre><code>async def page_callback(update: Update, context: CallbackContext) -&gt; int:\n    \"\"\"\n    Handle page callbacks.\n\n    Args:\n        update (Update): Update object\n        context (CallbackContext): CallbackContext object\n\n    \"\"\"\n    Pages.clean_up(get_settings().db.pages_expiration_days)\n    logger.debug(\"Cleaned up expired pages\")\n\n    query = update.callback_query\n    pages_id = query.data.split(\"#\")[0]\n    page_num = int(query.data.split(\"#\")[1]) - 1\n\n    await context.bot.answer_callback_query(query.id)\n\n    lg = logger.bind(message_id=query.message.message_id, pages_id=pages_id, page_num=page_num)\n    lg.trace(\"Handling page callback\")\n\n    try:\n        page, keyboard = Pages.from_id(pages_id).get_page(page_num)\n    except ValueError:\n        lg.debug(\"Query refers to non-existing pages, possibly because they expired\")\n        page = md(\"\u26a0\ufe0f *This paginated message has expired.*\")\n        keyboard = None\n\n    await query.edit_message_text(text=page, reply_markup=keyboard, parse_mode=\"MarkdownV2\")\n\n    lg.bind(text=page).debug(\"Handled page callback\")\n\n    return ConversationHandler.END\n</code></pre>"},{"location":"reference/kamihi/tg/handlers/page_handler/#kamihi.tg.handlers.page_handler.page_callback(update)","title":"<code>update</code>","text":""},{"location":"reference/kamihi/tg/handlers/page_handler/#kamihi.tg.handlers.page_handler.page_callback(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/tg/media/","title":"media","text":""},{"location":"reference/kamihi/tg/media/#kamihi.tg.media","title":"kamihi.tg.media","text":"<p>Media types for the Kamihi bot.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>Audio</code> <p>Represents an audio media type.</p> <code>Document</code> <p>Represents a document media type.</p> <code>Location</code> <p>Represents a location media type.</p> <code>Media</code> <p>Represents a media type for the Kamihi bot.</p> <code>Pages</code> <p>Represents a paginated media type.</p> <code>Photo</code> <p>Represents a photo media type.</p> <code>Video</code> <p>Represents a video media type.</p> <code>Voice</code> <p>Represents a voice media type.</p>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Audio","title":"Audio  <code>dataclass</code>","text":"<pre><code>Audio(\n    file: str | Path | IO[bytes] | bytes,\n    caption: str | None = None,\n    filename: str | None = None,\n    _size_limit: float = float(\n        FileSizeLimit.FILESIZE_UPLOAD\n    ),\n    performer: str | None = None,\n    title: str | None = None,\n)\n</code></pre> <p>               Bases: <code>Media</code></p> <p>Represents an audio media type.</p> <p>Methods:</p> Name Description <code>as_input_media</code> <p>Convert the Audio to the InputMediaDocument class for sending.</p>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Audio.as_input_media","title":"as_input_media","text":"<pre><code>as_input_media() -&gt; InputMediaAudio\n</code></pre> <p>Convert the Audio to the InputMediaDocument class for sending.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>InputMediaAudio</code> <p>A dictionary representation of the audio for input media.</p> Source code in <code>src/kamihi/tg/media.py</code> <pre><code>def as_input_media(self) -&gt; InputMediaAudio:\n    \"\"\"\n    Convert the Audio to the InputMediaDocument class for sending.\n\n    Returns:\n        dict: A dictionary representation of the audio for input media.\n\n    \"\"\"\n    return InputMediaAudio(\n        media=self.file.read_bytes() if isinstance(self.file, Path) else self.file,\n        caption=md(self.caption) if self.caption else None,\n        filename=self.filename,\n        performer=self.performer,\n        title=self.title,\n    )\n</code></pre>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Document","title":"Document  <code>dataclass</code>","text":"<pre><code>Document(\n    file: str | Path | IO[bytes] | bytes,\n    caption: str | None = None,\n    filename: str | None = None,\n    _size_limit: float = float(\n        FileSizeLimit.FILESIZE_UPLOAD\n    ),\n)\n</code></pre> <p>               Bases: <code>Media</code></p> <p>Represents a document media type.</p> <p>Methods:</p> Name Description <code>as_input_media</code> <p>Convert the Document to the InputMediaDocument class for sending.</p>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Document.as_input_media","title":"as_input_media","text":"<pre><code>as_input_media() -&gt; InputMediaDocument\n</code></pre> <p>Convert the Document to the InputMediaDocument class for sending.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>InputMediaDocument</code> <p>A dictionary representation of the document for input media.</p> Source code in <code>src/kamihi/tg/media.py</code> <pre><code>def as_input_media(self) -&gt; InputMediaDocument:\n    \"\"\"\n    Convert the Document to the InputMediaDocument class for sending.\n\n    Returns:\n        dict: A dictionary representation of the document for input media.\n\n    \"\"\"\n    return InputMediaDocument(\n        media=self.file.read_bytes() if isinstance(self.file, Path) else self.file,\n        caption=md(self.caption) if self.caption else None,\n        filename=self.filename,\n    )\n</code></pre>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Location","title":"Location","text":"<pre><code>Location(\n    latitude: float,\n    longitude: float,\n    horizontal_accuracy: float | None = None,\n)\n</code></pre> <p>Represents a location media type.</p> <p>Attributes:</p> Name Type Description <code>latitude</code> <code>float</code> <p>Latitude of the location, must be between -90 and 90.</p> <code>longitude</code> <code>float</code> <p>Longitude of the location, must be between -180 and 180.</p> <code>horizontal_accuracy</code> <code>float | None</code> <p>Optional horizontal accuracy in meters.</p> <p>Initialize a Location instance with validated coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>Latitude of the location (-90 to 90).</p> required <code>float</code> <p>Longitude of the location (-180 to 180).</p> required <code>float | None</code> <p>Optional horizontal accuracy in meters.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If latitude or longitude values are out of valid range.</p> Source code in <code>src/kamihi/tg/media.py</code> <pre><code>def __init__(self, latitude: float, longitude: float, horizontal_accuracy: float | None = None) -&gt; None:\n    \"\"\"\n    Initialize a Location instance with validated coordinates.\n\n    Args:\n        latitude (float): Latitude of the location (-90 to 90).\n        longitude (float): Longitude of the location (-180 to 180).\n        horizontal_accuracy (float | None): Optional horizontal accuracy in meters.\n\n\n    Raises:\n        ValueError: If latitude or longitude values are out of valid range.\n\n    \"\"\"\n    if not -90 &lt;= latitude &lt;= 90:\n        msg = f\"Latitude must be between -90 and 90, got {latitude}\"\n        raise ValueError(msg)\n    if not -180 &lt;= longitude &lt;= 180:\n        msg = f\"Longitude must be between -180 and 180, got {longitude}\"\n        raise ValueError(msg)\n    if horizontal_accuracy and not 0.0 &lt;= horizontal_accuracy &lt;= float(LocationLimit.HORIZONTAL_ACCURACY):\n        msg = (\n            f\"Horizontal accuracy must be between 0 \"\n            f\"and {LocationLimit.HORIZONTAL_ACCURACY}, got {horizontal_accuracy}\"\n        )\n        raise ValueError(msg)\n\n    self.latitude = latitude\n    self.longitude = longitude\n    self.horizontal_accuracy = horizontal_accuracy\n</code></pre>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Location(latitude)","title":"<code>latitude</code>","text":""},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Location(longitude)","title":"<code>longitude</code>","text":""},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Location(horizontal_accuracy)","title":"<code>horizontal_accuracy</code>","text":""},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Media","title":"Media  <code>dataclass</code>","text":"<pre><code>Media(\n    file: str | Path | IO[bytes] | bytes,\n    caption: str | None = None,\n    filename: str | None = None,\n    _size_limit: float = float(\n        FileSizeLimit.FILESIZE_UPLOAD\n    ),\n)\n</code></pre> <p>Represents a media type for the Kamihi bot.</p> <p>This is a base class for different media types like Photo and Document.</p> <p>Attributes:</p> Name Type Description <code>file</code> <code>str | Path | IO[bytes] | bytes</code> <p>The path to the media file or the file-like object.</p> <code>caption</code> <code>str | None</code> <p>Optional caption for the media.</p>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Pages","title":"Pages","text":"<pre><code>Pages(\n    data: list,\n    page_template: Template,\n    items_per_page: int = 5,\n    first_page_template: Template = None,\n    **kwargs: Any,\n)\n</code></pre> <p>Represents a paginated media type.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>The ID of the Pages instance.</p> <p>Initialize a Pages instance.</p> <p>Parameters:</p> Name Type Description Default <code>list</code> <p>List of data items to be paginated.</p> required <code>Template</code> <p>Template for rendering each page.</p> required <code>int</code> <p>Number of items per page.</p> <code>5</code> <code>Template | None</code> <p>Optional template for the first page. This page will not get elements from the <code>data</code> list passed to it.</p> <code>None</code> <code>Any</code> <p>Additional keyword arguments to be passed to the template rendering, including to the first page template if provided.</p> <code>{}</code> <p>Methods:</p> Name Description <code>clean_up</code> <p>Clean up old pages from the database.</p> <code>from_id</code> <p>Retrieve a Pages instance from the database by its ID.</p> <code>get_page</code> <p>Retrieve a specific page by its number.</p> Source code in <code>src/kamihi/tg/media.py</code> <pre><code>def __init__(\n    self,\n    data: list,\n    page_template: Template,\n    items_per_page: int = 5,\n    first_page_template: Template = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initialize a Pages instance.\n\n    Args:\n        data (list): List of data items to be paginated.\n        page_template (Template): Template for rendering each page.\n        items_per_page (int): Number of items per page.\n        first_page_template (Template | None): Optional template for the first page. This page will not get elements from the `data` list passed to it.\n        **kwargs: Additional keyword arguments to be passed to the template rendering, including to the first page template if provided.\n\n    \"\"\"\n    pages = [\n        md(page_template.render(data=dl, **kwargs))\n        for dl in [data[i : i + items_per_page] for i in range(0, len(data), items_per_page)]\n    ]\n    if first_page_template:\n        first_page = md(first_page_template.render(**kwargs))\n        pages.insert(0, first_page)\n\n    with Session(get_engine()) as session:\n        pages = DbPages(pages=pages)\n        session.add(pages)\n        session.commit()\n\n        self.id = pages.id\n</code></pre>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Pages(data)","title":"<code>data</code>","text":""},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Pages(page_template)","title":"<code>page_template</code>","text":""},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Pages(items_per_page)","title":"<code>items_per_page</code>","text":""},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Pages(first_page_template)","title":"<code>first_page_template</code>","text":""},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Pages(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Pages.clean_up","title":"clean_up  <code>staticmethod</code>","text":"<pre><code>clean_up(expire_days: int) -&gt; None\n</code></pre> <p>Clean up old pages from the database.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>Number of days after which pages are considered expired.</p> required Source code in <code>src/kamihi/tg/media.py</code> <pre><code>@staticmethod\ndef clean_up(expire_days: int) -&gt; None:\n    \"\"\"\n    Clean up old pages from the database.\n\n    Args:\n        expire_days (int): Number of days after which pages are considered expired.\n\n    \"\"\"\n    with Session(get_engine()) as session:\n        expire_cutoff = datetime.datetime.now(datetime.UTC) - datetime.timedelta(days=expire_days)\n        stmt = delete(DbPages).where(DbPages.created_at &lt; expire_cutoff)\n        session.execute(stmt)\n        session.commit()\n</code></pre>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Pages.clean_up(expire_days)","title":"<code>expire_days</code>","text":""},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Pages.from_id","title":"from_id  <code>staticmethod</code>","text":"<pre><code>from_id(pages_id: str) -&gt; Pages\n</code></pre> <p>Retrieve a Pages instance from the database by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The ID of the Pages instance.</p> required <p>Returns:</p> Name Type Description <code>Pages</code> <code>Pages</code> <p>The Pages instance.</p> Source code in <code>src/kamihi/tg/media.py</code> <pre><code>@staticmethod\ndef from_id(pages_id: str) -&gt; Pages:\n    \"\"\"\n    Retrieve a Pages instance from the database by its ID.\n\n    Args:\n        pages_id (str): The ID of the Pages instance.\n\n    Returns:\n        Pages: The Pages instance.\n\n    \"\"\"\n    pages = Pages.__new__(Pages)\n    pages.id = pages_id\n    return pages\n</code></pre>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Pages.from_id(pages_id)","title":"<code>pages_id</code>","text":""},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Pages.get_page","title":"get_page","text":"<pre><code>get_page(\n    page_number: int,\n) -&gt; tuple[str, InlineKeyboardMarkup]\n</code></pre> <p>Retrieve a specific page by its number.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The page number to retrieve.</p> required <p>Returns:</p> Type Description <code>tuple[str, InlineKeyboardMarkup]</code> <p>tuple[str, InlineKeyboardMarkup]: A tuple containing the page content and the pagination markup.</p> Source code in <code>src/kamihi/tg/media.py</code> <pre><code>def get_page(self, page_number: int) -&gt; tuple[str, InlineKeyboardMarkup]:\n    \"\"\"\n    Retrieve a specific page by its number.\n\n    Args:\n        page_number (int): The page number to retrieve.\n\n    Returns:\n        tuple[str, InlineKeyboardMarkup]: A tuple containing the page content and the pagination markup.\n\n    \"\"\"\n    with Session(get_engine()) as session:\n        db_pages = self._db_pages(session)\n        try:\n            page = db_pages.pages[page_number]\n        except IndexError as e:\n            msg = f\"Page number {page_number} is out of range. Valid range is 0 to {len(self) - 1}.\"\n            raise ValueError(msg) from e\n\n        return str(page), InlineKeyboardPaginator(\n            page_count=len(self),\n            current_page=page_number + 1,\n            data_pattern=self.id + \"#{page}\",\n        ).markup\n</code></pre>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Pages.get_page(page_number)","title":"<code>page_number</code>","text":""},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Photo","title":"Photo  <code>dataclass</code>","text":"<pre><code>Photo(\n    file: str | Path | IO[bytes] | bytes,\n    caption: str | None = None,\n    filename: str | None = None,\n    _size_limit: float = float(\n        FileSizeLimit.FILESIZE_UPLOAD\n    ),\n)\n</code></pre> <p>               Bases: <code>Media</code></p> <p>Represents a photo media type.</p> <p>Methods:</p> Name Description <code>as_input_media</code> <p>Convert the Photo to the InputMediaDocument class for sending.</p>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Photo.as_input_media","title":"as_input_media","text":"<pre><code>as_input_media() -&gt; InputMediaPhoto\n</code></pre> <p>Convert the Photo to the InputMediaDocument class for sending.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>InputMediaPhoto</code> <p>A dictionary representation of the photo for input media.</p> Source code in <code>src/kamihi/tg/media.py</code> <pre><code>def as_input_media(self) -&gt; InputMediaPhoto:\n    \"\"\"\n    Convert the Photo to the InputMediaDocument class for sending.\n\n    Returns:\n        dict: A dictionary representation of the photo for input media.\n\n    \"\"\"\n    return InputMediaPhoto(\n        media=self.file.read_bytes() if isinstance(self.file, Path) else self.file,\n        caption=md(self.caption) if self.caption else None,\n        filename=self.filename,\n    )\n</code></pre>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Video","title":"Video  <code>dataclass</code>","text":"<pre><code>Video(\n    file: str | Path | IO[bytes] | bytes,\n    caption: str | None = None,\n    filename: str | None = None,\n    _size_limit: float = float(\n        FileSizeLimit.FILESIZE_UPLOAD\n    ),\n)\n</code></pre> <p>               Bases: <code>Media</code></p> <p>Represents a video media type.</p> <p>Methods:</p> Name Description <code>as_input_media</code> <p>Convert the Video to the InputMediaDocument class for sending.</p>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Video.as_input_media","title":"as_input_media","text":"<pre><code>as_input_media() -&gt; InputMediaVideo\n</code></pre> <p>Convert the Video to the InputMediaDocument class for sending.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>InputMediaVideo</code> <p>A dictionary representation of the video for input media.</p> Source code in <code>src/kamihi/tg/media.py</code> <pre><code>def as_input_media(self) -&gt; InputMediaVideo:\n    \"\"\"\n    Convert the Video to the InputMediaDocument class for sending.\n\n    Returns:\n        dict: A dictionary representation of the video for input media.\n\n    \"\"\"\n    return InputMediaVideo(\n        media=self.file.read_bytes() if isinstance(self.file, Path) else self.file,\n        caption=md(self.caption) if self.caption else None,\n        filename=self.filename,\n    )\n</code></pre>"},{"location":"reference/kamihi/tg/media/#kamihi.tg.media.Voice","title":"Voice  <code>dataclass</code>","text":"<pre><code>Voice(\n    file: str | Path | IO[bytes] | bytes,\n    caption: str | None = None,\n    filename: str | None = None,\n    _size_limit: float = float(\n        FileSizeLimit.FILESIZE_UPLOAD\n    ),\n)\n</code></pre> <p>               Bases: <code>Media</code></p> <p>Represents a voice media type.</p>"},{"location":"reference/kamihi/tg/send/","title":"send","text":""},{"location":"reference/kamihi/tg/send/#kamihi.tg.send","title":"kamihi.tg.send","text":"<p>Send functions for Telegram.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>guess_media_type</code> <p>Guess the media type of a file based on its MIME type.</p> <code>send</code> <p>Send a message based on the provided object and annotation.</p>"},{"location":"reference/kamihi/tg/send/#kamihi.tg.send.guess_media_type","title":"guess_media_type","text":"<pre><code>guess_media_type(\n    file: Path | bytes | BufferedReader, lg: Logger\n) -&gt; Media\n</code></pre> <p>Guess the media type of a file based on its MIME type.</p> <p>Parameters:</p> Name Type Description Default <code>Path | bytes | BufferedReader</code> <p>The file path to check.</p> required <code>Logger</code> <p>The logger instance to use for logging.</p> required <p>Returns:</p> Name Type Description <code>Media</code> <code>Media</code> <p>An instance of Media subclass based on the file type.</p> Source code in <code>src/kamihi/tg/send.py</code> <pre><code>def guess_media_type(file: Path | bytes | BufferedReader, lg: Logger) -&gt; Media:\n    \"\"\"\n    Guess the media type of a file based on its MIME type.\n\n    Args:\n        file (Path | bytes | BufferedReader): The file path to check.\n        lg (Logger): The logger instance to use for logging.\n\n    Returns:\n        Media: An instance of Media subclass based on the file type.\n\n    \"\"\"\n    with lg.catch(exception=magic.MagicException, message=\"Failed to get MIME type\", reraise=True):\n        if isinstance(file, bytes):\n            mimetype = magic.from_buffer(file, mime=True)\n        elif isinstance(file, BufferedReader):\n            file.seek(0)\n            mimetype = magic.from_buffer(file.read(1024), mime=True)\n            file.seek(0)\n        else:\n            mimetype = magic.from_file(file, mime=True)\n        lg.trace(\"MIME type is {t}\", t=mimetype)\n\n    if \"image/\" in mimetype:\n        lg.debug(\"File detected as image\")\n        return Photo(file=file, filename=file.name if isinstance(file, Path) else None)\n\n    if mimetype == \"video/mp4\":\n        lg.debug(\"File detected as video\")\n        return Video(file=file, filename=file.name if isinstance(file, Path) else None)\n\n    if mimetype in (\"audio/mpeg\", \"audio/mp4\", \"audio/x-m4a\", \"audio/ogg\"):\n        try:\n            res = Voice(file=file, filename=file.name if isinstance(file, Path) else None)\n            lg.debug(\"File detected as voice message\")\n        except ValueError:\n            res = Audio(file=file, filename=file.name if isinstance(file, Path) else None)\n            lg.debug(\"File detected as audio\")\n        return res\n\n    lg.debug(\"File detected as generic document\")\n    return Document(file=file, filename=file.name if isinstance(file, Path) else None)\n</code></pre>"},{"location":"reference/kamihi/tg/send/#kamihi.tg.send.guess_media_type(file)","title":"<code>file</code>","text":""},{"location":"reference/kamihi/tg/send/#kamihi.tg.send.guess_media_type(lg)","title":"<code>lg</code>","text":""},{"location":"reference/kamihi/tg/send/#kamihi.tg.send.send","title":"send  <code>async</code>","text":"<pre><code>send(\n    obj: Any,\n    dest: int | Update,\n    context: CallbackContext,\n    reply_markup: TelegramObject = None,\n) -&gt; Message | list[Message] | None\n</code></pre> <p>Send a message based on the provided object and annotation.</p> <p>Parameters:</p> Name Type Description Default <code>Any</code> <p>The object to send.</p> required <code>int | Update</code> <p>The destination of the message.</p> required <code>CallbackContext</code> <p>The callback context containing the bot instance.</p> required <code>TelegramObject</code> <p>Additional interface options to be sent with the message. Defaults to None. Only supported for text messages.</p> <code>None</code> <p>Returns:</p> Type Description <code>Message | list[Message] | None</code> <p>Message | list[Message]: The response from the Telegram API, or a list of responses if multiple objects are sent.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the object type is not supported for sending.</p> Source code in <code>src/kamihi/tg/send.py</code> <pre><code>async def send(  # noqa: C901\n    obj: Any,\n    dest: int | Update,\n    context: CallbackContext,\n    reply_markup: TelegramObject = None,\n) -&gt; Message | list[Message] | None:\n    \"\"\"\n    Send a message based on the provided object and annotation.\n\n    Args:\n        obj (Any): The object to send.\n        dest (int | Update): The destination of the message.\n        context (CallbackContext): The callback context containing the bot instance.\n        reply_markup (TelegramObject, optional): Additional interface options to be sent with the message. Defaults to None. Only supported for text messages.\n\n    Returns:\n        Message | list[Message]: The response from the Telegram API, or a list of responses\n            if multiple objects are sent.\n\n    Raises:\n        TypeError: If the object type is not supported for sending.\n\n    \"\"\"\n    if isinstance(dest, Update):\n        dest = dest.effective_chat.id\n\n    lg = logger.bind(chat_id=dest)\n\n    if obj is None:\n        lg.debug(\"Nothing to send\")\n        return None\n\n    if isinstance(obj, str):\n        lg = lg.bind(text=obj)\n        method = context.bot.send_message\n        kwargs = {\"text\": md(obj), \"reply_markup\": reply_markup}\n        lg.debug(\"Sending as text message\")\n    elif isinstance(obj, (Path, bytes, BufferedReader)):\n        return await send(guess_media_type(obj, lg), dest, context)\n    elif isinstance(obj, Media):\n        caption = md(obj.caption) if obj.caption else None\n        lg = lg.bind(path=obj.file, caption=caption)\n\n        kwargs: dict[str, Any] = {\"filename\": obj.filename, \"caption\": caption}\n\n        if isinstance(obj, Document):\n            method = context.bot.send_document\n            kwargs[\"document\"] = obj.file\n            lg.debug(\"Sending as generic file\")\n        elif isinstance(obj, Photo):\n            method = context.bot.send_photo\n            kwargs[\"photo\"] = obj.file\n            lg.debug(\"Sending as photo\")\n        elif isinstance(obj, Video):\n            method = context.bot.send_video\n            kwargs[\"video\"] = obj.file\n            lg.debug(\"Sending as video\")\n        elif isinstance(obj, Audio):\n            method = context.bot.send_audio\n            kwargs[\"audio\"] = obj.file\n            lg.debug(\"Sending as audio\")\n        elif isinstance(obj, Voice):\n            method = context.bot.send_voice\n            kwargs[\"voice\"] = obj.file\n            lg.debug(\"Sending as voice note\")\n        else:\n            mes = f\"Object of type {type(obj)} cannot be sent\"\n            raise TypeError(mes)\n    elif isinstance(obj, Location):\n        lg = lg.bind(latitude=obj.latitude, longitude=obj.longitude, horizontal_accuracy=obj.horizontal_accuracy)\n        method = context.bot.send_location\n        kwargs = {\"latitude\": obj.latitude, \"longitude\": obj.longitude, \"horizontal_accuracy\": obj.horizontal_accuracy}\n        lg.debug(\"Sending as location\")\n    elif isinstance(obj, Pages):\n        lg = lg.bind(pages_id=obj.id)\n        lg.debug(\"Sending as paginated message\")\n        page, keyboard = obj.get_page(0)\n        return await send(page, dest, context, reply_markup=keyboard)\n    elif (\n        isinstance(obj, collections.abc.Sequence)\n        and 2 &lt;= len(obj) &lt;= 10\n        and any(\n            [\n                all(isinstance(item, (Photo, Video)) for item in obj),\n                all(isinstance(item, Document) for item in obj),\n                all(isinstance(item, Audio) for item in obj),\n            ]\n        )\n    ):\n        lg.debug(\"Sending as media group\")\n        method = context.bot.send_media_group\n        kwargs = {\"media\": [item.as_input_media() for item in obj]}\n    elif (\n        isinstance(obj, collections.abc.Sequence)\n        and 2 &lt;= len(obj) &lt;= 10\n        and all(isinstance(item, Path) for item in obj)\n    ):\n        lg.debug(\"Received list of file paths, guessing media types and trying to send as media group\")\n        return await send(\n            [guess_media_type(item, lg) for item in obj],\n            dest,\n            context,\n        )\n    elif isinstance(obj, collections.abc.Sequence):\n        lg.debug(\"Sending as list of items\")\n        return [await send(item, dest, context) for item in obj]\n    else:\n        mes = f\"Object of type {type(obj)} cannot be sent\"\n        raise TypeError(mes)\n\n    with lg.catch(exception=TelegramError, message=\"Failed to send\"):\n        res = await method(\n            chat_id=dest,\n            **kwargs,\n        )\n        lg.bind(\n            response_id=res.message_id if isinstance(res, Message) else [message.message_id for message in res],\n        ).debug(\"Sent\")\n        return res\n</code></pre>"},{"location":"reference/kamihi/tg/send/#kamihi.tg.send.send(obj)","title":"<code>obj</code>","text":""},{"location":"reference/kamihi/tg/send/#kamihi.tg.send.send(dest)","title":"<code>dest</code>","text":""},{"location":"reference/kamihi/tg/send/#kamihi.tg.send.send(context)","title":"<code>context</code>","text":""},{"location":"reference/kamihi/tg/send/#kamihi.tg.send.send(reply_markup)","title":"<code>reply_markup</code>","text":""},{"location":"reference/kamihi/users/","title":"users","text":""},{"location":"reference/kamihi/users/#kamihi.users","title":"kamihi.users","text":"<p>Users module of the Kamihi framework.</p> License <p>MIT</p> <p>Modules:</p> Name Description <code>users</code> <p>Common user-related functions.</p> <p>Functions:</p> Name Description <code>get_user_from_telegram_id</code> <p>Get a user from the database using their Telegram ID.</p> <code>get_users</code> <p>Get all users from the database.</p> <code>is_user_authorized</code> <p>Check if a user is authorized to use a specific action.</p>"},{"location":"reference/kamihi/users/#kamihi.users.BaseUser","title":"BaseUser","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for user models.</p> <p>This class should be extended in user code to create a custom user model.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p> <code>telegram_id</code> <code>int</code> <p>Unique Telegram ID of the user.</p> <code>is_admin</code> <code>bool</code> <p>Whether the user is an admin.</p> <code>roles</code> <code>list[Role]</code> <p>List of roles associated with the user.</p> <code>permissions</code> <code>list[Permission]</code> <p>List of permissions associated with the user.</p> <p>Methods:</p> Name Description <code>admin_repr</code> <p>Define the representation of the user in the admin interface.</p> <code>cls</code> <p>Get the active user class.</p>"},{"location":"reference/kamihi/users/#kamihi.users.BaseUser.admin_repr","title":"admin_repr","text":"<pre><code>admin_repr() -&gt; str\n</code></pre> <p>Define the representation of the user in the admin interface.</p> Source code in <code>src/kamihi/db/models.py</code> <pre><code>def admin_repr(self) -&gt; str:\n    \"\"\"Define the representation of the user in the admin interface.\"\"\"\n    return str(self.telegram_id)\n</code></pre>"},{"location":"reference/kamihi/users/#kamihi.users.BaseUser.cls","title":"cls  <code>classmethod</code>","text":"<pre><code>cls() -&gt; type[BaseUser]\n</code></pre> <p>Get the active user class.</p> Source code in <code>src/kamihi/db/models.py</code> <pre><code>@classmethod\ndef cls(cls) -&gt; type[BaseUser]:\n    \"\"\"Get the active user class.\"\"\"\n    return cls._active_class or globals()[\"User\"]\n</code></pre>"},{"location":"reference/kamihi/users/#kamihi.users.Permission","title":"Permission","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for permissions.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p> <code>action_id</code> <code>int | None</code> <p>Foreign key to the registered action.</p> <code>action</code> <code>RegisteredAction</code> <p>The registered action associated with the permission.</p> <code>users</code> <code>list[User]</code> <p>List of users associated with the permission.</p> <code>roles</code> <code>list[Role]</code> <p>List of roles associated with the permission.</p> <p>Methods:</p> Name Description <code>is_user_allowed</code> <p>Check if a user has this permission.</p>"},{"location":"reference/kamihi/users/#kamihi.users.Permission.effective_users","title":"effective_users  <code>property</code>","text":"<pre><code>effective_users: list[BaseUser]\n</code></pre> <p>Get the list of users who have this permission, either directly or through roles.</p> <p>Returns:</p> Type Description <code>list[BaseUser]</code> <p>list[User]: List of users with this permission.</p>"},{"location":"reference/kamihi/users/#kamihi.users.Permission.is_user_allowed","title":"is_user_allowed","text":"<pre><code>is_user_allowed(user: BaseUser) -&gt; bool\n</code></pre> <p>Check if a user has this permission.</p> <p>Parameters:</p> Name Type Description Default <code>User</code> <p>The user to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the user has this permission, False otherwise.</p> Source code in <code>src/kamihi/db/models.py</code> <pre><code>def is_user_allowed(self, user: BaseUser) -&gt; bool:\n    \"\"\"\n    Check if a user has this permission.\n\n    Args:\n        user (User): The user to check.\n\n    Returns:\n        bool: True if the user has this permission, False otherwise.\n\n    \"\"\"\n    return user in self.effective_users\n</code></pre>"},{"location":"reference/kamihi/users/#kamihi.users.Permission.is_user_allowed(user)","title":"<code>user</code>","text":""},{"location":"reference/kamihi/users/#kamihi.users.RegisteredAction","title":"RegisteredAction","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for registered actions.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key.</p> <code>name</code> <code>str</code> <p>Name of the action.</p> <code>description</code> <code>str | None</code> <p>Description of the action.</p> <code>permissions</code> <code>list[Permission]</code> <p>List of permissions associated with the action.</p>"},{"location":"reference/kamihi/users/#kamihi.users.get_engine","title":"get_engine","text":"<pre><code>get_engine() -&gt; Engine\n</code></pre> <p>Create a database engine.</p> <p>Returns:</p> Name Type Description <code>Engine</code> <code>Engine</code> <p>The database engine.</p> Source code in <code>src/kamihi/db/db.py</code> <pre><code>def get_engine() -&gt; Engine:\n    \"\"\"\n    Create a database engine.\n\n    Returns:\n        Engine: The database engine.\n\n    \"\"\"\n    if _engine is None:\n        raise RuntimeError(\"Database engine is not initialized. Call init_engine() first.\")\n    return _engine\n</code></pre>"},{"location":"reference/kamihi/users/#kamihi.users.get_user_from_telegram_id","title":"get_user_from_telegram_id","text":"<pre><code>get_user_from_telegram_id(\n    telegram_id: int,\n) -&gt; BaseUser | None\n</code></pre> <p>Get a user from the database using their Telegram ID.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The Telegram ID of the user.</p> required <p>Returns:</p> Type Description <code>BaseUser | None</code> <p>User | None: The user object if found, otherwise None.</p> Source code in <code>src/kamihi/users/users.py</code> <pre><code>def get_user_from_telegram_id(telegram_id: int) -&gt; BaseUser | None:\n    \"\"\"\n    Get a user from the database using their Telegram ID.\n\n    Args:\n        telegram_id (int): The Telegram ID of the user.\n\n    Returns:\n        User | None: The user object if found, otherwise None.\n\n    \"\"\"\n    with Session(get_engine()) as session:\n        sta = select(BaseUser.cls()).where(BaseUser.cls().telegram_id == telegram_id)\n        return session.execute(sta).scalars().first()\n</code></pre>"},{"location":"reference/kamihi/users/#kamihi.users.get_user_from_telegram_id(telegram_id)","title":"<code>telegram_id</code>","text":""},{"location":"reference/kamihi/users/#kamihi.users.get_users","title":"get_users","text":"<pre><code>get_users() -&gt; Sequence[BaseUser]\n</code></pre> <p>Get all users from the database.</p> <p>Returns:</p> Type Description <code>Sequence[BaseUser]</code> <p>list[User]: A list of all users in the database.</p> Source code in <code>src/kamihi/users/users.py</code> <pre><code>def get_users() -&gt; Sequence[BaseUser]:\n    \"\"\"\n    Get all users from the database.\n\n    Returns:\n        list[User]: A list of all users in the database.\n\n    \"\"\"\n    with Session(get_engine()) as session:\n        sta = select(BaseUser.cls())\n        return session.execute(sta).scalars().all()\n</code></pre>"},{"location":"reference/kamihi/users/#kamihi.users.get_users_of_action","title":"get_users_of_action","text":"<pre><code>get_users_of_action(action_name: str) -&gt; Sequence[BaseUser]\n</code></pre> <p>Get all users who have permission for a specific action.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name of the action.</p> required <p>Returns:</p> Type Description <code>Sequence[BaseUser]</code> <p>Sequence[BaseUser]: A list of users who have permission for the action.</p> Source code in <code>src/kamihi/users/users.py</code> <pre><code>def get_users_of_action(action_name: str) -&gt; Sequence[BaseUser]:\n    \"\"\"\n    Get all users who have permission for a specific action.\n\n    Args:\n        action_name (str): The name of the action.\n\n    Returns:\n        Sequence[BaseUser]: A list of users who have permission for the action.\n\n    \"\"\"\n    with Session(get_engine()) as session:\n        sta = select(RegisteredAction).where(RegisteredAction.name == action_name)\n        action = session.execute(sta).scalars().first()\n        if action is None:\n            mes = f\"Action '{action_name}' is not registered in the database.\"\n            raise ValueError(mes)\n\n        sta = select(Permission).where(Permission.action == action)\n        permissions = session.execute(sta).scalars().all()\n\n        users: set[BaseUser] = set()\n        for permission in permissions:\n            users.update(permission.effective_users)\n\n        return list(users)\n</code></pre>"},{"location":"reference/kamihi/users/#kamihi.users.get_users_of_action(action_name)","title":"<code>action_name</code>","text":""},{"location":"reference/kamihi/users/#kamihi.users.is_user_authorized","title":"is_user_authorized","text":"<pre><code>is_user_authorized(\n    user: BaseUser, action_name: str\n) -&gt; bool\n</code></pre> <p>Check if a user is authorized to use a specific action.</p> <p>Parameters:</p> Name Type Description Default <code>User</code> <p>The user object to check.</p> required <code>str</code> <p>The action to check authorization for.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the user is authorized, False otherwise.</p> Source code in <code>src/kamihi/users/users.py</code> <pre><code>def is_user_authorized(user: BaseUser, action_name: str) -&gt; bool:\n    \"\"\"\n    Check if a user is authorized to use a specific action.\n\n    Args:\n        user (User): The user object to check.\n        action_name (str): The action to check authorization for.\n\n    Returns:\n        bool: True if the user is authorized, False otherwise.\n\n    \"\"\"\n    with Session(get_engine()) as session:\n        user = session.get(BaseUser.cls(), user.id)\n\n        if not user:\n            return False\n\n        if user.is_admin:\n            return True\n\n        sta = select(RegisteredAction).where(RegisteredAction.name == action_name)\n        action = session.execute(sta).scalars().first()\n        if action is None:\n            mes = f\"Action '{action_name}' is not registered in the database.\"\n            raise ValueError(mes)\n\n        sta = select(Permission).where(Permission.action == action)\n        permissions = session.execute(sta).scalars().all()\n\n        if not permissions:\n            return False\n\n        return any(permission.is_user_allowed(user) for permission in permissions)\n</code></pre>"},{"location":"reference/kamihi/users/#kamihi.users.is_user_authorized(user)","title":"<code>user</code>","text":""},{"location":"reference/kamihi/users/#kamihi.users.is_user_authorized(action_name)","title":"<code>action_name</code>","text":""},{"location":"reference/kamihi/users/users/","title":"users","text":""},{"location":"reference/kamihi/users/users/#kamihi.users.users","title":"kamihi.users.users","text":"<p>Common user-related functions.</p> License <p>MIT</p> <p>Functions:</p> Name Description <code>get_user_from_telegram_id</code> <p>Get a user from the database using their Telegram ID.</p> <code>get_users</code> <p>Get all users from the database.</p> <code>get_users_of_action</code> <p>Get all users who have permission for a specific action.</p> <code>is_user_authorized</code> <p>Check if a user is authorized to use a specific action.</p>"},{"location":"reference/kamihi/users/users/#kamihi.users.users.get_user_from_telegram_id","title":"get_user_from_telegram_id","text":"<pre><code>get_user_from_telegram_id(\n    telegram_id: int,\n) -&gt; BaseUser | None\n</code></pre> <p>Get a user from the database using their Telegram ID.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The Telegram ID of the user.</p> required <p>Returns:</p> Type Description <code>BaseUser | None</code> <p>User | None: The user object if found, otherwise None.</p> Source code in <code>src/kamihi/users/users.py</code> <pre><code>def get_user_from_telegram_id(telegram_id: int) -&gt; BaseUser | None:\n    \"\"\"\n    Get a user from the database using their Telegram ID.\n\n    Args:\n        telegram_id (int): The Telegram ID of the user.\n\n    Returns:\n        User | None: The user object if found, otherwise None.\n\n    \"\"\"\n    with Session(get_engine()) as session:\n        sta = select(BaseUser.cls()).where(BaseUser.cls().telegram_id == telegram_id)\n        return session.execute(sta).scalars().first()\n</code></pre>"},{"location":"reference/kamihi/users/users/#kamihi.users.users.get_user_from_telegram_id(telegram_id)","title":"<code>telegram_id</code>","text":""},{"location":"reference/kamihi/users/users/#kamihi.users.users.get_users","title":"get_users","text":"<pre><code>get_users() -&gt; Sequence[BaseUser]\n</code></pre> <p>Get all users from the database.</p> <p>Returns:</p> Type Description <code>Sequence[BaseUser]</code> <p>list[User]: A list of all users in the database.</p> Source code in <code>src/kamihi/users/users.py</code> <pre><code>def get_users() -&gt; Sequence[BaseUser]:\n    \"\"\"\n    Get all users from the database.\n\n    Returns:\n        list[User]: A list of all users in the database.\n\n    \"\"\"\n    with Session(get_engine()) as session:\n        sta = select(BaseUser.cls())\n        return session.execute(sta).scalars().all()\n</code></pre>"},{"location":"reference/kamihi/users/users/#kamihi.users.users.get_users_of_action","title":"get_users_of_action","text":"<pre><code>get_users_of_action(action_name: str) -&gt; Sequence[BaseUser]\n</code></pre> <p>Get all users who have permission for a specific action.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name of the action.</p> required <p>Returns:</p> Type Description <code>Sequence[BaseUser]</code> <p>Sequence[BaseUser]: A list of users who have permission for the action.</p> Source code in <code>src/kamihi/users/users.py</code> <pre><code>def get_users_of_action(action_name: str) -&gt; Sequence[BaseUser]:\n    \"\"\"\n    Get all users who have permission for a specific action.\n\n    Args:\n        action_name (str): The name of the action.\n\n    Returns:\n        Sequence[BaseUser]: A list of users who have permission for the action.\n\n    \"\"\"\n    with Session(get_engine()) as session:\n        sta = select(RegisteredAction).where(RegisteredAction.name == action_name)\n        action = session.execute(sta).scalars().first()\n        if action is None:\n            mes = f\"Action '{action_name}' is not registered in the database.\"\n            raise ValueError(mes)\n\n        sta = select(Permission).where(Permission.action == action)\n        permissions = session.execute(sta).scalars().all()\n\n        users: set[BaseUser] = set()\n        for permission in permissions:\n            users.update(permission.effective_users)\n\n        return list(users)\n</code></pre>"},{"location":"reference/kamihi/users/users/#kamihi.users.users.get_users_of_action(action_name)","title":"<code>action_name</code>","text":""},{"location":"reference/kamihi/users/users/#kamihi.users.users.is_user_authorized","title":"is_user_authorized","text":"<pre><code>is_user_authorized(\n    user: BaseUser, action_name: str\n) -&gt; bool\n</code></pre> <p>Check if a user is authorized to use a specific action.</p> <p>Parameters:</p> Name Type Description Default <code>User</code> <p>The user object to check.</p> required <code>str</code> <p>The action to check authorization for.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the user is authorized, False otherwise.</p> Source code in <code>src/kamihi/users/users.py</code> <pre><code>def is_user_authorized(user: BaseUser, action_name: str) -&gt; bool:\n    \"\"\"\n    Check if a user is authorized to use a specific action.\n\n    Args:\n        user (User): The user object to check.\n        action_name (str): The action to check authorization for.\n\n    Returns:\n        bool: True if the user is authorized, False otherwise.\n\n    \"\"\"\n    with Session(get_engine()) as session:\n        user = session.get(BaseUser.cls(), user.id)\n\n        if not user:\n            return False\n\n        if user.is_admin:\n            return True\n\n        sta = select(RegisteredAction).where(RegisteredAction.name == action_name)\n        action = session.execute(sta).scalars().first()\n        if action is None:\n            mes = f\"Action '{action_name}' is not registered in the database.\"\n            raise ValueError(mes)\n\n        sta = select(Permission).where(Permission.action == action)\n        permissions = session.execute(sta).scalars().all()\n\n        if not permissions:\n            return False\n\n        return any(permission.is_user_allowed(user) for permission in permissions)\n</code></pre>"},{"location":"reference/kamihi/users/users/#kamihi.users.users.is_user_authorized(user)","title":"<code>user</code>","text":""},{"location":"reference/kamihi/users/users/#kamihi.users.users.is_user_authorized(action_name)","title":"<code>action_name</code>","text":""},{"location":"reference/kamihi/web/","title":"web","text":""},{"location":"reference/kamihi/web/#kamihi.web","title":"kamihi.web","text":"<p>Web interface module for Kamihi.</p> License <p>MIT</p> <p>Modules:</p> Name Description <code>views</code> <p>Custom view definitions for the Kamihi web application.</p> <code>web</code> <p>Web interface main file.</p> <p>Classes:</p> Name Description <code>KamihiWeb</code> <p>KamihiWeb is a class that sets up a web server for the Kamihi application.</p>"},{"location":"reference/kamihi/web/#kamihi.web.KamihiWeb","title":"KamihiWeb","text":"<pre><code>KamihiWeb(\n    hooks: dict[\n        Literal[\n            \"before_create\",\n            \"after_create\",\n            \"before_edit\",\n            \"after_edit\",\n            \"before_delete\",\n            \"after_delete\",\n            \"run_job\",\n        ],\n        list[Callable],\n    ] = None,\n)\n</code></pre> <p>               Bases: <code>Thread</code></p> <p>KamihiWeb is a class that sets up a web server for the Kamihi application.</p> <p>This class is responsible for creating and running a web server with an admin interface. It also handles the database connection and configuration.</p> <p>Attributes:</p> Name Type Description <code>app</code> <code>Starlette</code> <p>The application instance.</p> <code>admin</code> <code>Admin</code> <p>The Starlette-Admin instance for the admin interface.</p> <p>Initialize the KamihiWeb instance.</p> <p>Methods:</p> Name Description <code>run</code> <p>Run the app.</p> Source code in <code>src/kamihi/web/web.py</code> <pre><code>def __init__(\n    self,\n    hooks: dict[\n        Literal[\n            \"before_create\", \"after_create\", \"before_edit\", \"after_edit\", \"before_delete\", \"after_delete\", \"run_job\"\n        ],\n        list[Callable],\n    ] = None,\n) -&gt; None:\n    \"\"\"Initialize the KamihiWeb instance.\"\"\"\n    settings = get_settings()\n\n    super().__init__()\n\n    self.hooks = hooks\n    self.host = settings.web.host\n    self.port = settings.web.port\n\n    self.daemon = True\n\n    self.app = None\n    self.admin = None\n</code></pre>"},{"location":"reference/kamihi/web/#kamihi.web.KamihiWeb.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the app.</p> Source code in <code>src/kamihi/web/web.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the app.\"\"\"\n    self._create_app()\n\n    uvicorn.run(\n        self.app,\n        host=self.host,\n        port=self.port,\n        log_config={\n            \"version\": 1,\n            \"disable_existing_loggers\": False,\n            \"formatters\": {\n                \"default\": {\n                    \"()\": \"uvicorn.logging.DefaultFormatter\",\n                    \"fmt\": \"%(message)s\",\n                },\n                \"access\": {\n                    \"()\": \"uvicorn.logging.AccessFormatter\",\n                    \"fmt\": '%(client_addr)s - \"%(request_line)s\" %(status_code)s',  # noqa: E501\n                },\n            },\n            \"handlers\": {\n                \"default\": {\n                    \"formatter\": \"default\",\n                    \"class\": \"kamihi.web.web._InterceptHandler\",\n                },\n                \"access\": {\n                    \"formatter\": \"access\",\n                    \"class\": \"kamihi.web.web._InterceptHandler\",\n                },\n            },\n            \"loggers\": {\n                \"uvicorn\": {\"handlers\": [\"default\"], \"level\": \"DEBUG\", \"propagate\": False},\n                \"uvicorn.error\": {\"level\": \"DEBUG\"},\n                \"uvicorn.access\": {\"handlers\": [\"access\"], \"level\": \"DEBUG\", \"propagate\": False},\n            },\n        },\n    )\n</code></pre>"},{"location":"reference/kamihi/web/views/","title":"views","text":""},{"location":"reference/kamihi/web/views/#kamihi.web.views","title":"kamihi.web.views","text":"<p>Custom view definitions for the Kamihi web application.</p> License <p>MIT</p> <p>Modules:</p> Name Description <code>action_view</code> <p>Actions view module.</p> <code>base_view</code> <p>BaseView for Starlette-Admin with hooks for CRUD operations.</p> <code>job_view</code> <p>Job view module for Kamihi web application.</p> <code>user_view</code> <p>User view module for Kamihi web application.</p> <p>Classes:</p> Name Description <code>ActionView</code> <p>ReadOnlyView makes the model read-only in the admin interface.</p> <code>BaseView</code> <p>HooksView is a custom view that accepts a dictionary of hooks on different events.</p> <code>JobView</code> <p>JobView is a custom view for managing jobs in the admin interface.</p> <code>UserView</code> <p>UserView is a custom view for managing users in the admin interface.</p>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.ActionView","title":"ActionView","text":"<pre><code>ActionView(*args, hooks: dict = None, **kwargs)\n</code></pre> <p>               Bases: <code>BaseView</code></p> <p>ReadOnlyView makes the model read-only in the admin interface.</p> <p>Methods:</p> Name Description <code>can_create</code> <p>Check if the user can create a new instance of the model.</p> <code>can_delete</code> <p>Check if the user can edit an instance of the model.</p> <code>can_edit</code> <p>Check if the user can edit an instance of the model.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>def __init__(self, *args, hooks: dict = None, **kwargs) -&gt; None:  # noqa: ANN002, ANN003\n    \"\"\"\n    Initialize the HooksView with hooks.\n\n    Args:\n        *args: Positional arguments.\n        hooks (dict): A dictionary of hooks for different events.\n        **kwargs: Keyword arguments.\n\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.hooks = hooks or {}\n</code></pre>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.ActionView.can_create","title":"can_create","text":"<pre><code>can_create(request: Request) -&gt; bool\n</code></pre> <p>Check if the user can create a new instance of the model.</p> Source code in <code>src/kamihi/web/views/action_view.py</code> <pre><code>def can_create(self, request: Request) -&gt; bool:  # noqa: ARG002\n    \"\"\"Check if the user can create a new instance of the model.\"\"\"\n    return False\n</code></pre>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.ActionView.can_delete","title":"can_delete","text":"<pre><code>can_delete(request: Request) -&gt; bool\n</code></pre> <p>Check if the user can edit an instance of the model.</p> Source code in <code>src/kamihi/web/views/action_view.py</code> <pre><code>def can_delete(self, request: Request) -&gt; bool:  # noqa: ARG002\n    \"\"\"Check if the user can edit an instance of the model.\"\"\"\n    return False\n</code></pre>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.ActionView.can_edit","title":"can_edit","text":"<pre><code>can_edit(request: Request) -&gt; bool\n</code></pre> <p>Check if the user can edit an instance of the model.</p> Source code in <code>src/kamihi/web/views/action_view.py</code> <pre><code>def can_edit(self, request: Request) -&gt; bool:  # noqa: ARG002\n    \"\"\"Check if the user can edit an instance of the model.\"\"\"\n    return False\n</code></pre>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.BaseView","title":"BaseView","text":"<pre><code>BaseView(*args, hooks: dict = None, **kwargs)\n</code></pre> <p>               Bases: <code>ModelView</code></p> <p>HooksView is a custom view that accepts a dictionary of hooks on different events.</p> <p>Initialize the HooksView with hooks.</p> <p>Parameters:</p> Name Type Description Default <p>Positional arguments.</p> <code>()</code> <code>dict</code> <p>A dictionary of hooks for different events.</p> <code>None</code> <p>Keyword arguments.</p> <code>{}</code> <p>Methods:</p> Name Description <code>after_create</code> <p>Run after creating an object.</p> <code>after_delete</code> <p>Run after deleting an object.</p> <code>after_edit</code> <p>Run after editing an object.</p> <code>before_create</code> <p>Run before creating an object.</p> <code>before_delete</code> <p>Run before deleting an object.</p> <code>before_edit</code> <p>Run before editing an object.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>def __init__(self, *args, hooks: dict = None, **kwargs) -&gt; None:  # noqa: ANN002, ANN003\n    \"\"\"\n    Initialize the HooksView with hooks.\n\n    Args:\n        *args: Positional arguments.\n        hooks (dict): A dictionary of hooks for different events.\n        **kwargs: Keyword arguments.\n\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.hooks = hooks or {}\n</code></pre>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.BaseView(*args)","title":"<code>*args</code>","text":""},{"location":"reference/kamihi/web/views/#kamihi.web.views.BaseView(hooks)","title":"<code>hooks</code>","text":""},{"location":"reference/kamihi/web/views/#kamihi.web.views.BaseView(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/kamihi/web/views/#kamihi.web.views.BaseView.after_create","title":"after_create  <code>async</code>","text":"<pre><code>after_create(request: Request, obj: Any) -&gt; None\n</code></pre> <p>Run after creating an object.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>async def after_create(self, request: Request, obj: Any) -&gt; None:\n    \"\"\"Run after creating an object.\"\"\"\n    await self._run_hooks(self.hooks.get(\"after_create\", []), request, obj)\n</code></pre>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.BaseView.after_delete","title":"after_delete  <code>async</code>","text":"<pre><code>after_delete(request: Request, obj: Any) -&gt; None\n</code></pre> <p>Run after deleting an object.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>async def after_delete(self, request: Request, obj: Any) -&gt; None:\n    \"\"\"Run after deleting an object.\"\"\"\n    await self._run_hooks(self.hooks.get(\"after_delete\", []), request, obj)\n</code></pre>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.BaseView.after_edit","title":"after_edit  <code>async</code>","text":"<pre><code>after_edit(request: Request, obj: Any) -&gt; None\n</code></pre> <p>Run after editing an object.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>async def after_edit(self, request: Request, obj: Any) -&gt; None:\n    \"\"\"Run after editing an object.\"\"\"\n    await self._run_hooks(self.hooks.get(\"after_edit\", []), request, obj)\n</code></pre>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.BaseView.before_create","title":"before_create  <code>async</code>","text":"<pre><code>before_create(\n    request: Request, data: dict[str, Any], obj: Any\n) -&gt; None\n</code></pre> <p>Run before creating an object.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>async def before_create(self, request: Request, data: dict[str, Any], obj: Any) -&gt; None:\n    \"\"\"Run before creating an object.\"\"\"\n    await self._run_hooks(self.hooks.get(\"before_create\", []), request, data, obj)\n</code></pre>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.BaseView.before_delete","title":"before_delete  <code>async</code>","text":"<pre><code>before_delete(request: Request, obj: Any) -&gt; None\n</code></pre> <p>Run before deleting an object.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>async def before_delete(self, request: Request, obj: Any) -&gt; None:\n    \"\"\"Run before deleting an object.\"\"\"\n    await self._run_hooks(self.hooks.get(\"before_delete\", []), request, obj)\n</code></pre>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.BaseView.before_edit","title":"before_edit  <code>async</code>","text":"<pre><code>before_edit(\n    request: Request, data: dict[str, Any], obj: Any\n) -&gt; None\n</code></pre> <p>Run before editing an object.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>async def before_edit(self, request: Request, data: dict[str, Any], obj: Any) -&gt; None:\n    \"\"\"Run before editing an object.\"\"\"\n    await self._run_hooks(self.hooks.get(\"before_edit\", []), request, data, obj)\n</code></pre>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.JobView","title":"JobView","text":"<pre><code>JobView(\n    *args,\n    enabled: bool,\n    run_job_callback: Callable,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>BaseView</code></p> <p>JobView is a custom view for managing jobs in the admin interface.</p> <p>Initialize the JobView with optional run_job_callback.</p> <p>Parameters:</p> Name Type Description Default <p>Positional arguments.</p> <code>()</code> <code>bool</code> <p>Flag indicating if jobs are enabled.</p> required <code>list</code> <p>A list of callables to run when a job is executed.</p> required <p>Keyword arguments.</p> <code>{}</code> <p>Methods:</p> Name Description <code>run_job</code> <p>Run the job manually.</p> <code>validate</code> <p>Validate the job data before creating or editing.</p> Source code in <code>src/kamihi/web/views/job_view.py</code> <pre><code>def __init__(self, *args, enabled: bool, run_job_callback: Callable, **kwargs) -&gt; None:  # noqa: ANN002, ANN003\n    \"\"\"\n    Initialize the JobView with optional run_job_callback.\n\n    Args:\n        *args: Positional arguments.\n        enabled (bool): Flag indicating if jobs are enabled.\n        run_job_callback (list): A list of callables to run when a job is executed.\n        **kwargs: Keyword arguments.\n\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.enabled = enabled\n    if not self.enabled:\n        self.list_template = \"job/disabled.html\"\n        self.detail_template = \"job/disabled.html\"\n        self.create_template = \"job/disabled.html\"\n        self.edit_template = \"job/disabled.html\"\n    self.run_job_callback = run_job_callback\n</code></pre>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.JobView(*args)","title":"<code>*args</code>","text":""},{"location":"reference/kamihi/web/views/#kamihi.web.views.JobView(enabled)","title":"<code>enabled</code>","text":""},{"location":"reference/kamihi/web/views/#kamihi.web.views.JobView(run_job_callback)","title":"<code>run_job_callback</code>","text":""},{"location":"reference/kamihi/web/views/#kamihi.web.views.JobView(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/kamihi/web/views/#kamihi.web.views.JobView.run_job","title":"run_job  <code>async</code>","text":"<pre><code>run_job(request: Request, pk: Any) -&gt; str\n</code></pre> <p>Run the job manually.</p> Source code in <code>src/kamihi/web/views/job_view.py</code> <pre><code>@row_action(\n    name=\"run_job\",\n    text=\"Run job manually\",\n    icon_class=\"fas fa-play\",\n    confirmation=\"Are you sure you want to run this job manually?\",\n    submit_btn_text=\"Yes, run job\",\n    submit_btn_class=\"btn-success\",\n)\nasync def run_job(self, request: Request, pk: Any) -&gt; str:\n    \"\"\"Run the job manually.\"\"\"\n    await self.run_job_callback(pk)\n    return \"Job executed successfully.\"\n</code></pre>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.JobView.validate","title":"validate  <code>async</code>","text":"<pre><code>validate(request: Request, data: dict[str, Any]) -&gt; None\n</code></pre> <p>Validate the job data before creating or editing.</p> Source code in <code>src/kamihi/web/views/job_view.py</code> <pre><code>async def validate(self, request: Request, data: dict[str, Any]) -&gt; None:\n    \"\"\"Validate the job data before creating or editing.\"\"\"\n    errors: dict[str, str] = {}\n\n    if not is_valid_cron_expression(data[\"cron_expression\"]):\n        errors[\"cron_expression\"] = \"Invalid cron expression.\"\n\n    if len(errors) &gt; 0:\n        raise FormValidationError(errors)\n    return await super().validate(request, data)\n</code></pre>"},{"location":"reference/kamihi/web/views/#kamihi.web.views.UserView","title":"UserView","text":"<pre><code>UserView(*args, hooks: dict = None, **kwargs)\n</code></pre> <p>               Bases: <code>BaseView</code></p> <p>UserView is a custom view for managing users in the admin interface.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>def __init__(self, *args, hooks: dict = None, **kwargs) -&gt; None:  # noqa: ANN002, ANN003\n    \"\"\"\n    Initialize the HooksView with hooks.\n\n    Args:\n        *args: Positional arguments.\n        hooks (dict): A dictionary of hooks for different events.\n        **kwargs: Keyword arguments.\n\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.hooks = hooks or {}\n</code></pre>"},{"location":"reference/kamihi/web/views/action_view/","title":"action_view","text":""},{"location":"reference/kamihi/web/views/action_view/#kamihi.web.views.action_view","title":"kamihi.web.views.action_view","text":"<p>Actions view module.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>ActionView</code> <p>ReadOnlyView makes the model read-only in the admin interface.</p>"},{"location":"reference/kamihi/web/views/action_view/#kamihi.web.views.action_view.ActionView","title":"ActionView","text":"<pre><code>ActionView(*args, hooks: dict = None, **kwargs)\n</code></pre> <p>               Bases: <code>BaseView</code></p> <p>ReadOnlyView makes the model read-only in the admin interface.</p> <p>Methods:</p> Name Description <code>can_create</code> <p>Check if the user can create a new instance of the model.</p> <code>can_delete</code> <p>Check if the user can edit an instance of the model.</p> <code>can_edit</code> <p>Check if the user can edit an instance of the model.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>def __init__(self, *args, hooks: dict = None, **kwargs) -&gt; None:  # noqa: ANN002, ANN003\n    \"\"\"\n    Initialize the HooksView with hooks.\n\n    Args:\n        *args: Positional arguments.\n        hooks (dict): A dictionary of hooks for different events.\n        **kwargs: Keyword arguments.\n\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.hooks = hooks or {}\n</code></pre>"},{"location":"reference/kamihi/web/views/action_view/#kamihi.web.views.action_view.ActionView.can_create","title":"can_create","text":"<pre><code>can_create(request: Request) -&gt; bool\n</code></pre> <p>Check if the user can create a new instance of the model.</p> Source code in <code>src/kamihi/web/views/action_view.py</code> <pre><code>def can_create(self, request: Request) -&gt; bool:  # noqa: ARG002\n    \"\"\"Check if the user can create a new instance of the model.\"\"\"\n    return False\n</code></pre>"},{"location":"reference/kamihi/web/views/action_view/#kamihi.web.views.action_view.ActionView.can_delete","title":"can_delete","text":"<pre><code>can_delete(request: Request) -&gt; bool\n</code></pre> <p>Check if the user can edit an instance of the model.</p> Source code in <code>src/kamihi/web/views/action_view.py</code> <pre><code>def can_delete(self, request: Request) -&gt; bool:  # noqa: ARG002\n    \"\"\"Check if the user can edit an instance of the model.\"\"\"\n    return False\n</code></pre>"},{"location":"reference/kamihi/web/views/action_view/#kamihi.web.views.action_view.ActionView.can_edit","title":"can_edit","text":"<pre><code>can_edit(request: Request) -&gt; bool\n</code></pre> <p>Check if the user can edit an instance of the model.</p> Source code in <code>src/kamihi/web/views/action_view.py</code> <pre><code>def can_edit(self, request: Request) -&gt; bool:  # noqa: ARG002\n    \"\"\"Check if the user can edit an instance of the model.\"\"\"\n    return False\n</code></pre>"},{"location":"reference/kamihi/web/views/base_view/","title":"base_view","text":""},{"location":"reference/kamihi/web/views/base_view/#kamihi.web.views.base_view","title":"kamihi.web.views.base_view","text":"<p>BaseView for Starlette-Admin with hooks for CRUD operations.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>BaseView</code> <p>HooksView is a custom view that accepts a dictionary of hooks on different events.</p>"},{"location":"reference/kamihi/web/views/base_view/#kamihi.web.views.base_view.BaseView","title":"BaseView","text":"<pre><code>BaseView(*args, hooks: dict = None, **kwargs)\n</code></pre> <p>               Bases: <code>ModelView</code></p> <p>HooksView is a custom view that accepts a dictionary of hooks on different events.</p> <p>Initialize the HooksView with hooks.</p> <p>Parameters:</p> Name Type Description Default <p>Positional arguments.</p> <code>()</code> <code>dict</code> <p>A dictionary of hooks for different events.</p> <code>None</code> <p>Keyword arguments.</p> <code>{}</code> <p>Methods:</p> Name Description <code>after_create</code> <p>Run after creating an object.</p> <code>after_delete</code> <p>Run after deleting an object.</p> <code>after_edit</code> <p>Run after editing an object.</p> <code>before_create</code> <p>Run before creating an object.</p> <code>before_delete</code> <p>Run before deleting an object.</p> <code>before_edit</code> <p>Run before editing an object.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>def __init__(self, *args, hooks: dict = None, **kwargs) -&gt; None:  # noqa: ANN002, ANN003\n    \"\"\"\n    Initialize the HooksView with hooks.\n\n    Args:\n        *args: Positional arguments.\n        hooks (dict): A dictionary of hooks for different events.\n        **kwargs: Keyword arguments.\n\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.hooks = hooks or {}\n</code></pre>"},{"location":"reference/kamihi/web/views/base_view/#kamihi.web.views.base_view.BaseView(*args)","title":"<code>*args</code>","text":""},{"location":"reference/kamihi/web/views/base_view/#kamihi.web.views.base_view.BaseView(hooks)","title":"<code>hooks</code>","text":""},{"location":"reference/kamihi/web/views/base_view/#kamihi.web.views.base_view.BaseView(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/kamihi/web/views/base_view/#kamihi.web.views.base_view.BaseView.after_create","title":"after_create  <code>async</code>","text":"<pre><code>after_create(request: Request, obj: Any) -&gt; None\n</code></pre> <p>Run after creating an object.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>async def after_create(self, request: Request, obj: Any) -&gt; None:\n    \"\"\"Run after creating an object.\"\"\"\n    await self._run_hooks(self.hooks.get(\"after_create\", []), request, obj)\n</code></pre>"},{"location":"reference/kamihi/web/views/base_view/#kamihi.web.views.base_view.BaseView.after_delete","title":"after_delete  <code>async</code>","text":"<pre><code>after_delete(request: Request, obj: Any) -&gt; None\n</code></pre> <p>Run after deleting an object.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>async def after_delete(self, request: Request, obj: Any) -&gt; None:\n    \"\"\"Run after deleting an object.\"\"\"\n    await self._run_hooks(self.hooks.get(\"after_delete\", []), request, obj)\n</code></pre>"},{"location":"reference/kamihi/web/views/base_view/#kamihi.web.views.base_view.BaseView.after_edit","title":"after_edit  <code>async</code>","text":"<pre><code>after_edit(request: Request, obj: Any) -&gt; None\n</code></pre> <p>Run after editing an object.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>async def after_edit(self, request: Request, obj: Any) -&gt; None:\n    \"\"\"Run after editing an object.\"\"\"\n    await self._run_hooks(self.hooks.get(\"after_edit\", []), request, obj)\n</code></pre>"},{"location":"reference/kamihi/web/views/base_view/#kamihi.web.views.base_view.BaseView.before_create","title":"before_create  <code>async</code>","text":"<pre><code>before_create(\n    request: Request, data: dict[str, Any], obj: Any\n) -&gt; None\n</code></pre> <p>Run before creating an object.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>async def before_create(self, request: Request, data: dict[str, Any], obj: Any) -&gt; None:\n    \"\"\"Run before creating an object.\"\"\"\n    await self._run_hooks(self.hooks.get(\"before_create\", []), request, data, obj)\n</code></pre>"},{"location":"reference/kamihi/web/views/base_view/#kamihi.web.views.base_view.BaseView.before_delete","title":"before_delete  <code>async</code>","text":"<pre><code>before_delete(request: Request, obj: Any) -&gt; None\n</code></pre> <p>Run before deleting an object.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>async def before_delete(self, request: Request, obj: Any) -&gt; None:\n    \"\"\"Run before deleting an object.\"\"\"\n    await self._run_hooks(self.hooks.get(\"before_delete\", []), request, obj)\n</code></pre>"},{"location":"reference/kamihi/web/views/base_view/#kamihi.web.views.base_view.BaseView.before_edit","title":"before_edit  <code>async</code>","text":"<pre><code>before_edit(\n    request: Request, data: dict[str, Any], obj: Any\n) -&gt; None\n</code></pre> <p>Run before editing an object.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>async def before_edit(self, request: Request, data: dict[str, Any], obj: Any) -&gt; None:\n    \"\"\"Run before editing an object.\"\"\"\n    await self._run_hooks(self.hooks.get(\"before_edit\", []), request, data, obj)\n</code></pre>"},{"location":"reference/kamihi/web/views/job_view/","title":"job_view","text":""},{"location":"reference/kamihi/web/views/job_view/#kamihi.web.views.job_view","title":"kamihi.web.views.job_view","text":"<p>Job view module for Kamihi web application.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>JobView</code> <p>JobView is a custom view for managing jobs in the admin interface.</p>"},{"location":"reference/kamihi/web/views/job_view/#kamihi.web.views.job_view.JobView","title":"JobView","text":"<pre><code>JobView(\n    *args,\n    enabled: bool,\n    run_job_callback: Callable,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>BaseView</code></p> <p>JobView is a custom view for managing jobs in the admin interface.</p> <p>Initialize the JobView with optional run_job_callback.</p> <p>Parameters:</p> Name Type Description Default <p>Positional arguments.</p> <code>()</code> <code>bool</code> <p>Flag indicating if jobs are enabled.</p> required <code>list</code> <p>A list of callables to run when a job is executed.</p> required <p>Keyword arguments.</p> <code>{}</code> <p>Methods:</p> Name Description <code>run_job</code> <p>Run the job manually.</p> <code>validate</code> <p>Validate the job data before creating or editing.</p> Source code in <code>src/kamihi/web/views/job_view.py</code> <pre><code>def __init__(self, *args, enabled: bool, run_job_callback: Callable, **kwargs) -&gt; None:  # noqa: ANN002, ANN003\n    \"\"\"\n    Initialize the JobView with optional run_job_callback.\n\n    Args:\n        *args: Positional arguments.\n        enabled (bool): Flag indicating if jobs are enabled.\n        run_job_callback (list): A list of callables to run when a job is executed.\n        **kwargs: Keyword arguments.\n\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.enabled = enabled\n    if not self.enabled:\n        self.list_template = \"job/disabled.html\"\n        self.detail_template = \"job/disabled.html\"\n        self.create_template = \"job/disabled.html\"\n        self.edit_template = \"job/disabled.html\"\n    self.run_job_callback = run_job_callback\n</code></pre>"},{"location":"reference/kamihi/web/views/job_view/#kamihi.web.views.job_view.JobView(*args)","title":"<code>*args</code>","text":""},{"location":"reference/kamihi/web/views/job_view/#kamihi.web.views.job_view.JobView(enabled)","title":"<code>enabled</code>","text":""},{"location":"reference/kamihi/web/views/job_view/#kamihi.web.views.job_view.JobView(run_job_callback)","title":"<code>run_job_callback</code>","text":""},{"location":"reference/kamihi/web/views/job_view/#kamihi.web.views.job_view.JobView(**kwargs)","title":"<code>**kwargs</code>","text":""},{"location":"reference/kamihi/web/views/job_view/#kamihi.web.views.job_view.JobView.run_job","title":"run_job  <code>async</code>","text":"<pre><code>run_job(request: Request, pk: Any) -&gt; str\n</code></pre> <p>Run the job manually.</p> Source code in <code>src/kamihi/web/views/job_view.py</code> <pre><code>@row_action(\n    name=\"run_job\",\n    text=\"Run job manually\",\n    icon_class=\"fas fa-play\",\n    confirmation=\"Are you sure you want to run this job manually?\",\n    submit_btn_text=\"Yes, run job\",\n    submit_btn_class=\"btn-success\",\n)\nasync def run_job(self, request: Request, pk: Any) -&gt; str:\n    \"\"\"Run the job manually.\"\"\"\n    await self.run_job_callback(pk)\n    return \"Job executed successfully.\"\n</code></pre>"},{"location":"reference/kamihi/web/views/job_view/#kamihi.web.views.job_view.JobView.validate","title":"validate  <code>async</code>","text":"<pre><code>validate(request: Request, data: dict[str, Any]) -&gt; None\n</code></pre> <p>Validate the job data before creating or editing.</p> Source code in <code>src/kamihi/web/views/job_view.py</code> <pre><code>async def validate(self, request: Request, data: dict[str, Any]) -&gt; None:\n    \"\"\"Validate the job data before creating or editing.\"\"\"\n    errors: dict[str, str] = {}\n\n    if not is_valid_cron_expression(data[\"cron_expression\"]):\n        errors[\"cron_expression\"] = \"Invalid cron expression.\"\n\n    if len(errors) &gt; 0:\n        raise FormValidationError(errors)\n    return await super().validate(request, data)\n</code></pre>"},{"location":"reference/kamihi/web/views/user_view/","title":"user_view","text":""},{"location":"reference/kamihi/web/views/user_view/#kamihi.web.views.user_view","title":"kamihi.web.views.user_view","text":"<p>User view module for Kamihi web application.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>UserView</code> <p>UserView is a custom view for managing users in the admin interface.</p>"},{"location":"reference/kamihi/web/views/user_view/#kamihi.web.views.user_view.UserView","title":"UserView","text":"<pre><code>UserView(*args, hooks: dict = None, **kwargs)\n</code></pre> <p>               Bases: <code>BaseView</code></p> <p>UserView is a custom view for managing users in the admin interface.</p> Source code in <code>src/kamihi/web/views/base_view.py</code> <pre><code>def __init__(self, *args, hooks: dict = None, **kwargs) -&gt; None:  # noqa: ANN002, ANN003\n    \"\"\"\n    Initialize the HooksView with hooks.\n\n    Args:\n        *args: Positional arguments.\n        hooks (dict): A dictionary of hooks for different events.\n        **kwargs: Keyword arguments.\n\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.hooks = hooks or {}\n</code></pre>"},{"location":"reference/kamihi/web/web/","title":"web","text":""},{"location":"reference/kamihi/web/web/#kamihi.web.web","title":"kamihi.web.web","text":"<p>Web interface main file.</p> License <p>MIT</p> <p>Classes:</p> Name Description <code>KamihiWeb</code> <p>KamihiWeb is a class that sets up a web server for the Kamihi application.</p>"},{"location":"reference/kamihi/web/web/#kamihi.web.web.KamihiWeb","title":"KamihiWeb","text":"<pre><code>KamihiWeb(\n    hooks: dict[\n        Literal[\n            \"before_create\",\n            \"after_create\",\n            \"before_edit\",\n            \"after_edit\",\n            \"before_delete\",\n            \"after_delete\",\n            \"run_job\",\n        ],\n        list[Callable],\n    ] = None,\n)\n</code></pre> <p>               Bases: <code>Thread</code></p> <p>KamihiWeb is a class that sets up a web server for the Kamihi application.</p> <p>This class is responsible for creating and running a web server with an admin interface. It also handles the database connection and configuration.</p> <p>Attributes:</p> Name Type Description <code>app</code> <code>Starlette</code> <p>The application instance.</p> <code>admin</code> <code>Admin</code> <p>The Starlette-Admin instance for the admin interface.</p> <p>Initialize the KamihiWeb instance.</p> <p>Methods:</p> Name Description <code>run</code> <p>Run the app.</p> Source code in <code>src/kamihi/web/web.py</code> <pre><code>def __init__(\n    self,\n    hooks: dict[\n        Literal[\n            \"before_create\", \"after_create\", \"before_edit\", \"after_edit\", \"before_delete\", \"after_delete\", \"run_job\"\n        ],\n        list[Callable],\n    ] = None,\n) -&gt; None:\n    \"\"\"Initialize the KamihiWeb instance.\"\"\"\n    settings = get_settings()\n\n    super().__init__()\n\n    self.hooks = hooks\n    self.host = settings.web.host\n    self.port = settings.web.port\n\n    self.daemon = True\n\n    self.app = None\n    self.admin = None\n</code></pre>"},{"location":"reference/kamihi/web/web/#kamihi.web.web.KamihiWeb.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the app.</p> Source code in <code>src/kamihi/web/web.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the app.\"\"\"\n    self._create_app()\n\n    uvicorn.run(\n        self.app,\n        host=self.host,\n        port=self.port,\n        log_config={\n            \"version\": 1,\n            \"disable_existing_loggers\": False,\n            \"formatters\": {\n                \"default\": {\n                    \"()\": \"uvicorn.logging.DefaultFormatter\",\n                    \"fmt\": \"%(message)s\",\n                },\n                \"access\": {\n                    \"()\": \"uvicorn.logging.AccessFormatter\",\n                    \"fmt\": '%(client_addr)s - \"%(request_line)s\" %(status_code)s',  # noqa: E501\n                },\n            },\n            \"handlers\": {\n                \"default\": {\n                    \"formatter\": \"default\",\n                    \"class\": \"kamihi.web.web._InterceptHandler\",\n                },\n                \"access\": {\n                    \"formatter\": \"access\",\n                    \"class\": \"kamihi.web.web._InterceptHandler\",\n                },\n            },\n            \"loggers\": {\n                \"uvicorn\": {\"handlers\": [\"default\"], \"level\": \"DEBUG\", \"propagate\": False},\n                \"uvicorn.error\": {\"level\": \"DEBUG\"},\n                \"uvicorn.access\": {\"handlers\": [\"access\"], \"level\": \"DEBUG\", \"propagate\": False},\n            },\n        },\n    )\n</code></pre>"}]}